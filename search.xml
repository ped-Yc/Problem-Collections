<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【方法论】代码重构的一点心得</title>
    <url>/2023/02/11/MethodologyRefactoring/</url>
    <content><![CDATA[<h1 id="重构（Refactoring）"><a href="#重构（Refactoring）" class="headerlink" title="重构（Refactoring）"></a>重构（Refactoring）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直在做前端重构的工作，多少有些感想，特此记录。</p>
<p>首先，项目的历史太悠久了，AngularJS 的项目，</p>
<h2 id="一、什么是重构？为什么要重构？重构要达成什么目标？"><a href="#一、什么是重构？为什么要重构？重构要达成什么目标？" class="headerlink" title="一、什么是重构？为什么要重构？重构要达成什么目标？"></a>一、什么是重构？为什么要重构？重构要达成什么目标？</h2><p><strong>什么是重构</strong></p>
<p>在<code>不改变代码外在行为</code>的前提下，对代码进行修改，以<code>改进程序的内部结构</code>。</p>
<p><strong>为什么要重构</strong></p>
<p>在软件工程中，开发迭代的过程实际上是一个熵增的过程，软件系统会随着生命周期的进行变得越来越臃肿、混乱、冗余，从而增加维护与进一步迭代的成本。而重构可以<code>偿还技术债务、改进软件结构、减小维护和迭代的成本、增加产品可信</code>。</p>
<p><strong>重构要达成什么目标？</strong></p>
<ol>
<li>系统结构重新梳理：旧系统在设计上可能有许多疏漏，由于经验的欠缺或者考虑不周到，这是难以避免的。新系统应该见贤思齐、查漏补缺，例如重新设计基类、文件结构和继承关系，争取让系统更加完善。</li>
<li>公共资源重新梳理：</li>
<li>业务需求重新梳理：</li>
</ol>
<h2 id="二、重构有哪些分类？什么时候重构？重构有哪些原则？"><a href="#二、重构有哪些分类？什么时候重构？重构有哪些原则？" class="headerlink" title="二、重构有哪些分类？什么时候重构？重构有哪些原则？"></a>二、重构有哪些分类？什么时候重构？重构有哪些原则？</h2><p><strong>重构有哪些分类？</strong></p>
<ul>
<li>小粒度重构（函数级、小模块）</li>
<li>大粒度重构（架构级、大模块）</li>
</ul>
<p><strong>什么时候重构？</strong></p>
<ul>
<li>新增需求时（小粒度）</li>
<li>修改 BUG 时（小粒度）</li>
<li>复审代码时（大粒度）</li>
<li>代码逻辑混乱、依赖混杂（大粒度）</li>
</ul>
<p><strong>重构有哪些原则？</strong></p>
<ul>
<li>先评审，再重构，不要反复推翻重来</li>
<li>确保模块的功能完整，否则不重构该模块</li>
<li>新增需求时，不要改动既有代码（小粒度）</li>
<li>重构既有代码时，不要新增功能（小粒度）</li>
</ul>
<h2 id="三、重构工作流程"><a href="#三、重构工作流程" class="headerlink" title="三、重构工作流程"></a>三、重构工作流程</h2><ol>
<li>前期准备，搭架子<ul>
<li>构建对应技术栈的文件结构、代码关系</li>
<li>整理公共资源、公共能力</li>
<li>整理业务需求，确保没有遗漏的需求</li>
</ul>
</li>
<li>前期准备，分需求、培训（主要涉及文件结构和公共资源）</li>
<li>开始重构</li>
</ol>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【方法论】前端状态管理的一些理解</title>
    <url>/2022/06/15/MethodologyStateManagement/</url>
    <content><![CDATA[<h1 id="前端状态管理的一些理解"><a href="#前端状态管理的一些理解" class="headerlink" title="前端状态管理的一些理解"></a>前端状态管理的一些理解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在工作中，我们常常会使用状态管理工具，例如：vue2 的 vuex，vue3 的 pinia，angular 的 NgRx，react 的 redux。有时难免会有一些疑问，为什么要使用状态管理工具，</p>
<p>一个有趣的比方：假设有一个图书馆，当这个图书馆很小时，读者要找到一本书是非常简单的，就像一个小的前端项目，直接使用组件对数据进行存储更改是更加快捷方便的方式。但如果这个图书馆很大，人流量也很多，读者找一本书或者归还一本书就会很吃力。而状态管理器就像这个图书馆的电脑，当你要找一本书时，如果这是一本教科书，就会去教科书的栏目内检索，就像写的<code>action = &#39;schoolbook&#39;;</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【方法论】JS 执行流程</title>
    <url>/2023/02/21/MethodologyJSExcutionProcess/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><code>前言</code></h2><p>本文主要解释 JS 引擎在遇见 script 代码块时，从编译到执行具体经历了些什么？</p>
<p>一些关于作用域与闭包还有<code>this</code>关键字的问题可能被解答：</p>
<ul>
<li>为什么会产生变量提升？</li>
<li>闭包的产生原理是什么？</li>
<li>多个 script 代码块间是以什么顺序来执行的？</li>
<li>为什么定义在不同代码块间的方法可以共通？通过本文都可以得到解答。</li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a><code>基础概念</code></h2><ul>
<li><p>JavaScript 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。<br><code>解释型</code>：JS 引擎在运行 JS 代码时，是利用解释器一边编译一边执行的。</p>
<p>如此便避免不了一种情况：某些代码多次重复的运行，例如 for 循环，在编译型语言中，for 循环块中的代码将以机器码执行多次；而在解释型语言中，for 循环块中的代码将被解释多次并执行，如此便有了很大的耗损。</p>
<p><code>即时编译型</code>：于是 JS 引擎就加入了<code>JIT</code>（Just-in-time）进行编译优化，例如对重复语句和类型判断进行优化。</p>
</li>
<li><p>引擎、编译器与作用域<br>  引擎：从头到尾负责整个 javascript 程序的编译及执行过程。浏览器不同，其引擎也不同，比如 Chrome 采用的是 v8，Safari 采用的是 SquirrelFish Extreme。</p>
<p>  编译器：编译过程主要分为”词法分析”、“语法分析”及“代码生成“。</p>
<blockquote>
</blockquote>
<p>  作用域（Scope）：根据名称查找变量的一套规则，用于管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p>
</li>
<li><p>执行上下文（Excution Context EC）&amp;&amp; 执行上下文栈（Excution Context Stack ECS）<br>  存在三种 EC：全局执行上下文  GlobalEC ，函数执行上下文  Function EC，Eval。</p>
<p>  ECS：引擎记录 EC 的容器，栈底是 GlobalEC ，只有在关闭页面时出栈；栈顶是当前正在执行的 EC ，函数执行完毕后出栈，并将执行权交给下一个 EC 。</p>
</li>
<li><p>变量对象（Variable Object）&amp;&amp; 活动对象（Activation Object）<br>  VO：EC 中用来存储变量声明（必须是 var 关键字声明而不是 let 与 const）与函数声明（必须是显式声明而不是表达式）的容器。由引擎实现，不能访问到。</p>
<p>  AO：可以理解为 VO 的实例化，函数调用时在 EC 中被激活，成员属性能被访问。</p>
</li>
<li><p>LHS（Left Hand Side） &amp;&amp; RHS（Right Hand Side）<br>  LHS：赋值操作的目标。例如：a&#x3D;2; 是对 a 进行 LHS 查询。</p>
<p>  RHS：赋值操作的源头。例如：console.log(a); 是对 a 进行 RHS 查询。</p>
<blockquote>
</blockquote>
<p>  非严格模式下，LHS 查询不到变量会在顶层作用域创建具有该名称的变量，RHS 查询不到变量会报 ReferenceError 的异常；严格模式下禁止自动创建全局变量，两种查询方式失败均报 ReferenceError 的异常。</p>
</li>
</ul>
<h2 id="JS-代码执行流程"><a href="#JS-代码执行流程" class="headerlink" title="JS 代码执行流程"></a><code>JS 代码执行流程</code></h2><ol>
<li>–&gt;进入 script 标签</li>
<li>–&gt;【预编译】JS 引擎创建全局 EC，全局 EC 入栈</li>
<li>–&gt;【编译】JS 解释器开始对代码<code>逐行</code>进行分词、语法分析、代码生成</li>
<li>–&gt;有错则抛出，终止执行；无错继续向下逐行执行</li>
<li>–&gt;【预编译】调用函数前，创建函数 EC，EC 入栈</li>
<li>–&gt;【编译】</li>
<li>–&gt;有错则抛出，终止执行；无错继续向下执行</li>
<li>–&gt;函数执行完毕，EC 出栈</li>
<li>–&gt;继续以上步骤</li>
<li>–&gt;页面销毁，全局 EC 出栈</li>
<li>–&gt;结束</li>
</ol>
<p><code>创建当前环境 EC 流程如下：</code></p>
<p>1、初始化作用域 [[Scope]]，（拷贝传入的父执行上下文的 Scope），数据结构应该是数组或者链表。</p>
<p>例如：[[Scope]] : AO1（当前）–&gt;VO（全局）</p>
<p>2、创建活动对象，创建完成之后，将活动对象推入作用域链的最前端：</p>
<p>例如：[[Scope]] : AO2（当前）–&gt;AO1（父级）–&gt;VO（全局）</p>
<p>2.1、创建 arguments 对象，检查上下文，初始化参数名称和值并创建引用的复制。（函数中存在）</p>
<p>2.2、创建形参，通过实参赋值。（函数中存在）</p>
<p>2.3、扫描上下文的函数声明（而非函数表达式）：</p>
<p>为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。如果函数的名字已经存在，引用指针将被重写。函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值</p>
<p>2.4、扫描上下文的变量声明：</p>
<p>为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为 undefined，如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。</p>
<p>3、求出上下文内部 this 的值。</p>
<blockquote>
<p>从以上流程中可以观察到<code>作用域、变量提升和 this</code>，接下来结合代码具体分析。</p>
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a><code>代码分析</code></h2><p>1、EC 创建流程与变量提升</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;outer&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a+<span class="string">&#x27;--a--start&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b+<span class="string">&#x27;--b--start&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c+<span class="string">&#x27;--c--start&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`------------`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a+<span class="string">&#x27;--a--end&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b+<span class="string">&#x27;--b--end&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c+<span class="string">&#x27;--c--end&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">22</span>);<span class="comment">// 对形参 i 的 LHS 查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="literal">undefined</span>--a--start<span class="comment">// 变量 a 声明时提升赋值为 undefined</span></span><br><span class="line"><span class="literal">undefined</span>--b--start<span class="comment">// 变量 b 声明时提升赋值为 undefined</span></span><br><span class="line">ƒ <span class="title function_">c</span>(<span class="params"></span>) &#123;&#125;--c--start<span class="comment">// 函数 c 声明时提升指向 c 的引用</span></span><br><span class="line">------------</span><br><span class="line">hello--a--end<span class="comment">// 此时赋值语句执行完毕，a 的值为 hello</span></span><br><span class="line">ƒ() &#123;&#125;--b--end<span class="comment">// 此时赋值语句执行完毕，b 指向 b 的引用</span></span><br><span class="line">ƒ <span class="title function_">c</span>(<span class="params"></span>) &#123;&#125;--c--end<span class="comment">// 无变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析</span></span><br><span class="line"><span class="comment">// 代码载入前，创建全局 EC 的伪代码</span></span><br><span class="line"><span class="title class_">GlobalEC</span> : &#123;</span><br><span class="line">    [[<span class="title class_">Scope</span>]] : [&#123;<span class="variable constant_">VO</span>&#125;],</span><br><span class="line">    <span class="variable constant_">VO</span> : &#123;</span><br><span class="line">        foo : fnFoo,<span class="comment">// 函数声明优先，指向函数 Foo 的引用</span></span><br><span class="line">        a :  <span class="literal">undefined</span><span class="comment">// 变量声明</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="variable language_">this</span><span class="comment">// 指向全局</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数 foo(22) 时，创建当前 EC 的伪代码</span></span><br><span class="line"><span class="title class_">CurrentEC</span> : &#123;</span><br><span class="line">    [[<span class="title class_">Scope</span>]] : [&#123;<span class="variable constant_">AO</span>&#125;, &#123;<span class="variable constant_">VO</span>&#125;],</span><br><span class="line">    <span class="variable constant_">AO</span> : &#123;</span><br><span class="line">        <span class="comment">// 顺序：arguments 对象 形参 函数声明 变量声明</span></span><br><span class="line">        <span class="variable language_">arguments</span> : &#123;</span><br><span class="line">            <span class="number">0</span> : <span class="number">22</span>,</span><br><span class="line">            length : <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        i : <span class="number">22</span>,<span class="comment">// 形参，接受实参赋值</span></span><br><span class="line">        c : fnC,<span class="comment">//指向函数 c 的引用</span></span><br><span class="line">        a : <span class="literal">undefined</span>,</span><br><span class="line">        b : <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="variable language_">this</span><span class="comment">// 指向函数的调用者，这里指向全局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2、多个 script 块间的执行过程</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script1 start&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>,a);</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> b=<span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script1 end&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script2 start&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> a=<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>,b);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script2 end&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">     script1 start</span></span><br><span class="line"><span class="comment">     Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">     script2 start</span></span><br><span class="line"><span class="comment">     b undefined</span></span><br><span class="line"><span class="comment">     script2 end</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 1、从代码运行结果可以看出，JS 执行流在进入第一个 script 块时，首先会创建全局 EC ，将 b 的声明加入 AO 并推入作用域中（所以第二个 script 块中的代码才能访问到 b），全局 EC 压入 ECS。</span></span><br><span class="line"><span class="comment"> 2、逐行的进行分词、语法检查、代码生成，然后执行。</span></span><br><span class="line"><span class="comment">     2.1、在 console.log(&#x27;script1 start&#x27;); 这行代码中，不存在语法错误，执行，输出 start。</span></span><br><span class="line"><span class="comment">     2.2、在 console.log(&#x27;a&#x27;,a); 这行代码中，对变量 a 进行 RHS 查询，在作用域链中找不到 a ，报 ReferenceError，script 块中断执行。</span></span><br><span class="line"><span class="comment"> 3、JS 执行流进入第二个 script 块，仍然在全局 EC（JS 引擎只会存在一个全局 EC），将 a 的声明加入 AO（与第一个代码块相同，每个 EC 绑定唯一的 VO|AO） 并推入作用域。</span></span><br><span class="line"><span class="comment"> 4、逐行的进行分词、语法检查、代码生成，然后执行。</span></span><br><span class="line"><span class="comment">     4.1、在 console.log(&#x27;b&#x27;,b); 这行代码中，对变量 b 进行 RHS 查询，在作用域的 AO 中找到对应的值 undefined，输出 b undefined。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 结束</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>3、闭包的产生</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 首先明确什么是闭包？可以使用如下定义：</span></span><br><span class="line"><span class="comment">// 函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;JavaScript&#x27;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">fn</span>();</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// JavaScript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func 函数执行的位置和定义的位置是不相同的，func 是在函数 fn 中定义的，但执行却是在全局环境中，虽然是在全局函数中执行的，但函数仍然可以访问当定义时的词法作用域。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当函数执行结束后其活动变量就会被销毁，但是在上面的例子中却不是这个样子。但函数 fn 执行结束之后，fn 对象的活动变量并没有被销毁，这是因为 fn 返回的函数 func 的作用域链还保持着 fn 的活动变量，因此 JavaScript 的垃圾回收机制不会回收 fn 活动变量。虽然返回的函数 func 是在全局环境下执行的，但是其作用域链的存储的活动（变量）对象的顺序分别是：func 的活动对象、fn 的活动对象、全局变量对象。因此在 func 函数执行时，会顺着作用域链查找标识符，也就能访问到 fn 所定义的词法作用域（即 fn 函数的活动变量）也就不足为奇了。</span></span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><code>总结</code></h2><p>问：多个 script 块间的执行顺序</p>
<blockquote>
<p>答：多个 script 代码块从上到下按序载入，语法分析阶段报错的话，结束本代码块的执行，执行流进入下一个代码块。多个代码块共享全局执行上下文，可以访问到其他代码块定义的变量和方法。</p>
</blockquote>
<p>问：为什么会产生变量提升与函数提升？</p>
<blockquote>
<p>答：在代码执行之前的预编译阶段，创建当前 EC 时，会在活动对象上创建一个与函数声明与变量声明对应的属性，然后将活动对象推入作用域链。在查询变量时，是通过作用域链进行 RHS 查询。所以会查询到作用域链上已经定义的函数与变量。</p>
</blockquote>
<p>问：闭包的产生</p>
<blockquote>
<p>答：简单来说，闭包中的函数所对应的作用域链上仍然保留了父级活动对象，所以可以对父级活动对象的属性进行查询。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><code>参考资料</code></h2><ul>
<li>《你不知道的 Javascript》（上卷），第一部分，作用域和闭包</li>
<li><a class="link"   href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" >JS 引擎的执行过程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000013915935" >彻底明白作用域、执行上下文 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/yangxinxiang84/article/details/113051811?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328641.10297.16155372256670345&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" >深入理解 JavaScript 的执行流程，执行上下文 EC、变量对象 VO、活动对象 AO、作用域 Scope <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/Ancecis/article/details/104382441" >浅谈 JS 的 VO|AO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/chen_zw/article/details/18502937?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control" >JS 运行机制之执行顺序 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/MrErHu/blog/issues/16" >我所认识的作用域链与原型链 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】JS：详解Event Loop运行机制</title>
    <url>/2022/06/28/ReprintJSEventLoop/</url>
    <content><![CDATA[<a class="link"   href="https://limeii.github.io/2019/05/js-eventloop" >【转载】JS：详解Event Loop运行机制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>

<article class="post-container post-container--single" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title">JS：详解Event Loop运行机制</h1>
  </header>

  <section class="post">
    <p>在这篇文章中会介绍以下内容：</p>
    <ul>
      <li>
        <p>engine runtime 和 call stack 简介（以 V8 引擎为例）</p>
      </li>
      <li>
        <p>Event Loop 运行机制的详解</p>
      </li>
      <li>
        <p>microtasks 和 macrotask 的执行顺序</p>
      </li>
    </ul>

    <h2 id="engine-runtime-和-call-stack-简介">engine runtime 和 call stack 简介</h2>

    <p>在 chrome 浏览器和 nodejs 里都是用 V8 引擎解析和运行 JS 代码，我们先来看下 V8 引擎的简化图：</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop01.png"
                      alt="js-eventloop" height="80%" width="80%"
                ></p>

    <p>上图中 Heap 是用来做内存分配，<code class="language-plaintext highlighter-rouge">Call Stack</code>是用来执行 JS 代码，由于 JS
      是单线程所以只有一个<code class="language-plaintext highlighter-rouge">Call Stack</code>。实际我们写网页开发的时候，除了一些 JS
      代码，我们还会大量用到：DOM 事件、AJAX(XMLHttpRequest)、setTimeout 等等一些异步事件。从上图可以看出，这些异步事件都没有在 V8 引擎里，事实上这些异步事件不属于 V8
      引擎，而是属于浏览器，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都分别有单独的线程来处理。由于<code
        class="language-plaintext highlighter-rouge">Call Stack</code>执行（JS 运行线程）和页面渲染线程是互斥的，如果所有的事情都由 V8
      引擎处理，这样肯定会导致页面卡顿。</p>

    <p>浏览器多线程和 callback 机制完美避免了页面卡顿的问题。DOM 事件、AJAX(XMLHttpRequest)、setTimeout 这些异步事件在各自单独的线程处理完以后，每个异步事件都有 callback
      回调函数，V8 引擎再把这些回调函数放在<code class="language-plaintext highlighter-rouge">Call Stack</code>执行。上述整个运行机制可以称为是
      runtime，可以简化如下图：</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop02.png"
                      alt="js-eventloop" height="80%" width="80%"
                ></p>

    <p>如上图所示，web 异步事件结束以后，会有 callback，然后 runtime 把这些 callback 事件放到<code
        class="language-plaintext highlighter-rouge">Callback Queue</code>里，一旦<code
        class="language-plaintext highlighter-rouge">Call Stack</code>所有的方法都执行完以后，<code
        class="language-plaintext highlighter-rouge">Event Loop</code>会依次把 <code
        class="language-plaintext highlighter-rouge">Callback Queue</code>里的回调函数放到<code
        class="language-plaintext highlighter-rouge">Call Stack</code>里执行。</p>

    <h2 id="event-loop-运行机制的详解">Event Loop 运行机制的详解</h2>

    <p>Event Loop 实际上就是一个 job，用来检测 Call Stack 和 Callback Queue，一旦 Call Stack 里代码执行完以后，就会把 Callback Queue 里第一个 callback
      函数放到 Call Stack 里执行。我们来看个例子：</p>

    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script start</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;,</span> <span class="mi">1000</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script end</span><span class="dl">'</span><span class="p">);</span>
</code></pre>
      </div>
    </div>
    <p>运行运行结果如下:</p>

    <div class="language-plaintext highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code>script start
script end
setTimeout
</code></pre>
      </div>
    </div>
    <p>我们具体一步一步看下整个流程：</p>

    <p>1，代码没有运行之前，<code class="language-plaintext highlighter-rouge">Call Stack</code> <code
        class="language-plaintext highlighter-rouge">Callback Queue</code>都是空的</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop03.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>2，把<code class="language-plaintext highlighter-rouge">console.log('script start')</code>加到 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop04.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>3，执行<code class="language-plaintext highlighter-rouge">console.log('script start')</code>，在 console 里打印出<code
        class="language-plaintext highlighter-rouge">script start</code>，执行结束后把它移出 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop05.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>4，把 setTimeout 放到 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop06.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>5, 执行 setTimeout，用 setTimout 线程执行 timeout 时间，Call Stack 中 setTimeout 执行结束，把它移出 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop07.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>6, 把<code class="language-plaintext highlighter-rouge">console.log('script end')</code>加到 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop08.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>7，执行<code class="language-plaintext highlighter-rouge">console.log('script end')</code>，在 console 里打印出<code
        class="language-plaintext highlighter-rouge">script end</code></p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop09.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>8，<code class="language-plaintext highlighter-rouge">console.log('script end')</code>执行结束，把它移出 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop10.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>9，1000毫秒以后，计时结束，把 callback<code class="language-plaintext highlighter-rouge">cb1</code>函数放到 Callback Queue 里</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop11.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>10，此时 Callback Stack 是空的，Event Loop 把 cb1 拿到 Callback Stack 里</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop12.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>11，执行 cb1，cb1 里有<code class="language-plaintext highlighter-rouge">console.log('setTimeout')</code>，把<code
        class="language-plaintext highlighter-rouge">console.log('setTimeout')</code>放到 Call Stack 里</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop13.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>12，执行<code class="language-plaintext highlighter-rouge">console.log('setTimeout')</code>，在 console 里打印出<code
        class="language-plaintext highlighter-rouge">setTimeout</code>，<code
        class="language-plaintext highlighter-rouge">console.log('setTimeout')</code>执行结束，把它移出 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop14.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>13，<code class="language-plaintext highlighter-rouge">cb1</code>执行结束，把它移出 Call Stack</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop15.png"
                      alt="js-eventloop" height="60%" width="60%"
                ></p>

    <p>总结来说就是，JS 是单线程的，只有一个 Call Stack，浏览器是多线程的，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout
      都是有单独的线程处理。在这些异步事件结束，runtime会把它们的 callback 按顺序放到 Callback Queue 里，Event Loop 会检测 Call Stack，一旦它为空，就会把 Callback
      Queue 里的回调函数依次放到 Call Stack 里执行，直到 Callback Queue 为空。</p>

    <h2 id="microtasks-和-macrotask-的执行顺序">microtasks 和 macrotask 的执行顺序</h2>

    <p>刚才用 setTimeout 为例，解释了JS中 Event Loop 机制是怎么运行的，也提到过 runtime 会把回调函数依次按时间先后顺序放到 Callback Queue 里，然后 Event Loop
      再依次把这些回调函数放到 Call Stack 里运行。我们在浏览器 Console 运行以下代码，看下结果：</p>

    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script start</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise1</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise2</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script end</span><span class="dl">'</span><span class="p">);</span>
</code></pre>
      </div>
    </div>
    <p>执行结果如下：</p>

    <div class="language-plaintext highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code>script start
script end
promise1
promise2
setTimeout
</code></pre>
      </div>
    </div>
    <blockquote>
      <p>
        上述代码虽然 setTimeout 延时为0，其实还是异步的。因为H5标准规定 setTimeout 函数的第二个参数不能小于4毫秒，不足会自动增加。
      </p>
    </blockquote>

    <p>setTimeout 和 promise 都是异步事件，而且setTimeout 写在 promise 之前，为什么 setTimeout 的回调要比 promise 后执行呢？那是因为 promise
      属于微任务（microtasks）而 setTimeout 属于宏任务（macrotask），微任务（microtasks）的优先级要高于宏任务（macrotask）。</p>

    <p>首先我们需要明白以下几件事情：</p>
    <ul>
      <li>JS 分为同步任务和异步任务</li>
      <li>同步任务都在主线程上执行，形成一个执行栈</li>
      <li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
      <li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li>
    </ul>

    <p>根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task
      source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop16.png"
                      alt="js-eventloop"
                ></p>

    <p>Callback Queue（Task Queue）里的回调事件称为宏任务（macrotask），每次异步事件结束后，它们的回调函数会依次按时间顺序放在 Callback Queue 里，等待 Event Loop
      依次把它们放到 Call Stack 里执行。比如：<code class="language-plaintext highlighter-rouge">setInterval</code> <code
        class="language-plaintext highlighter-rouge">setTimeout</code> <code
        class="language-plaintext highlighter-rouge">script</code> <code
        class="language-plaintext highlighter-rouge">setImmediate</code> <code
        class="language-plaintext highlighter-rouge">I/O</code> <code
        class="language-plaintext highlighter-rouge">UI rendering</code>就是宏任务（macrotask）。</p>

    <p>微任务（microtasks）是指异步事件结束后，回调函数不会放到 Callback Queue，而是放到一个微任务队列里（Microtasks Queue），在 Call Stack 为空时，Event Loop
      会先查看微任务队列里是否有任务，如果有就会先执行微任务队列里的回调事件；如果没有微任务，才会到 Callback Queue 执行回到事件。比如：<code
        class="language-plaintext highlighter-rouge">promise</code> <code
        class="language-plaintext highlighter-rouge">process.netTick</code> <code
        class="language-plaintext highlighter-rouge">Object.observe</code> <code
        class="language-plaintext highlighter-rouge">MutationObserver</code>就是微任务（microtasks）。</p>

    <blockquote>
      <p>
        在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。
      </p>
    </blockquote>

    <p>整个 Event Loop 的执行顺序如下：</p>
    <ul>
      <li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
      <li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
      <li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
      <li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
      <li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取，也就是 callbacke queue）</li>
    </ul>

    <p>流程图如下：
      <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./js-eventloop17.jpg"
                      alt="js-eventloop" height="40%" width="40%"
                >
    </p>

    <p>我们再把代码改一下，在创建 promise 的时候，加一行<code
        class="language-plaintext highlighter-rouge">console.log('Promise')</code>，而且在第一个 promise resolve 的时候再加一个
      setTimeout，代码如下：</p>
    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script start</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Promise</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">();</span>
<span class="p">&#125;).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">&#123;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout in promise1</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">&#125;,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise1</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise2</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script end</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/**
script start
Promise
script end
promise1
promise2
setTimeout
setTimeout in promise1
**/</span>
</code></pre>
      </div>
    </div>

    <p><code class="language-plaintext highlighter-rouge">console.log('Promise')</code>在这里是同步代码，<code
        class="language-plaintext highlighter-rouge">console.log('script end')</code>是同步代码且放在最后，所以<code
        class="language-plaintext highlighter-rouge">Promise</code>在<code
        class="language-plaintext highlighter-rouge">script end</code>前面，而且在微任务（microtasks）里有宏任务（macrotask），macrotask
      还是会依次被放到 Callback Queue 等待执行。</p>

    <p>如果有 async await 呢？再来看一段代码：</p>
    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="c1">//请写出输出内容</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 start</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">async2</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 end</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">async2</span><span class="p">()</span> <span class="p">&#123;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async2</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script start</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;,</span> <span class="mi">0</span><span class="p">)</span>

<span class="nx">async1</span><span class="p">();</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise1</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">();</span>
<span class="p">&#125;).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise2</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script end</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/**
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
**/</span>
</code></pre>
      </div>
    </div>

    <p>我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async/await 中，在出现 await
      出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？</p>

    <p>由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的</p>
    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">()</span> <span class="p">&#123;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 start</span><span class="dl">'</span><span class="p">);</span>
	<span class="k">await</span> <span class="nx">async2</span><span class="p">();</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 end</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;</span>
</code></pre>
      </div>
    </div>
    <p>等价于：</p>
    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">()</span> <span class="p">&#123;</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 start</span><span class="dl">'</span><span class="p">);</span>
	<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">async2</span><span class="p">()).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">&#123;</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 end</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">&#125;)</span>
<span class="p">&#125;</span>
</code></pre>
      </div>
    </div>

    <p>我们来看一个变式, 将 async2 中的函数也变成了 Promise 函数：</p>
    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 start</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">async2</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 end</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">async2</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="c1">//async2做出如下更改：</span>
    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise1</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">();</span>
<span class="p">&#125;).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise2</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">&#125;);</span>
<span class="p">&#125;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script start</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">async1</span><span class="p">();</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise3</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">();</span>
<span class="p">&#125;).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise4</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script end</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/**
script start
async1 start
promise1
promise3
script end
promise2
async1 end
promise4
setTimeout
**/</span>
</code></pre>
      </div>
    </div>

    <p>我们再来看一个变式，将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下：</p>
    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">async1 start</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">await</span> <span class="nx">async2</span><span class="p">();</span>
    <span class="c1">//更改如下：</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout1</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">&#125;,</span><span class="mi">0</span><span class="p">)</span>
<span class="p">&#125;</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">async2</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="c1">//更改如下：</span>
	<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout2</span><span class="dl">'</span><span class="p">)</span>
	<span class="p">&#125;,</span><span class="mi">0</span><span class="p">)</span>
<span class="p">&#125;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script start</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout3</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">async1</span><span class="p">();</span>

<span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise1</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">resolve</span><span class="p">();</span>
<span class="p">&#125;).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise2</span><span class="dl">'</span><span class="p">);</span>
<span class="p">&#125;);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script end</span><span class="dl">'</span><span class="p">);</span>

<span class="cm">/**
script start
async1 start
promise1
script end
promise2
setTimeout3
setTimeout2
setTimeout1
**/</span>
</code></pre>
      </div>
    </div>

    <p>我们再来看一个变式，代码如下：</p>
    <div class="language-js highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">a1</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">a1 start</span><span class="dl">'</span><span class="p">)</span>
    <span class="k">await</span> <span class="nx">a2</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">a1 end</span><span class="dl">'</span><span class="p">)</span>
<span class="p">&#125;</span>
<span class="k">async</span> <span class="kd">function</span> <span class="nx">a2</span> <span class="p">()</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">a2</span><span class="dl">'</span><span class="p">)</span>
<span class="p">&#125;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script start</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">setTimeout</span><span class="dl">'</span><span class="p">)</span>
<span class="p">&#125;,</span> <span class="mi">0</span><span class="p">)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">&#125;)</span>

<span class="nx">a1</span><span class="p">()</span>

<span class="kd">let</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#123;</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise2.then</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise2</span><span class="dl">'</span><span class="p">)</span>
<span class="p">&#125;)</span>

<span class="nx">promise2</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">&#123;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">&#123;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">promise3</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">&#125;)</span>
<span class="p">&#125;)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">script end</span><span class="dl">'</span><span class="p">)</span>


<span class="cm">/**
script start
a1 start
a2
promise2
script end
promise1
a1 end
promise2.then
promise3
setTimeout
**/</span>
</code></pre>
      </div>
    </div>

    <p>参考资料：</p>
    <ul>
      <li><a class="link"   href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" >“Event loops”, section in HTML5
          spec. <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
      <li><a class="link"   href="https://vimeo.com/96425312" >“Help, I’m stuck in an event-loop” by Philip Roberts (video). <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
    </ul>

  </section>
</article>]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】02，事件循环</title>
    <url>/2021/02/25/someInterestingQuestions02/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>结果：打印 start promise end then1 then2 setTimeout</p>
<p>原因：简单来说，JS 代码的执行顺序为：同步代码–&gt;异步代码（微任务–&gt;宏任务）</p>
<p>分析：</p>
<ol>
<li><p>打印 start</p>
</li>
<li><p>setTimeout 加入消息队列</p>
</li>
<li><p>new Promise 的同步部分执行，打印 promise，then 部分加入消息队列</p>
</li>
<li><p>打印 end</p>
</li>
<li><p>消息队列中先处理微任务 then 的部分，打印 then1，then2</p>
</li>
<li><p>消息队列处理宏任务 setTimeout，打印 setTimeout</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><code>参考资料</code></h2><blockquote>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" >并发模型与事件循环 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="http://lynnelv.github.io/js-event-loop-browser" >深入理解 js 事件循环机制（浏览器篇） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Vue Composition API</title>
    <url>/2022/06/22/ReprintVueCompositionAPI/</url>
    <content><![CDATA[<a class="link"   href="https://zhuanlan.zhihu.com/p/408272742" >【转载】Composition API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>

<div class="RichText ztext Post-RichText css-1g0fqss" options="[object Object]">
  <h2 data-first-child="">前言 </h2>
  <p data-pid="d-p163wy">关注 React 的同学应该知道，React 在 19 年推出了 Hooks API，从而可以抛弃难以理解的 class
    完全转向函数式组件。当然，它对开发者的意义不止于此，更为重要的是它提供了从组件中<b>提取状态逻辑</b>的能力，让我们能以业务逻辑为细粒度拆分组件，并在组件之间复用业务逻辑。 </p>
  <p data-pid="lloIgxso">后续尤大马上发布了 Vue Function-based API RFC（在之后重写成了 Composition API），并作为 Vue3 的核心特性，可想而知它的重要性。 </p>
  <p data-pid="vYRnkATX">接下来让我们抛开 React，来看看 Composition API 都有哪些内容。 </p>
  <h2>一、介绍 </h2>
  <p data-pid="B39fLDrP"><b>1.1 什么是 Composition API ？ </b></p>
  <p data-pid="Rm3abSlN">Vue 3 中引入的一种新的编写 Vue 组件的方式，可以将 2.x 中与组件逻辑相关的选项以 API 函数的形式重新设计。 </p>
  <p data-pid="x_L4YJEQ"><b>1.2 基本例子 </b></p>
  <figure data-size="normal"><img src="https://pic2.zhimg.com/v2-3215832798dad4d85252c140e509f445_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="1884" data-rawheight="1240" class="origin_image zh-lightbox-thumb" width="1884"
      data-original="https://pic2.zhimg.com/v2-3215832798dad4d85252c140e509f445_r.jpg" style=""></figure>
  <p data-pid="80OXzjAb">我们使用 Composition API 对左侧进行重构，其实就是将组件选项抽离到了 <code>setup</code>
    函数当中进行编排，并在最后把模板用到的变量返回，最后的结果和将变量定义在 <code>data</code> 或者 <code>methods</code> 中没有什么区别。 </p>
  <p data-pid="zUbcTqvG">当然，setup 和 2.x 的选项一起混用也是没有问题的，并且依旧可以通过 <code>this.xx</code> 访问到 <code>setup</code> 返回的变量。</p>
  <blockquote data-pid="yCWHp3ur">❓ 如果只是把代码迁移到 <code>setup</code> 函数中，变成一长条的面条式代码，有什么意义呢 </blockquote>
  <p data-pid="__ovLorF"><b>1.3 更进一步的例子 </b></p>
  <figure data-size="normal"><img src="https://pic3.zhimg.com/v2-7889c66d30a72bf92842103cf92ed84e_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="936" data-rawheight="1204" class="origin_image zh-lightbox-thumb" width="936"
      data-original="https://pic3.zhimg.com/v2-7889c66d30a72bf92842103cf92ed84e_r.jpg"></figure>
  <p data-pid="3Plt6P_5">这一次我们将 <code>setup</code> 中的代码进一步抽离，拆出了 <code>useMouse</code>
    组合函数，里面封装了对鼠标位置的监听逻辑。<code>useMouse</code>
    只需要将要暴露给组件的状态（<code>x</code>、<code>y</code>）以响应式的数据源的方式返回出来，就可以在我们的组件代码中使用。 </p>
  <p data-pid="SLR82yO4">对于 Component 来说，里面没有任何监听鼠标位置的逻辑代码，只需要调用 <code>useMouse</code> 拿到 <code>x</code>、<code>y</code>
    即可。</p>
  <blockquote data-pid="jfosxkhU">❓ 这些我用 Mixins 也能实现呀 </blockquote>
  <p data-pid="ba4NQEDI"><b>1.4 更更进一步的例子 </b></p>
  <figure data-size="normal"><img src="https://pic4.zhimg.com/v2-7e01ef06f0e5e71970a6f98dcc5a610f_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="1532" data-rawheight="1384" class="origin_image zh-lightbox-thumb" width="1532"
      data-original="https://pic4.zhimg.com/v2-7e01ef06f0e5e71970a6f98dcc5a610f_r.jpg" style=""></figure>
  <p data-pid="xHhwJpIi">首先我们通过模板来理解 <code>useDark</code> 的工作内容，就是返回了一个表示是否是黑夜模式的布尔值，并且可以通过 <code>useToggle</code>
    来快速得到一个 toggle 函数。 </p>
  <p data-pid="nmV5YoSR">然后观察 <code>useDark</code>，我们可以看到它身为一个组合函数的同时，又调用了其他的组合函数 <code>usePreferredDark</code> 和
    <code>useLocalStorage</code> 来获取系统主题色和本地配置色。当然，我们不需要太关心它们的具体实现，只需要专注于处理结果，并返回以本地配置色为优先的结果即可。
  </p>
  <p data-pid="C6hZ8F1F">其中的组合函数调用关系如下图所示： </p>
  <figure data-size="normal"><img src="https://pic3.zhimg.com/v2-1f58c63c4fccaffaa58660947892808a_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="1678" data-rawheight="730" class="origin_image zh-lightbox-thumb" width="1678"
      data-original="https://pic3.zhimg.com/v2-1f58c63c4fccaffaa58660947892808a_r.jpg" style=""></figure>
  <p data-pid="J4AYoGK8">组合函数的底层又依赖了其他组合函数，比如 <code>useLocalStorage</code> 依赖统一封装了 SessionStorage 和 LocalStorage 逻辑的
    <code>useStorage</code>，<code>usePreferredDark</code> 依赖封装了 <code>window.matchMedia</code> 逻辑的
    <code>useMediaQuery</code>。它们最后又都通过 <code>useEventListener</code> 来做状态改变的响应，并且能自动卸载。
  </p>
  <p data-pid="jqJ6ebx1">涉及的每一个函数都能独立使用，并且有自己的职责，最后进行组合。 </p>
  <blockquote data-pid="08iizr0U">这个例子来源于 <a class="link"   href="https://link.zhihu.com/?target=https%3A//github.com/vueuse/vueuse" 
      class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">VueUse <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.
  </blockquote>
  <p data-pid="WuMdyX-p">当然，我们不可能总是写到这么通用的代码，但是在业务中也可以使用 Composition API 来对业务逻辑进行拆分，让每一个组合函数负责独立的业务，比如埋点上报、RichTextPanel
    组件参数与回调、页面控件逻辑等。这些组件内的状态、方法现在我们可以将它提取到组合函数中，可以是为了复用，也可以仅仅是为了让 .vue 文件看起来更干净。</p>
  <h2>二、API </h2>
  <p data-pid="0PsR029O"><b>2.1 setup </b></p>
  <p data-pid="FdBMQSTF"><code>setup</code> 是组合式 API 的入口点，它的执行时机在 <code>beforeCreate</code> 和
    <code>created</code>，并且只会执行一次。
  </p>
  <p data-pid="8emt6Qmd">所以我们不需要 <code>onBeforeCreate</code> 和 <code>onCreated</code>，这些钩子对应的代码应该直接在 <code>setup</code>
    函数中编写。 </p>
  <p data-pid="-PkOkw14">它接收两个参数： </p>
  <ol>
    <li data-pid="PzoT1YH8">响应式的 <code>props</code> </li>
    <li data-pid="En2tDX8_">非响应式的 <code>context</code>，包含：attrs、slots、emit </li>
  </ol>
  <p data-pid="IeEBiCS8">它执行的时候组件实例尚未被创建，所以我们无法访问 data、computed、methods 这些组件选项。 </p>
  <p data-pid="JlJyHhSo">如果它返回一个对象，那么对象的 property 就可以在选项或者模板中访问到。 </p>
  <p data-pid="pCqoAluV"><b>2.1.1 返回渲染函数 </b></p>
  <figure data-size="normal"><img src="https://pic1.zhimg.com/v2-ed3d1aa04bf9bf33e9878a0d935fb074_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="1088" data-rawheight="484" class="origin_image zh-lightbox-thumb" width="1088"
      data-original="https://pic1.zhimg.com/v2-ed3d1aa04bf9bf33e9878a0d935fb074_r.jpg"></figure>
  <p data-pid="yc8vp9x5">在 Babel Plugin 支持下可以返回 JSX：<a class="link" 
       href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/jsx/pull/142"  class=" wrap external"
      target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">feat: add @vue/composition-api support
      #142 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
  <p data-pid="4iqS02eC"><b>2.1.2 getCurrentInstance </b></p>
  <p data-pid="jphaZDki">如果确实需要访问组件实例，可以使用 <code>getCurrentInstance()</code>。 </p>
  <p data-pid="X2DJAAWy">只能在 <code>setup</code>、生命周期钩子和组合函数中使用。 </p>
  <figure data-size="normal"><img src="https://pic4.zhimg.com/v2-2219ce295be181f25efcf766f103d15b_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="970" data-rawheight="304" class="origin_image zh-lightbox-thumb" width="970"
      data-original="https://pic4.zhimg.com/v2-2219ce295be181f25efcf766f103d15b_r.jpg"></figure>
  <p data-pid="tKx1A6sw"><b>2.2 reactive </b></p>
  <p data-pid="EXN2rHlJ">返回对象的响应式副本，相当于 <code>Vue.observable(obj)</code> 。 </p>
  <p data-pid="XRwILD4j">该响应式转换是“深度转换”——它会影响嵌套对象传递的所有 property。 </p>
  <p data-pid="YTfRw30Y">怎么理解这里的响应式呢？就是我们在渲染期间使用响应式对象，当值改变的时候视图会自动更新，就和修改挂在 data 对象里的值一样。 </p>
  <p data-pid="Chdt9Vul"><b>2.2.1 无法代理原始值类型 </b></p>
  <p data-pid="6Qo8VckW">reactive() 函数可以代理一个对象，但不能代理基本类型值，这是因为原始值类型只有值而没有引用，无法追踪变量的后续变化。 </p>
  <p data-pid="i_6Q-8R3"><b>2.2.2 响应丢失 </b></p>
  <figure data-size="normal"><img src="https://pic2.zhimg.com/v2-bde37e9bd232fafb93168b55251367b9_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="1008" data-rawheight="484" class="origin_image zh-lightbox-thumb" width="1008"
      data-original="https://pic2.zhimg.com/v2-bde37e9bd232fafb93168b55251367b9_r.jpg"></figure>
  <p data-pid="pAx7_aPR"><b>2.3 ref </b></p>
  <p data-pid="E96TTVJ_">接收一个值，返回的响应式且可变的包装对象。 </p>
  <p data-pid="xmCIrvO9">它只有一个属性：<code>.value</code> ，该属性指向内部被包装的值。这个值可以直接修改。 </p>
  <blockquote data-pid="OgJesy_I">我们没法用 reactive 处理原始值类型，但是我们可以创建一个对象将原始值挂在它的同名 property 下，再传递给 reactive。Vue 提供了 ref
    来替我们做这件事。 </blockquote>
  <figure data-size="normal"><img src="https://pic1.zhimg.com/v2-19e7df03e22381ebc37428bf17a8e594_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="800" data-rawheight="484" class="origin_image zh-lightbox-thumb" width="800"
      data-original="https://pic1.zhimg.com/v2-19e7df03e22381ebc37428bf17a8e594_r.jpg"></figure>
  <p data-pid="Q7Uideqn"><b>2.3.1 自动解包（不需要加 .value 的情况） </b></p>
  <ol>
    <li data-pid="g2srjh5V">ref 在模板中会自动解包 </li>
  </ol>
  <p data-pid="nHaF68Z1">2.<code>watch</code> 可以直接接受 ref 作为监听对象，在回调函数中会直接返回解包后的值。 </p>
  <figure data-size="normal"><img src="https://pic2.zhimg.com/v2-61b795e0a933eaba882ebe38e65d3acd_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="868" data-rawheight="268" class="origin_image zh-lightbox-thumb" width="868"
      data-original="https://pic2.zhimg.com/v2-61b795e0a933eaba882ebe38e65d3acd_r.jpg"></figure>
  <p data-pid="BWQdWKOb">3. 使用 reactive() / readonly() 解包对象嵌套的 ref </p>
  <figure data-size="normal"><img src="https://pic3.zhimg.com/v2-6b5120ec665ba0e9330220c967ac023a_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="716" data-rawheight="268" class="origin_image zh-lightbox-thumb" width="716"
      data-original="https://pic3.zhimg.com/v2-6b5120ec665ba0e9330220c967ac023a_r.jpg"></figure>
  <blockquote data-pid="zaIwbIj-">但是从 <code>Array</code> 或原生集合类型如 <code>Map</code>访问 ref 时，不会进行解包。</blockquote>
  <p data-pid="e4NmHN9d"><b>2.3.2 unref（ref 的反向操作） </b></p>
  <p data-pid="snoUo1ZM">传入一个 ref，返回 <code>ref.value</code>，否则原样返回。 </p>
  <blockquote data-pid="o7iXv9Gs">纠结是否需要加 <code>.value</code>（比如某个函数参数的类型是
    <code>Ref&lt;number&gt; | number</code>）来取值，可以使用 unref 来解包。
  </blockquote>
  <figure data-size="normal"><img src="https://pic1.zhimg.com/v2-be644447a3adfae139ccb07863b4fe30_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="700" data-rawheight="196" class="origin_image zh-lightbox-thumb" width="700"
      data-original="https://pic1.zhimg.com/v2-be644447a3adfae139ccb07863b4fe30_r.jpg"></figure>
  <p data-pid="vHg0rpqg"><b>2.3.3 重复使用已有 ref </b></p>
  <p data-pid="liLqb6ff">将一个 ref 传递给 <code>ref()</code> 构造函数，它会原样返回。 </p>
  <blockquote data-pid="h1FrzDho">如果你的函数需要返回一个 ref，但是不确定参数的类型，可以直接 <code>return ref(param)</code>，如果是 ref 则会复用，不是则返回一个新的
    ref。 </blockquote>
  <p data-pid="ueXBRAta"><b>2.3.4 可以使用 ES6 解构语法 </b></p>
  <p data-pid="7Qg9q4Wo">解构一个值是 ref 的对象不会丢失响应式。 </p>
  <figure data-size="normal"><img src="https://pic3.zhimg.com/v2-fb83022e342cde7e017a54e710b8d6b6_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="744" data-rawheight="124" class="origin_image zh-lightbox-thumb" width="744"
      data-original="https://pic3.zhimg.com/v2-fb83022e342cde7e017a54e710b8d6b6_r.jpg"></figure>
  <p data-pid="bVu2MvPp"><b>2.3.5 this.$refs 的解决方案 </b></p>
  <p data-pid="sYcku75L">在虚拟 DOM 补丁算法中，如果 VNode 的 <code>ref</code> 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。 </p>
  <blockquote data-pid="jYqAgu0k">由于是在虚拟 DOM 挂载/打补丁过程中执行的，因此 ref 只会在初始渲染之后才获得赋值。 </blockquote>
  <figure data-size="normal"><img src="https://pic4.zhimg.com/v2-c08e93238d9074b4e78284dcca4b94cb_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="902" data-rawheight="1348" class="origin_image zh-lightbox-thumb" width="902"
      data-original="https://pic4.zhimg.com/v2-c08e93238d9074b4e78284dcca4b94cb_r.jpg"></figure>
  <p data-pid="oCTH_fU2"><b>2.4 toRefs </b></p>
  <p data-pid="TZTJ9i_T">将响应式对象转换为普通对象，并对每个 property 对应的 value 转换成 ref。 </p>
  <p data-pid="2oWgFXua">可以用来解决 <code>reactive</code> 或者 <code>props</code> 在解构的时候丢失响应式的问题。 </p>
  <figure data-size="normal"><img src="https://pic1.zhimg.com/v2-e1550002c1ead321c4dde992c78f944c_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="1008" data-rawheight="340" class="origin_image zh-lightbox-thumb" width="1008"
      data-original="https://pic1.zhimg.com/v2-e1550002c1ead321c4dde992c78f944c_r.jpg"></figure>
  <p data-pid="YcVVmyxD"><b>2.5 computed </b></p>
  <p data-pid="STH_UE0l">接收 getter 函数，返回一个<b>只读</b>的响应式 ref 对象。 </p>
  <figure data-size="normal"><img src="https://pic1.zhimg.com/v2-b2e6f76a4f4265e182212f3dff7b8ab4_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="868" data-rawheight="304" class="origin_image zh-lightbox-thumb" width="868"
      data-original="https://pic1.zhimg.com/v2-b2e6f76a4f4265e182212f3dff7b8ab4_r.jpg"></figure>
  <p data-pid="8GHIhOTL">如果参数是具有 get 和 set 函数的对象，返回的结果会是一个<b>可写</b>的响应式 ref 对象。 </p>
  <figure data-size="normal"><img src="https://pic4.zhimg.com/v2-c7dadc1902029f1fa98537e6c13744d3_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="564" data-rawheight="448" class="origin_image zh-lightbox-thumb" width="564"
      data-original="https://pic4.zhimg.com/v2-c7dadc1902029f1fa98537e6c13744d3_r.jpg"></figure>
  <p data-pid="VVFGe_SE"><b>2.6 watch </b></p>
  <p data-pid="d64D5vN9">第一个参数接收数据源，可以是： </p>
  <ul>
    <li data-pid="Tk3QbSoW">getter 函数、ref </li>
    <li data-pid="67gvpbE8">包含上述两种类型的数组（也就是可以 watch 多个源，其中任一个变化都会触发回调） </li>
  </ul>
  <p data-pid="lIMaq9k1">第二个参数是回调函数，在数据源变动的时候触发。 </p>
  <figure data-size="normal"><img src="https://pic3.zhimg.com/v2-b0556885105bd72c7b0b6ea131af826a_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="752" data-rawheight="520" class="origin_image zh-lightbox-thumb" width="752"
      data-original="https://pic3.zhimg.com/v2-b0556885105bd72c7b0b6ea131af826a_r.jpg"></figure>
  <p data-pid="6F0hGO5P"><b>2.6.1 停止观察 </b></p>
  <p data-pid="3v1JUsDo"><code>watch()</code> 返回一个停止观察的函数： </p>
  <figure data-size="normal"><img src="https://pic1.zhimg.com/v2-75541dc512f2994a4ac1719df0e23a64_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="464" data-rawheight="196" class="origin_image zh-lightbox-thumb" width="464"
      data-original="https://pic1.zhimg.com/v2-75541dc512f2994a4ac1719df0e23a64_r.jpg"></figure>
  <p data-pid="JiYo5C3c">如果 <code>watch()</code> 是在一个组件的 <code>setup()</code> 或是生命周期函数中被调用的，那么该 watcher
    会在当前组件被销毁时也一同被自动停</p>
  <p data-pid="IddzStMs"><b>2.6.2 清理 effect </b></p>
  <p data-pid="ZlB7P72W">watcher 的回调会接收到的第三个参数是一个用来注册清理操作的函数。 </p>
  <blockquote data-pid="GLeHCtBz">有时候当观察的数据源变化后，我们可能需要对之前所执行的副作用进行清理。举例来说，一个异步操作在完成之前数据就产生了变化，我们可能要撤销还在等待的前一个操作。
  </blockquote>
  <p data-pid="yWDqqwZf">调用这个函数可以注册一个清理函数，执行时机在： </p>
  <ul>
    <li data-pid="IqIvIe6s">回调被下一次调用前 </li>
    <li data-pid="lJAeV6sq">watcher 被停止前 </li>
  </ul>
  <figure data-size="normal"><img src="https://pic4.zhimg.com/v2-f81961ecde2ab5d1edecc76cb51940b3_b.jpg" data-caption=""
      data-size="normal" data-rawwidth="784" data-rawheight="376" class="origin_image zh-lightbox-thumb" width="784"
      data-original="https://pic4.zhimg.com/v2-f81961ecde2ab5d1edecc76cb51940b3_r.jpg"></figure>
  <h2>三、设计动机 </h2>
  <p data-pid="4kuIX-HO"><b>3.1 从 Class API 到 Function API 再到 Composition API </b></p>
  <p data-pid="MxQjNLEk">我们可以在 Vue RFC 中看到最初的 <a class="link" 
       href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/17"  class=" wrap external"
      target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Class API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 到 <a class="link" 
       href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/42"  class=" wrap external"
      target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Function-based Component API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 取其 FP
    的精华，再到被修订为 <a class="link"   href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/78"  class=" wrap external"
      target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Composition API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 采用 Reactivity 的过程。
  </p>
  <p data-pid="Nxz49j3D"><b>3.2 解决了什么问题 </b></p>
  <p data-pid="4qCnoHpH">对比 2.x 对象式 API： </p>
  <ul>
    <li data-pid="tsAJKZRh">极易复用。 </li>
    <ul>
      <li data-pid="J6TxQJgP">状态可以从组件中拆出来放到组合函数中。 </li>
    </ul>
    <li data-pid="XNnV1qH2">更清楚的逻辑。 </li>
    <ul>
      <li data-pid="3a9fzd7b">代码可以按功能/逻辑组织，而不是分散在各个选项中。 </li>
    </ul>
    <li data-pid="6Yavg6-T">更好的 TypeScript 类型支持。 </li>
    <ul>
      <li data-pid="0zXyXXu0">基于 Class 的 API 存在 TS 类型问题，而基于函数的 API 天然对类型推导很友好，因为 TS 对函数的参数、返回值和泛型的支持已经非常完备。 </li>
    </ul>
    <li data-pid="t_7FHIx3">更小的打包体积。 </li>
    <ul>
      <li data-pid="53fBlnTF">基于函数的 API 每一个函数都可以作为 named ES export 被单独引入，这使得它们对 tree-shaking 非常友好。没有被使用的 API
        的相关代码可以在最终打包时被移除。 </li>
      <li data-pid="qTwuzRZq">同时，基于函数 API 所写的代码也有更好的压缩效率，因为所有的函数名和 setup 函数体内部的变量名都可以被压缩，但对象和 class 的属性/方法名却不可以。</li>
    </ul>
  </ul>
  <p data-pid="4OG0-W96"><b>3.3 对比 2.x 的复用模式 </b></p>
  <p data-pid="54CLk7Ni">Vue 2.x 目前的 API 我们有一些常见的逻辑复用模式，包括： </p>
  <ul>
    <li data-pid="5CdKCo9R">Mixins </li>
    <li data-pid="uKjdCge1">高阶组件 (Higher-order Components, aka HOCs) </li>
    <li data-pid="JpSzfvFy">Renderless Components （基于 scoped slots / 作用域插槽封装逻辑的组件） </li>
  </ul>
  <p data-pid="THz_2hk1">总体来说，以上这些模式存在以下问题： </p>
  <ul>
    <li data-pid="u5nWdNNy">模版中的数据来源不清晰。 </li>
    <ul>
      <li data-pid="JofMkOuo">举例来说，当一个组件中使用了多个 mixin 的时候，光看模版会很难分清一个属性到底是来自哪一个 mixin。HOC 也有类似的问题。 </li>
    </ul>
    <li data-pid="Uu6popTc">使用 Composition API 只需要观察 setup 函数就可以知道数据的来源。 </li>
    <li data-pid="vJXVZcq_">命名空间冲突。 </li>
    <ul>
      <li data-pid="srpLZS_S">由不同开发者开发的 mixin 无法保证不会正好用到一样的属性或是方法名。HOC 在注入的 props 中也存在类似问题。 </li>
    </ul>
    <li data-pid="MnHS9JyT">组合函数在使用和返回给渲染层的两个阶段都可以做重命名的操作。 </li>
    <li data-pid="HvY9AAXD">性能。 </li>
    <ul>
      <li data-pid="RsS4JaW_">HOC 和 Renderless Components 都需要额外的组件实例嵌套来封装逻辑，导致无谓的性能开销。 </li>
    </ul>
    <li data-pid="Rx5iZc1D">组合函数没有创建额外的组件实例所带来的性能损耗。</li>
  </ul>
  <p data-pid="XE-GZHF7"><b>3.4 对比 React Hooks </b></p>
  <p data-pid="Kqxc4Ygq">Composition API 虽然借鉴了 React Hooks，两者具有同等的基于函数抽取和复用逻辑的能力，但是出于框架的性质两者在实现上是天差地别的。 </p>
  <p data-pid="bmfO65Zo">React Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。而 Vue 的 <code>setup()</code>
    每个组件实例只会在初始化时调用一次 ，状态通过引用储存在 <code>setup()</code> 的闭包内。 </p>
  <p data-pid="eIwmCeKN"> 也就是说，Composition API 相比 React Hooks： </p>
  <ul>
    <li data-pid="xvul6_a6">整体上更符合 JavaScript 的直觉； </li>
    <ul>
      <li data-pid="I-_5HxJR">Mutable 写法。 </li>
    </ul>
    <li data-pid="Dbe9xIks">不受调用顺序的限制，可以有条件地被调用； </li>
    <ul>
      <li data-pid="14d6KrXq">Hooks 需要使用下标来获取对应的 state。 </li>
    </ul>
    <li data-pid="ITuR--Mc">不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力； </li>
    <ul>
      <li data-pid="OCdzF7ke">Hooks 的每次渲染都是单独的闭包。 </li>
    </ul>
    <li data-pid="sJud2Tht">不需要总是使用 <code>useCallback</code> 来缓存传给子组件的回调以防止过度更新； </li>
    <ul>
      <li data-pid="MJOZSOIQ">如果给子组件传了函数，每次渲染都会被当作新 props。 </li>
    </ul>
    <li data-pid="LaKlKgt_">不需要担心传了错误的依赖数组给 <code>useEffect/useMemo/useCallback</code> 从而导致回调中使用了过期的值。 </li>
    <ul>
      <li data-pid="71dmEK53">Vue 的依赖收集是全自动的，可以做到最小粒度的更新。 </li>
    </ul>
  </ul>
  <p data-pid="xxxm1Mna">这都是基于 Vue 的响应式更新能力。 </p>
  <p class="ztext-empty-paragraph"><br></p>
  <p data-pid="6wCLdS0z">有兴趣的同学可以通过下面的链接了解 React Hooks 的心智模型有多么沉重： </p>
  <p data-pid="dXcX4NpU"><a class="link" 
       href="https://link.zhihu.com/?target=https%3A//zh-hans.reactjs.org/docs/hooks-faq.html%23from-classes-to-hooks" 
      class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Hooks FAQ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
  <p data-pid="1O7wFzO1"><a class="link" 
       href="https://link.zhihu.com/?target=https%3A//overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/" 
      class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">使用 React Hooks 声明
      setInterval <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
  <p data-pid="tOfqa6Ta"><a class="link" 
       href="https://link.zhihu.com/?target=https%3A//overreacted.io/zh-hans/a-complete-guide-to-useeffect/" 
      class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">useEffect 完整指南 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>
  </p>
  <p class="ztext-empty-paragraph"><br></p>
  <p data-pid="jW2h8EBi"><b>3.5 那么它有缺点吗？ </b></p>
  <p data-pid="ZAvsH4cw"><b>3.5.1 ref 和 reactive 的区别 </b></p>
  <table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal">
    <thead style="background-color: gray;">
      <th>ref</th>
      <th>reactive</th>
    </thead>
    <tbody>
      <tr>
        <td>可以处理原始值，也可以处理对象</td>
        <td>只能处理对象</td>
      </tr>
      <tr>
        <td>需要加 .value，需要考虑自动解包</td>
        <td>不需要加 .value</td>
      </tr>
      <tr>
        <td>有单独的类型</td>
        <td>和普通的对象没有什么区别，无法直接通过类型判断是否是响应式</td>
      </tr>
      <tr>
        <td>可以使用解构赋值</td>
        <td>不可以使用解构赋值，会丢失响应式</td>
      </tr>
      <tr>
        <td></td>
        <td>需要使用箭头函数包装才能使用 watch</td>
      </tr>
    </tbody>
  </table>
  <p data-pid="aVtdgg6d"><b>3.5.2 考虑响应式和 .value </b></p>
  <p data-pid="mIuWJkq7">虽然写 Composition API 不会有 <code>useEffect</code> 的困扰，还能使用完全一致的生命周期钩子函数，但是此次 Vue 把响应式 API
    暴露给我们，实际上在编写代码的时候，需要考虑是否是响应式、是否是 ref 和响应式丢失的问题，也会带来一定的心智负担。 </p>
  <h2>总结</h2>
  <blockquote data-pid="dwydTu3z"><b>面向生命周期编程 vs 面向业务逻辑编程</b> <br>Composition API
    带来了组件逻辑抽取和复用的优化，抽取逻辑会变得非常简单，所以我们不必只在需要复用逻辑的时候才抽取函数，也可以单纯为了更好地组织代码去抽取函数，以此避免每个逻辑任务的代码都被选项切成了多个碎片分散在各处。
    <br>当然如果组件足够简单，我们还是可以只使用 Options API，以原来的习惯写代码。
  </blockquote>
  <p class="ztext-empty-paragraph"><br></p>
  <blockquote data-pid="nZaUCgyk"><b>我可以在 Vue 2 中使用吗？</b> <br>可以的，官方团队提供了可供 Vue 2 使用的插件： <a class="link" 
       href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/composition-api"  class=" wrap external"
      target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">@vue/composition-api <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。 <br>另外他们也计划让
    Composition API 在 Vue 2.7 原生支持。</blockquote>
  <h2>参考 </h2>
  <p data-pid="0nG5Lg4p"><a class="link" 
       href="https://link.zhihu.com/?target=https%3A//v3.cn.vuejs.org/guide/composition-api-introduction.html%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E7%25BB%2584%25E5%2590%2588%25E5%25BC%258F-api" 
      class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
  <p data-pid="CEjDQuk6"><a class="link"   href="https://zhuanlan.zhihu.com/p/68477600"  class="internal"
      data-za-detail-view-id="1043">Vue Function-based API RFC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
  <p data-pid="PF0H7EFU"><a class="link"   href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1x54y1V7H6/" 
      class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">VueUse 作者 Anthony
      Fu 分享可组合的 Vue <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
  <p data-pid="cxCCci-C"><a class="link"   href="https://zhuanlan.zhihu.com/p/146097763"  class="internal"
      data-za-detail-view-id="1043">深入理解 Vue3 Reactivity API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
</div>]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】01，作用域与闭包</title>
    <url>/2021/02/23/someInterestingQuestions01/</url>
    <content><![CDATA[<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i&#x27;</span>,i)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2021/02/23/someInterestingQuestions01/q1.png"
                      class="" title="结果"
                ></p>
<p><code>原因</code>：异步代码会在同步代码执行完毕后执行</p>
<p><code>分析</code>：在执行 setTimeout 中的 console.log 打印变量 i 时，对标识符 i 进行 RHS 查询，因为在当前作用域找不到对应标识符，所以向上前往父级作用域寻找。所以打印的其实是 for 循环中声明的变量 i，而此时已经经过循环赋值变成了 5</p>
<p><strong>解决方案一：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code> 结果</code>：1 秒后连续打印 0 1 2 3 4 </p>
<p><code>原因</code>：IIFE 使得对打印的标识符 i 的查询终止于当前作用域，不用向上继续查询 分析：console.log 打印变量 i 时，发现该标识符对应当前作用域中的形参，其值为传入的实参。所以每次执行 console.log 语句，变量 i 的值都会被覆盖，第一次为 0，第二次为 1，依次类推打印 0 1 2 3 4，而 for 循环中声明的变量 i，其值为 5</p>
<p><strong>解决方案二：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  <span class="title function_">setTimeourt</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：1 秒后连续打印 0 1 2 3 4</p>
<p><code>原因</code>：let 声明不会产生变量提升，并且会绑定当前作用域。for 循环头部的 let 声明会有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>
<hr>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="title class_">Foo</span>(),</span><br><span class="line">    f2 = <span class="title class_">Foo</span>();</span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2021/02/23/someInterestingQuestions01/q2.png"
                      class="" title="结果"
                ></p>
<p><code>原因</code>：</p>
<p>第一次调用函数 f1()：打印 0，创建闭包，此时局部变量 i&#x3D;1；</p>
<p>第二次调用函数 f1()：打印 1，创建闭包，此时局部变量 i&#x3D;2；</p>
<p>第一次调用函数 f2()：打印 0，因为函数 f1、f2 指向不同对象。</p>
<hr>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 类变量 a</span></span><br><span class="line">  <span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例变量 a，每个实例都有一个</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例变量 a，所有实例共享一个</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类变量 a</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">obj.<span class="title function_">a</span>();</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br></pre></td></tr></table></figure></div>
<p><code>结果</code>：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2021/02/23/someInterestingQuestions01/q3.png"
                      class="" title="结果"
                ></p>
<p><code>原因</code>：</p>
<p>打印 4：一开始 Foo 方法并未调用，输出的是函数体外的变量 a，此时可以把 Foo 当作对象，Foo.a 为其对象属性。</p>
<p>打印 2：使用 new 操作符实例化 Foo 后，obj.a 首先查找 obj 上的标识符 a，如果找不到的话沿着原型链向上查找，也找不到的话返回 undefined。</p>
<p>打印 1：此时 Foo 方法已经调用，方法体内的类变量 a 覆盖原来已经赋值的类变量 a。</p>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3 源码学习】01，从 createApp() 方法开始</title>
    <url>/2022/06/03/vueSourceCodeStudy01/</url>
    <content><![CDATA[<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s0.jpg"
                      class="" title="s0"
                >
<p>PS: 这是一张很有用的图</p>
<h2 id="前言：怎样学习源码？"><a href="#前言：怎样学习源码？" class="headerlink" title="前言：怎样学习源码？"></a>前言：怎样学习源码？</h2><ol>
<li>有主线，两种方式<ol>
<li>从入口入手，package.json–&gt;</li>
<li>从逻辑入手，createApp()</li>
</ol>
</li>
<li>提出一个问题，在源码中找答案</li>
<li>学习一步整理一步，然后复盘复习（画图）</li>
<li>有所掌握后造轮子实践</li>
<li>写博客或者做视频，在知识分享中巩固知识</li>
</ol>
<h2 id="首先提几个问题"><a href="#首先提几个问题" class="headerlink" title="首先提几个问题"></a>首先提几个问题</h2><ul>
<li>第一个问题：app 实例如何创建？</li>
<li>第二个问题：app 实例中有些什么？</li>
</ul>
<h2 id="第一个问题：app-实例如何创建？"><a href="#第一个问题：app-实例如何创建？" class="headerlink" title="第一个问题：app 实例如何创建？"></a>第一个问题：app 实例如何创建？</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-1.png"
                      class="" title="s1-1"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-2.png"
                      class="" title="s1-2"
                >
<p>createApp() 函数内部的 ensureRenderer() 方法返回了一个渲染器 renderer（），这个 renderer 调用了 createApp() 创建实例。可以看到在 ensureRenderer() 方法内部调用了 createRenderer() 方法，进入其中会发现一个工厂函数 baseCreateRenderer()。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-3.png"
                      class="" title="s1-3"
                > 
<p>查看 baseCreateRenderer() 方法的实现，会发现它返回了一个方法 createAppAPI()，进入 createAppAPI() 方法内部，会发现这又是一个工厂函数，返回一个 createApp() 方法，而这就是图一中一开始调用的 createApp()。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-4.png"
                      class="" title="s1-4"
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-5.png"
                      class="" title="s1-5"
                >

<h2 id="第二个问题：app-实例中有些什么？"><a href="#第二个问题：app-实例中有些什么？" class="headerlink" title="第二个问题：app 实例中有些什么？"></a>第二个问题：app 实例中有些什么？</h2><p>在 createAppAPI() 方法的实现代码中，我们可以找到实例 app 的实现，它包含了一些实例属性和实例方法，我们所熟悉的 use、mixin、component、directive、mount、unmount、provide 尽在其上</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy01/s1-6.png"
                      class="" title="s1-6"
                >

<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>可以发现，相比于 vue2 来说，vue3 将全局方法挂载到了实例 app 上（vue2 是挂载在构建函数 Vue 上），这样我们使用这些方法的方式发生了变化</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">&#x27;./vueSourceCodeStudy01/myComponent&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> myPlugin <span class="keyword">from</span> <span class="string">&#x27;./myPlugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;myComponent&#x27;</span>,myComponent);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(myPlugin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3</span></span><br><span class="line"><span class="title function_">createApp</span>(&#123;...&#125;).<span class="title function_">coponent</span>(myComponent).<span class="title function_">use</span>(myPlugin).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
<p>这样做有什么好处呢？我认为是为了应付多实例场景，这样做更加便于维护且清晰易懂。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3 源码学习】02，初始 mount() 方法</title>
    <url>/2022/06/03/vueSourceCodeStudy02/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书接上回，在 runtime-core 包下的文件<code>/runtime-core/src/apiCreateApp.ts</code>中我们找到了 createAppAPI() 方法，此方法调用时创建一个 app 实例，在这个实例中挂载了一些我们熟悉的实例方法，<code>mount()</code>就在其中。</p>
<h2 id="首先提几个问题"><a href="#首先提几个问题" class="headerlink" title="首先提几个问题"></a>首先提几个问题</h2><ol>
<li>初次挂载时 mount() 方法做了些什么？ </li>
<li>回忆一下 vue 的生命周期，mount() 方法在哪一部分执行了？<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s0.png"
                      class="" title="s2-0"
                ></li>
</ol>
<h2 id="初次挂载时-mount-方法干了些什么？"><a href="#初次挂载时-mount-方法干了些什么？" class="headerlink" title="初次挂载时 mount() 方法干了些什么？"></a>初次挂载时 mount() 方法干了些什么？</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-1.png"
                      class="" title="s2-1"
                >

<p>首先进入 mount() 方法，它接收 3 个参数：<code>rootContainer</code>，isHydrate，isSVG，我们这里只关注 rootContainer，因为初次挂载时的一般写法是：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到我们只传了一个字符串，是一个 CSS 选择器。</span></span><br><span class="line"><span class="title function_">createApp</span>(&#123;&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>再看方法体：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-2.png"
                      class="" title="s2-2"
                >

<p>可以看到首先创建了一个 vnode，这个 vnode 由 createApp 方法传入的根组件确定；然后执行红框中的 render() 方法，我们传入的 rootContainer 作为第二个参数传入。</p>
<p>让我们看看这个 render 方法，它是 createAppAPI() 方法的第一个参数，上一章介绍过这是 baseCreateRenderer() 这个工厂函数的返回，它在<code>/runtime-core/src/renderer.ts</code>目录下可以找到。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-3.png"
                      class="" title="s2-3"
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-4.png"
                      class="" title="s2-4"
                >

<p>接下来找到 render() 方法的方法体：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-5.png"
                      class="" title="s2-5"
                >

<p>可以看到 render() 方法接收三个参数，初次挂载时 vnode 有值，container 是我们 mount() 方法传入的挂载节点。因为 vnode 存在，所以执行 else 部分，可以看到，这里使用了一个<code>patch()</code>方法</p>
<p>我们来看一下这个 patch() 方法中传了些什么：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-6.png"
                      class="" title="s2-6"
                >

<p>可以看出传入的 container 参数是一个 DOM 对象，在第一次挂载时指向<code>div#app</code>，我们的宿主对象，此时 container._vnode 值为 undefined（在 render 方法的最后才会给_vnode 属性赋值），所以第一个参数值为 null，第二个参数是之前传入的 vnode 对象，长这样：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-7.png"
                      class="" title="s2-7"
                >

<p>之后会用到，此时先不做关注。我们再来看看 patch() 方法内部：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-8.png"
                      class="" title="s2-8"
                >

<!-- 
  YCNOTE：为什么 switch 语句要传入一个对象
 -->
<p>沿着逻辑往下走到红框部分，此时从我们传入的 vnode（第一次挂载时 mount 方法中新建的 vnode) 中取出 3 个值，根据<code>type</code>和<code>shapeFlag</code>的值进行不同的操作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-10.png"
                      class="" title="s2-10"
                >

<p>此时 shapeFlag 的值为 4，进行位与运算值为 true。以下<code>位移枚举</code>可以学一下，它的好处是清晰、好计算并且可以进行多值判断。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-11.png"
                      class="" title="s2-11"
                >

<p>初次挂载时执行<code>processComponent()</code>方法，进入方法体 processComponent()：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-12.png"
                      class="" title="s2-12"
                >

<p>可以看到走进 else 代码块，触发方法<code>mountComponent()</code>，见名知意，组件由这个方法挂载。进入该方法，该方法首先会执行一个<code>setupRenderEffect()</code>方法，</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-13.png"
                      class="" title="s2-13"
                >

<p>这个方法创建了一个执行器 <code>effect</code>，然后调用了 effect.run() 方法，当 effect.run() 执行完毕时，整个挂载流程结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，初次挂载时 mount() 方法执行流程大概这样：</p>
<p>mount()–&gt;createVNode()–&gt;render()–&gt;patch()–&gt;processComponent()–&gt;mountComponent()–&gt;createComponentInstance–&gt;setupRenderEffect()–&gt;ReactiveEffect()–&gt;update()–&gt;effect.run()</p>
<p>简洁一点就是：</p>
<p>mount()–&gt;render()–&gt;patch()</p>
<p>可以通过调用堆栈查看：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-14.png"
                      class="" title="s2-14"
                >

<p>回到最初提的两个问题，第一个问题已经基本解答完毕，第二个问题，mount() 函数在 vue 的生命周期的哪一部分执行也已经可以推想出来：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/06/03/vueSourceCodeStudy02/s2-15.png"
                      class="" title="s2-15"
                >

<p>本篇文章就到此为止，因为是初识，所以比较简单，基本上就是跟着调用栈走，之后会更具体的分析 render() 和 patch() 函数。</p>
<p>若有错误请大佬指出，感激不尽。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】04，逗号运算符</title>
    <url>/2021/03/14/someInterestingQuestions04/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;<span class="number">6</span>,j&lt;<span class="number">5</span>,i++,j++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><code>参考资料</code></h2>]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】03，浮点数</title>
    <url>/2021/03/06/someInterestingQuestions03/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>；</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> - <span class="number">0.9</span> == <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>
<p>在 JS 中只有一种数值类型，以 64 位表示的双精度浮点类型</p>
<p><code>解决方法</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>).<span class="title function_">toFixed</span>(<span class="number">10</span>) == <span class="number">0.3</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span> - <span class="number">0.9</span>).<span class="title function_">toFixed</span>(<span class="number">10</span>) == <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p><code>可以把运算封装成方法</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法函数，用来得到精确的加法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。</span></span><br><span class="line"><span class="comment">//调用：accAdd(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 加上 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accAdd</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> r1,r2,m;</span><br><span class="line">  <span class="keyword">try</span>&#123;r1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;r2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">  m=<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,<span class="title class_">Math</span>.<span class="title function_">max</span>(r1,r2))</span><br><span class="line">  <span class="keyword">return</span> (arg1*m+arg2*m)/m</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 Number 类型增加一个 add 方法，调用起来更加方便。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">arg</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">accAdd</span>(arg,<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//减法函数，用来得到精确的减法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的减法结果。</span></span><br><span class="line"><span class="comment">//调用：accSub(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 减去 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accSub</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> r1,r2,m,n;</span><br><span class="line">  <span class="keyword">try</span>&#123;r1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r1=<span class="number">0</span>&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;r2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;r2=<span class="number">0</span>&#125;</span><br><span class="line">  m=<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,<span class="title class_">Math</span>.<span class="title function_">max</span>(r1,r2));</span><br><span class="line">  <span class="comment">//last modify by deeka</span></span><br><span class="line">  <span class="comment">//动态控制精度长度</span></span><br><span class="line">  n=(r1&gt;=r2)?<span class="attr">r1</span>:r2;</span><br><span class="line">  <span class="keyword">return</span> ((arg1*m-arg2*m)/m).<span class="title function_">toFixed</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//除法函数，用来得到精确的除法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。</span></span><br><span class="line"><span class="comment">//调用：accDiv(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 除以 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accDiv</span>(<span class="params">arg1,arg2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>,r1,r2;</span><br><span class="line">  <span class="keyword">try</span>&#123;t1=arg1.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;t2=arg2.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="title function_">with</span>(<span class="params"><span class="built_in">Math</span></span>)&#123;</span><br><span class="line">    r1=<span class="title class_">Number</span>(arg1.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))</span><br><span class="line">    r2=<span class="title class_">Number</span>(arg2.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> (r1/r2)*<span class="title function_">pow</span>(<span class="number">10</span>,t2-t1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 Number 类型增加一个 div 方法，调用起来更加方便。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">div</span> = <span class="keyword">function</span> (<span class="params">arg</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">accDiv</span>(<span class="variable language_">this</span>, arg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//乘法函数，用来得到精确的乘法结果</span></span><br><span class="line"><span class="comment">//说明：javascript 的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。</span></span><br><span class="line"><span class="comment">//调用：accMul(arg1,arg2)</span></span><br><span class="line"><span class="comment">//返回值：arg1 乘以 arg2 的精确结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">accMul</span>(<span class="params">arg1,arg2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> m=<span class="number">0</span>,s1=arg1.<span class="title function_">toString</span>(),s2=arg2.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="keyword">try</span>&#123;m+=s1.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;m+=s2.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>].<span class="property">length</span>&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title class_">Number</span>(s1.<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))*<span class="title class_">Number</span>(s2.<span class="title function_">replace</span>(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>))/<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">10</span>,m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 Number 类型增加一个 mul 方法，调用起来更加方便。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mul</span> = <span class="keyword">function</span> (<span class="params">arg</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">accMul</span>(arg, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;br&gt;<span class="comment">//验证一下：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">accAdd</span>(<span class="number">1.79</span>, <span class="number">0.12</span>));  <span class="comment">//1.91</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">accSub</span>(<span class="number">2.01</span>, <span class="number">0.12</span>));  <span class="comment">//1.89</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">accDiv</span>(<span class="number">0.69</span>, <span class="number">10</span>));    <span class="comment">//0.069&lt;br&gt;console.log(accMul(1.01, 1.3));   //1.313　　</span></span><br></pre></td></tr></table></figure></div>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><code>参考资料</code></h2><ul>
<li><a class="link"   href="https://www.cnblogs.com/ppforever/p/5011660.html" >浅谈 JavaScript 浮点数及其运算 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.w3school.com.cn/js/js_numbers.asp" >JavaScript 数字
 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】05，for..in 与 for..of</title>
    <url>/2021/03/20/someInterestingQuestions05/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 此时 arr 对象的结构：[3,5,7,foo: &#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出 &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 for...of 的输出没有出现 &quot;hello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><code>for...in </code></p>
<ul>
<li>循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。</li>
<li>深入一点</li>
</ul>
<p><code>for...of </code></p>
<ul>
<li>在可迭代对象（包括 Array、Map、Set、arguments 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。</li>
<li>首先会在向访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。</li>
</ul>
<p><code>Symbol.iterator</code></p>
<ul>
<li>为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用。</li>
<li>可以通过 Symbol.iterator 来访问可迭代对象的@@iterator 属性<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> it = myArray[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【一些有趣的问题】06，进制转换</title>
    <url>/2021/03/27/someInterestingQuestions06/</url>
    <content><![CDATA[<p><code>以下语句会如何输出？</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">022</span> - <span class="number">017</span></span><br><span class="line"><span class="comment">// 3，18 - 15 = 3</span></span><br><span class="line"></span><br><span class="line"><span class="number">018</span> - <span class="number">045</span></span><br><span class="line"><span class="comment">// -19，18 - 37 = -19</span></span><br></pre></td></tr></table></figure></div>
<p>在 JS 中，在 Number 类型前加 0 会转换为 8 进制，如果原来的值位上有大于 8 的数，则不会进行转换。</p>
<p>在 JS 中，有几种方法来进行进制转换，但只能通过 10 进制中转，即 10 进制转其他进制或者其他进制转 10 进制。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0x 表示十六进制，但是 js 会强制转换为十进制来运算，0xa == 10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0xa</span>;</span><br><span class="line"><span class="comment">// 0 开头表示八进制，同样强制转换为十进制来运算 010 = 8</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.parseInt 方法把字符串（只能由字母和数字组成）由低进制转高进制，如二进制转八进制，但是八进制不能转二进制，radix 表示进制，取值 2~36，返回一个字符串。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(string,radix)</span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&#x27;0101&#x27;</span>,<span class="number">2</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&#x27;0101&#x27;</span>,<span class="number">8</span>) <span class="comment">// 65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.toString 方法将十进制数字转换为任意进制的字符串形式，同样，radix 表示进制，取值 2~36</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">toString</span>(radix)</span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">//&quot;1010&quot; 转 2 进制</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">8</span>) <span class="comment">//&quot;12&quot; 转 8 进制</span></span><br><span class="line">(<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">16</span>) <span class="comment">//&quot;a&quot; 转 16 进制</span></span><br><span class="line">(<span class="number">1000</span>).<span class="title function_">toString</span>(<span class="number">36</span>) <span class="comment">//&quot;rs&quot; 转 36 进制</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>一些有趣的问题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3 源码学习】03，初始 mount() 方法</title>
    <url>/2022/06/03/vueSourceCodeStudy03/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书接上回，在 runtime-core 包下的文件<code>/runtime-core/src/apiCreateApp.ts</code>中我们找到了 createAppAPI() 方法，此方法调用时创建一个 app 实例，在这个实例中挂载了一些我们熟悉的实例方法，<code>mount()</code>就在其中。</p>
<h2 id="首先提几个问题"><a href="#首先提几个问题" class="headerlink" title="首先提几个问题"></a>首先提几个问题</h2><ol>
<li>初次挂载时 mount() 方法做了些什么？ </li>
<li>回忆一下 vue 的生命周期，mount() 方法在哪一部分执行了？</li>
</ol>
<h2 id="初次挂载时-mount-方法干了些什么？"><a href="#初次挂载时-mount-方法干了些什么？" class="headerlink" title="初次挂载时 mount() 方法干了些什么？"></a>初次挂载时 mount() 方法干了些什么？</h2>

<p>首先进入 mount() 方法，它接收 3 个参数：<code>rootContainer</code>，isHydrate，isSVG，我们这里只关注 rootContainer，因为初次挂载时的一般写法是：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以看到我们只传了一个字符串，是一个 CSS 选择器。</span></span><br><span class="line"><span class="title function_">createApp</span>(&#123;&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>再看方法体：</p>


<p>可以看到首先创建了一个 vnode，这个 vnode 由 createApp 方法传入的根组件确定；然后执行红框中的 render() 方法，我们传入的 rootContainer 作为第二个参数传入。</p>
<p>让我们看看这个 render 方法，它是 createAppAPI() 方法的第一个参数，上一章介绍过这是 baseCreateRenderer() 这个工厂函数的返回，它在<code>/runtime-core/src/renderer.ts</code>目录下可以找到。</p>




<p>接下来找到 render() 方法的方法体：</p>


<p>可以看到 render() 方法接收三个参数，初次挂载时 vnode 有值，container 是我们 mount() 方法传入的挂载节点。因为 vnode 存在，所以执行 else 部分，可以看到，这里使用了一个<code>patch()</code>方法</p>
<p>我们来看一下这个 patch() 方法中传了些什么：</p>


<p>可以看出传入的 container 参数是一个 DOM 对象，在第一次挂载时指向<code>div#app</code>，我们的宿主对象，此时 container._vnode 值为 undefined（在 render 方法的最后才会给_vnode 属性赋值），所以第一个参数值为 null，第二个参数是之前传入的 vnode 对象，长这样：</p>


<p>之后会用到，此时先不做关注。我们再来看看 patch() 方法内部：</p>


<!-- 
  YCNOTE：为什么 switch 语句要传入一个对象
 -->
<p>沿着逻辑往下走到红框部分，此时从我们传入的 vnode（第一次挂载时 mount 方法中新建的 vnode) 中取出 3 个值，根据<code>type</code>和<code>shapeFlag</code>的值进行不同的操作：</p>


<p>此时 shapeFlag 的值为 4，进行位与运算值为 true。以下<code>位移枚举</code>可以学一下，它的好处是清晰、好计算并且可以进行多值判断。</p>


<p>初次挂载时执行<code>processComponent()</code>方法，进入方法体 processComponent()：</p>


<p>可以看到走进 else 代码块，触发方法<code>mountComponent()</code>，见名知意，组件由这个方法挂载。进入该方法，该方法首先会执行一个<code>setupRenderEffect()</code>方法，</p>


<p>这个方法创建了一个执行器 <code>effect</code>，然后调用了 effect.run() 方法，当 effect.run() 执行完毕时，整个挂载流程结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，初次挂载时 mount() 方法执行流程大概这样：</p>
<p>mount()–&gt;createVNode()–&gt;render()–&gt;patch()–&gt;processComponent()–&gt;mountComponent()–&gt;createComponentInstance–&gt;setupRenderEffect()–&gt;ReactiveEffect()–&gt;update()–&gt;effect.run()</p>
<p>简洁一点就是：</p>
<p>mount()–&gt;render()–&gt;patch()</p>
<p>可以通过调用堆栈查看：</p>


<p>回到最初提的两个问题，第一个问题已经基本解答完毕，第二个问题，mount() 函数在 vue 的生命周期的哪一部分执行也已经可以推想出来：</p>


<p>本篇文章就到此为止，因为是初识，所以比较简单，基本上就是跟着调用栈走，之后会更具体的分析 render() 和 patch() 函数。</p>
<p>若有错误请大佬指出，感激不尽。</p>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【方法论】前端工程化的一些理解</title>
    <url>/2022/07/28/MethodologyFrontendEngineering/</url>
    <content><![CDATA[<h1 id="前端工程化的一些理解"><a href="#前端工程化的一些理解" class="headerlink" title="前端工程化的一些理解"></a>前端工程化的一些理解</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/07/28/MethodologyFrontendEngineering/s0.png"
                      class="" title="s0"
                >

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目开发中常常听到前端工程化，那么什么是前端工程化，其要义在于何处，我想是值得了解的问题。</p>
<p>它有哪些目的，解决了哪些问题，又以何种方式实现，这些都是值得探究、值得思考的。</p>
<h2 id="什么是前端工程化？"><a href="#什么是前端工程化？" class="headerlink" title="什么是前端工程化？"></a>什么是前端工程化？</h2><p>关于什么是前端工程化，这里先给出我的理解：</p>
<ul>
<li>狭义上的理解：将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署</li>
<li>广义上理解：前端工程化应该包含从编码开始到发布，运行和维护阶段</li>
</ul>
<p>简而言之，在前端规模越来越大，业务逻辑越来越复杂的今天，一切可以<code>提高效率、降低成本、质量保证</code>的手段都可以称得上是前端工程化。如果说软件工程是面向问题的（将软件开发流程中的共性抽离出来），把软件工程的思想带入到前端开发中，就是前端工程化。</p>
<p>一个前端项目的开发流程可以概括为：</p>
<blockquote>
<p>需求分析–&gt;<code>设计阶段</code>–&gt;<code>开发阶段</code>(–&gt;测试阶段–&gt;部署阶段）–&gt;项目维护</p>
</blockquote>
<p>也可以说，前端工程化主要发生在设计阶段和开发阶段，解决的是<code>开发阶段到项目维护阶段</code>的生产效率问题。</p>
<h2 id="前端工程化要解决哪些问题？"><a href="#前端工程化要解决哪些问题？" class="headerlink" title="前端工程化要解决哪些问题？"></a>前端工程化要解决哪些问题？</h2><p>在项目过程中，一些问题是共通的，在设计阶段，需要考虑：</p>
<ol>
<li>怎样提高开发效率，降低开发成本？</li>
<li>怎样提高代码健壮性、降低维护难度？</li>
</ol>
<p>在开发阶段，需要考虑的问题有：</p>
<ol>
<li>代码审查</li>
<li>压缩打包</li>
<li>单元测试</li>
<li>增量更新</li>
</ol>
<h2 id="如何实现前端工程化？"><a href="#如何实现前端工程化？" class="headerlink" title="如何实现前端工程化？"></a>如何实现前端工程化？</h2><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>根据前文，能够知道在设计阶段面临的一些问题，那么怎么解决呢？</p>
<p>我们需要知道前端项目在设计阶段要做的一些事情：技术选型、确立规范、排期、分工。</p>
<p>而技术选型和确立规范就是其中的重中之重。</p>
<p><code>技术选型</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/07/28/MethodologyFrontendEngineering/s1.png"
                      class="" title="s1"
                >
<p>无论是技术框架、编程语言、工具库、UI 库，都属于技术选型的范畴。</p>
<p>一般要遵循的原则有 4 点：</p>
<ol>
<li>可控性</li>
<li>稳定性</li>
<li>适用性</li>
<li>易用性</li>
</ol>
<p>一般来说，前端项目选择的框架是 Vue、React、Angular 的一种，根据项目规模和团队技术栈选择其他的工具库、UI 库。</p>
<p>关于技术选型，可以看看这篇文章 <a class="link"   href="https://zhuanlan.zhihu.com/p/346410244" >技术选型 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><code>统一规范</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/07/28/MethodologyFrontendEngineering/s2.png"
                      class="" title="s2"
                >

<p>根据项目规模的不同，统一规范的重要性也不可一概而论，但总的来说，统一规范的重要性是随着项目复杂度的提升而提升的。</p>
<p>有哪些地方需要统一规范呢？</p>
<ul>
<li>代码格式化：eslint、tslint</li>
<li>代码提交规范：可以使用 git 的钩子函数自定义</li>
<li>设计规范：由需求设计人员提供</li>
<li>文档规范：注明公共 API、全局变量等</li>
<li>一些约定：<ul>
<li>目录结构约定：在什么地方做什么事</li>
<li>命名约定：变量、函数、css 类</li>
<li>版本管理</li>
<li>开发流程</li>
</ul>
</li>
</ul>
<h2 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a><code>开发</code></h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/07/28/MethodologyFrontendEngineering/s3.png"
                      class="" title="s3"
                >

<p>在开发过程中，工程化主要在自建库、选择第三方库、搭建脚手架时发挥作用。</p>
<p>自建库抽离公共函数，避免重复造轮子，应约定尽量使用自建库的方法。</p>
<p>当自建库不能满足需求时，可以选择第三方库来弥补，第三方库应该关注安全性、稳定性、采取最小限度原则（即只使用必要的部分）。</p>
<p>自定义工程脚手架也是非常重要的一部分，可以大大降低重复工作量，脚手架实践了<code>能够交给机器的事情就交给机器去做</code>这一思想。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a><code>测试</code></h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/07/28/MethodologyFrontendEngineering/s4.png"
                      class="" title="s4"
                >

<p>无论是什么项目，只要它仍在开发迭代，测试就是必要的一环。</p>
<p>一个完整的项目开发流程图如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/07/28/MethodologyFrontendEngineering/s4-1.png"
                      class="" title="s4-1"
                >

<p>常用的测试分类有<code>单元测试</code>和<code>集成测试</code>，在开发过程中使用的是单元测试，那么什么是单元测试？</p>
<blockquote>
<p>单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p>
</blockquote>
<p>常见的单元测试工具有：Jest、Mocha 等。</p>
<p>一些框架内也集成了单元测试工具，可以根据具体情况选择。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a><code>部署</code></h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/07/28/MethodologyFrontendEngineering/s5.png"
                      class="" title="s5"
                >

<p>在项目的部署阶段，我们聚焦于构建和部署。</p>
<p>在构建时需要关注性能优化、自定义配置等，常用构建工具有 webpack、rollup、vite 等，他们各有特点，这里不加赘述。</p>
<p>在部署时需要关注自动化、易用性等，常用的部署工具有 Jenkins。</p>
<p>其他还有灰度和 CDN 等概念，灰度可以理解为青春使用版，即新版本发布时控制流量，易于回退。CDN 技术则是优化网络访问速度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前端工程化的要义在于：把能够交给机器的事情尽量交给机器去做。</p>
<p>其重点在于<code>统一</code>，统一的代码规范、统一的命名约定、统一的技术栈、第三方库等等。</p>
<p>而在实际项目开发过程中，前端工程化的实践既依赖设计师、架构师对于项目的先期构建，更强调开发团队间的意见交流。了解工程化概念，明晰其目的，才能避免重复造轮子，代码结构混杂不清等疏漏，提高代码复用性和健壮性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a class="link"   href="https://woai3c.gitee.io/introduction-to-front-end-engineering/#%E7%AE%80%E4%BB%8B" >带你入门前端工程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/fsyz/p/8274727.html" >浅谈什么是前端工程化	 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/6844903853859536903" >大型项目前端架构浅谈 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【方法论】JS 模块化梳理</title>
    <url>/2022/03/09/MethodologyFrontendJSModularity%20/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模块化是编程中绕不过去的一环，可以说在我们的开发流程中，每时每刻都在使用着模块化，这无疑是一个非常重要的知识点。本文只讨论 JS 模块化，旨在加强对 JS 模块化的认识。主要涉及以下几点：</p>
<ul>
<li>JS 模块化的前世今生（为什么要模块化）</li>
<li>JS 模块化的本质（如何实现模块化）</li>
</ul>
<h2 id="一、JS-模块化的前世今生"><a href="#一、JS-模块化的前世今生" class="headerlink" title="一、JS 模块化的前世今生"></a>一、JS 模块化的前世今生</h2><h3 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h3><p>大家都知道模块化是复杂项目中必不可少的一环，良好的模块化能让项目结构更加清晰，提高代码复用性，逻辑与功能分离，加强可维护性。但在一开始，Javascript 中是不存在模块化的，它只是一门玩具语言，为网页添加一点特效而已。功能简单，用法单一。</p>
<p>此时的 js 代码的书写方式是，从上到下，简单明了，直到<code>ajax</code>出现。</p>
<h3 id="模块化萌芽"><a href="#模块化萌芽" class="headerlink" title="模块化萌芽"></a>模块化萌芽</h3><p>Google 将 ajax 概念发扬光大，在 Gmail 和 Google 地球等网页应用中大量使用了 ajax 技术，此时人们才惊觉利用 javascript 能够在网页中做到什么。于是越来越多的大型 web 项目开始出现，随之而来的是越来越复杂的业务逻辑与项目结构。问题不可避免的出现了。</p>
<ol>
<li><code>全局变量污染</code><br>因为大家写的代码都在同一个全局作用域中，一不小心就可能声明一个已经存在的全局变量，往往就会发生难以预测的错误，这里举一个例子：<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是我写的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是同事写的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;c.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;这里请不要改&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面有 3 个脚本，a.js、b.js 是我写的，c.js 是同事写的，我定义了一个全局变量 name，同事不知道，他定义了一个全局方法 name()，于是我俩都得懵逼。</p>
<p><em>解决方案</em></p>
<p>解决方法之一是使用自执行函数包裹：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">myModule = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> id = <span class="string">&#x27;user_id&#x27;</span></span><br><span class="line">	...</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></div>
<p>这种方式解决了全局变量污染的问题，但仍暴露了一个全局函数在全局，仍可能存在命名冲突，并且有时需定义许多个这种类型的函数，不够优雅。</p>
<ol start="2">
<li><code>函数命名冲突</code><br>我们经常将一些功能性的函数抽离出来，放在同一个功能文件中，例如 utils.js 文件下放了一个 format 方法，这时同事需要一个不同的 format 方法，他就只能新建一个 format2 或者其他名字的方法，类似的事情很多。</li>
</ol>
<p><em>解决方案</em></p>
<p>解决方法之一是使用命名空间，构造类似 java 的方式，于是代码变成了这样：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">MyNameSpace</span>.<span class="property">Utils</span>.<span class="title function_">format</span>()</span><br></pre></td></tr></table></figure></div>
<p>这种类型的代码确实有用，但大大增加了书写的负担，你只想调用一个方法，却不得不写一长串的前缀。</p>
<ol start="3">
<li><code>文件依赖混乱</code><br>文件的依赖往往是无法避免的，例如实现一个 dialog 组件，它调用了一些 utils.js 文件里的方法，那么在引入<code>&lt;script src=&quot;dialog&quot;&gt;</code>之前，需要先引入<code>&lt;script src=&quot;utils&quot;&gt;</code>，当类似的情况越来越多时，依赖就难免混杂，从而增加维护难度。</li>
</ol>
<p><em>解决方案</em></p>
<p>这是 Yahoo! 的 YUI3 框架解决方案，通过 requires 一个依赖数组来指定依赖：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">YUI</span>.<span class="title function_">add</span>(<span class="string">&#x27;my-module&#x27;</span>, <span class="keyword">function</span> (<span class="params">Y</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="string">&#x27;0.0.1&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">requires</span>: [<span class="string">&#x27;node&#x27;</span>, <span class="string">&#x27;event&#x27;</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>这种类型的代码确实解决了依赖混乱的问题，但当一个文件依赖增多时，这种配置型的代码就会变得复杂而且难看。</p>
<p>在这个时期，不同的 web 团队为了解决项目中遇到的这类难题提出了自己的解决方案，但没有哪种解决方案可以解决所有的问题。</p>
<h3 id="几种模块化规范"><a href="#几种模块化规范" class="headerlink" title="几种模块化规范"></a>几种模块化规范</h3><p>从以上的例子中可以观察到一些模块化所面临的难题：</p>
<ol>
<li>如何安全的包装一个模块（不污染模块外的代码）</li>
<li>如何定义模块的唯一标识（解决命名冲突）</li>
<li>如何优雅的暴露模块（不增加复杂依赖）</li>
<li>模块间互相引用的循环依赖问题</li>
</ol>
<p>在 nodeJS 出现后，Javascript 可以用来编写服务端程序，这时 Javascript 没有模块化的缺点变得更加令人难以忍受，nodeJS 社区开始制定 JS 模块化规范。[Modules&#x2F;1.0 规范](<a class="link"   href="https://wiki.commonjs.org/wiki/Modules/1.0" >Modules&#x2F;1.0 - CommonJS Spec Wiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)，首次定义了一个模块应该如何编写：</p>
<blockquote>
<ol>
<li>模块的标识应遵循的规则（书写规范）</li>
<li>定义全局函数 require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API</li>
<li>如果被 require 函数引入的模块中也包含依赖，那么依次加载这些依赖</li>
<li>如果引入模块失败，那么 require 函数应该报一个异常</li>
<li>模块通过变量 exports 来向往暴漏 API，exports 只能是一个对象，暴漏的 API 须作为此对象的属性。</li>
</ol>
</blockquote>
<p>一开始实现 Modules&#x2F;1.0 规范的是 ServerJS（CommonJS 改名之前的叫法），它的写法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> sum = <span class="number">0</span>,i = <span class="number">0</span>, args = <span class="variable language_">arguments</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">		sum += args[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// increment.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>).<span class="property">add</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">increment</span> = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">add</span>(val,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// program.js</span></span><br><span class="line"><span class="keyword">var</span> inc = <span class="built_in">require</span>(<span class="string">&#x27;increment&#x27;</span>).<span class="property">increment</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">inc</span>(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></div>
<p>相比于之前的阶段，此时的代码更加简洁明了，但它只能在服务端运行而难以向浏览器端推广，原因如下：</p>
<ol>
<li>外层没有 function 包裹，变量直接暴露在全局（如上 increment.js 中的 add 方法）</li>
<li>资源加载方式不同，在服务端，require 一个模块可以直接从内存中读取，消耗时间很小，但在浏览器端，require 一个模块需要向服务器发起一个 http 请求，下载完成后才能运行模块中的代码，也就是说 require 之后的代码必须等到 require 完成后才能执行。<br>因为这些问题，社区中的主张分裂为 3 种，分别是</li>
</ol>
<ul>
<li>Modules&#x2F;1.x 派</li>
<li>Modules&#x2F;Async 派</li>
<li>Modules&#x2F;2.0 派</li>
</ul>
<p><code>Modules/1.x,CommonJS,browserify</code><br>这一派人认为既然 ServerJS 能够在服务端运行良好，只需要在现有基础上进行改进就能适应浏览器端的需求，浏览器端需要 function 包裹（为了保护变量）、需要异步加载，那么就使用一种工具将现有模块转化为适合浏览器端的代码，基于这种想法有基于这个主张，制定了 <a class="link"   href="https://wiki.commonjs.org/wiki/Modules/Transport" >Modules&#x2F;Transport 规范 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，<code>browserify</code>是这种规范的一种实现，它是一种浏览器端的打包工具，能够将 nodeJS 模块转化为浏览器端可用的模块。</p>
<p><code>Modules/Async,AMD,RequireJS</code><br>这一派人认为浏览器端与服务端差别巨大，不能沿用原有模块标准。既然浏览器端需要异步加载代码，就通过回调的形式设计规范。其原理是：在模块定义时就指明并加载依赖，当依赖加载完毕后再执行回调中的本模块。因为这种异步的特性设计的规范名为 <a class="link"   href="https://github.com/amdjs/amdjs-api/wiki/AMD-%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89" >AMD（Asynchronous Module Definition） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，根据 AMD 规范出现了<code>RequireJS</code>的实现，它的写法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(id?, dependencies?, factory);</span><br><span class="line"></span><br><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;increment&#x27;</span>,[<span class="string">&#x27;math&#x27;</span>,<span class="string">&#x27;other&#x27;</span>],<span class="keyword">function</span>(<span class="params">math</span>)&#123;</span><br><span class="line">	<span class="comment">// 此时 math 和 other 模块内的代码已经执行完毕</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params">val</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> math.<span class="title function_">add</span>(val,<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 即使 other 没有被使用到，other 还是被提前执行了</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">		other.<span class="title function_">doSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>Modules/2.0 CMD Sea.js</code><br>这一派人有点类似中间派，既不想丢弃旧的规范，也不像 AMD 那样推倒重来，最终他们制定了 <a href="%5Bhttp://wiki.commonjs.org/wiki/Modules/Wrappings%5D(http://wiki.commonjs.org/wiki/Modules/Wrappings)">Modules&#x2F;Wrappings 规范</a>,<code>SeaJS</code>是它的一个实现。写法如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(factory);</span><br><span class="line"></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="built_in">exports</span>,<span class="variable language_">module</span></span>)&#123;</span><br><span class="line">	<span class="comment">// 就近原则，哪里使用哪里声明</span></span><br><span class="line">	<span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span>&#123;</span><br><span class="line">		<span class="attr">increment</span>:<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> math.<span class="title function_">add</span>(val,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，它的写法和 RequireJS 很像，那么不同之处在哪里呢？RequireJS 会在依赖加载的第一时间加载并执行依赖内的代码，然后再执行回调内的模块代码；而 SeaJS 会在声明依赖之后才会执行依赖内的代码。总的来说就是：<code>AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。</code></p>
<p><code>ES6 Module</code><br>从 ES6 开始，Javascript 开始有了标准层面的模块化，旨在成为浏览器端和服务器端的通用模块化方案。它的写法很简单，具体如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//increment.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params">val</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">add</span>(val,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>那么它和上面提到的几种模块化方案有哪些不同呢？</p>
<ol>
<li>动态只读引用<blockquote>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此</p>
</blockquote>
</li>
<li>编译时输出<blockquote>
<p>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。</p>
</blockquote>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>AMD&#x2F;CMD&#x2F;CommonJs 是 js 模块化开发的规范，对应的实现是 require.js&#x2F;sea.js&#x2F;Node.js，ES Module 是 ES6 在语言规范上的模块化实现。</li>
<li>CommonJS 主要针对服务端，AMD&#x2F;CMD&#x2F;ES Module 主要针对浏览器端，容易混淆的是 AMD&#x2F;CMD。针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行，因为这部分很快。而浏览器端采用异步加载，因为需要发送 http 请求，这就需要一个预处理，提前将所需要的模块文件并行加载好。</li>
<li>AMD&#x2F;CMD 的区别：虽然都是并行加载 js 文件，但还是有所区别，AMD 是预加载，在并行加载 js 文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而 CMD 是懒加载，虽然会一开始就并行加载 js 文件，但是不会执行，而是在需要的时候才执行。</li>
<li>AMD&#x2F;CMD 的优缺点：JS 引擎是单线程的，单位时间内只能执行单个任务，所以在加载多个大文件时，会阻塞脚本执行。AMD 会在文件全部加载完毕后才执行代码，CMD 则会遇见依赖再加载代码，在此种情况 CMD 会更快，其他情形则相差不多。</li>
<li></li>
</ol>
<h2 id="二、模块化的本质"><a href="#二、模块化的本质" class="headerlink" title="二、模块化的本质"></a>二、模块化的本质</h2><blockquote>
<p>模块化的本质在于外部只能访问模块暴露出来的属性和方法，可以通过闭包的特性实现。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生模块模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">moduleA</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">&quot;something&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> another = <span class="string">&quot;another&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(another);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">        <span class="attr">doAnother</span>: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用模块内方法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="title function_">moduleA</span>();</span><br><span class="line">foo.<span class="title function_">doSomething</span>(); <span class="comment">// something</span></span><br><span class="line">foo.<span class="property">another</span>; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 类型的模块</span></span><br><span class="line"><span class="comment">// var $ = window.jQuery()</span></span><br></pre></td></tr></table></figure></div>
<p>在这里通过调用 moduleA() 这个函数来创建模块实例 foo，通过这个模块实例可以调用模块内暴露的变量和方法，但仍存在问题，在于 moduleA 是一个全局函数，可能会造成函数名污染。也可以使用 IIFE 的方式创建：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line"><span class="keyword">var</span> foo = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">&quot;something&quot;</span>;</span><br><span class="line">	<span class="keyword">var</span> another = <span class="string">&quot;another&quot;</span>;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>)&#123;...&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>)&#123;...&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">doSomething</span>: doSomething,</span><br><span class="line">		<span class="attr">doAnother</span>: doAnother</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>
<p>这种形式避免了函数名冲突，并且实现了单例模式。</p>
<p>大多数模块加载器本质上就是将这种模块定义封装进一个 API，下面给出进一步实现：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleCreater = (<span class="keyword">function</span> <span class="title function_">Manager</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 通过 define 方法定义模块</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">define</span>(<span class="params">id,deps,impl</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; deps.<span class="property">length</span>;i++)&#123;</span><br><span class="line">			<span class="comment">// 在这里解包依赖数组</span></span><br><span class="line">			deps[i] = modules[deps[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		modules[id] = impl.<span class="title function_">apply</span>(imply,deps);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">id</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> modules[id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">define</span>: define,</span><br><span class="line">		<span class="attr">get</span>: get</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《你不知道的 Javascript》（上卷）</li>
<li><a class="link"   href="https://www.cnblogs.com/lvdabao/p/js-modules-develop.html" >js 模块化历程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/moxiaowohuwei/p/8692359.html" >js 模块化编程之彻底弄懂 CommonJS 和 AMD&#x2F;CMD！ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/seajs/seajs/issues/588" >前端模块化开发那点历史 · Issue #588 · seajs&#x2F;seajs (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://github.com/seajs/seajs/issues/269" >从 CommonJS 到 Sea.js · Issue #269 · seajs&#x2F;seajs (github.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【方法论】前端发展历程梳理</title>
    <url>/2022/03/20/MethodologyFrontendHistory/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解前端的发展历史有助于从一个全局的视角来重新认知前端技术，脱离单独某一种视角的窠臼。</p>
<ul>
<li><code>Node.js</code>的出现意味着什么？</li>
<li>为什么要从<code>jquery</code>转入三大框架？</li>
<li>既然已经有了<code>javascript</code>为什么还要使用<code>babel</code>来转化？</li>
<li><code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>、<code>ESModule</code>又是什么？</li>
</ul>
<p>类似的问题不胜枚举，而这篇文章有助于解决此类问题。</p>
<h2 id="1-需求驱动和问题驱动"><a href="#1-需求驱动和问题驱动" class="headerlink" title="1. 需求驱动和问题驱动"></a>1. 需求驱动和问题驱动</h2><p>一种技术能够出现并且不断的发展，一定具有某种内在的驱动力，我认为这种驱动力存在两种：</p>
<ol>
<li>需求驱动</li>
<li>问题驱动</li>
</ol>
<p>需求驱动顾名思义就是当前的技术工具支持不了新的需求，所以推动了新技术的产生。而问题驱动则是实现某种需求的过程中产生了困难，老旧的技术工具解决不了或者解决起来很麻烦困难，所以推动了新技术的产生。</p>
<h2 id="2-前端大事件的时间节点"><a href="#2-前端大事件的时间节点" class="headerlink" title="2. 前端大事件的时间节点"></a>2. 前端大事件的时间节点</h2><table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>web1.0 1991~2004</code></td>
<td align="left">只读网络，网站提供内容，用户阅读内容</td>
</tr>
<tr>
<td align="left">1989 年</td>
<td align="left"><code>HTML</code>由 Web 的发明者 Tim Berners-Lee 创立，这也是前端的起始</td>
</tr>
<tr>
<td align="left">1994 年</td>
<td align="left">世界上的第一款浏览器<code>NCSAMosaic</code>由 Netscape（网景）公司开发，同年<code>W3C</code>（世界万维网联盟）成立</td>
</tr>
<tr>
<td align="left">1995 年</td>
<td align="left"><code>JavaScript</code>由网景公司的 Brendan Eich 设计</td>
</tr>
<tr>
<td align="left">1996 年</td>
<td align="left">W3C 发布了<code>CSS1</code>标准，从此前端有了样式规范</td>
</tr>
<tr>
<td align="left">1997 年</td>
<td align="left"><code>ECMAScript1</code>由 ECMA 国际正式发布，从此 Javascript 有了自己的标准，同年 W3C 发布了<code>HTML4.0</code>标准，这是使用时间最长的一个版本</td>
</tr>
<tr>
<td align="left">1998 年</td>
<td align="left">W3C 发布了<code>XML（可扩展标记语言）</code>标准，同年<code>Ajax</code>（异步 Javascript 和 XML）技术开始得到应用</td>
</tr>
<tr>
<td align="left">2001 年</td>
<td align="left">Douglas Crockford 开始推广使用<code>JSON</code>数据格式，它比 XML 更加简洁清晰</td>
</tr>
<tr>
<td align="left"><code>web2.0 2004~至今</code></td>
<td align="left">交互网络，用户产生内容，通过网站与他人交互</td>
</tr>
<tr>
<td align="left">2006 年</td>
<td align="left">John Resig 发布了<code>JQuery</code>的第一个版本，这是迄今为止最成功的 JS 库，同年 W3C 正式发布<code>XMLHttpRequest</code>标准，为以后的 Ajax 爆发提供技术基础。</td>
</tr>
<tr>
<td align="left">2008 年</td>
<td align="left">Google 开源了高性能的 Javascript 引擎<code>V8</code></td>
</tr>
<tr>
<td align="left">2009 年</td>
<td align="left">Ryan Dahl 开发了基于 V8 引擎的<code>NodeJS</code>运行时环境，从此 javascript 可以运行在服务端；同年<code>ECMAScript5</code>发布，这是使用时间最长，各个浏览器兼容性最好，如今大部分程序也依然在使用的一代标准；同年 Miško Hevery 创造了<code>AngularJS</code>框架，基于 MVC 模式，并且实现了 SPA（单页面应用）</td>
</tr>
<tr>
<td align="left">2010 年</td>
<td align="left"><code>NPM</code>（NodeJS 包管理工具）发布了第一个版本，从此前端有了自己的包管理器</td>
</tr>
<tr>
<td align="left">2011 年</td>
<td align="left">Twitter 开源了其前端框架<code>Bootstrap</code></td>
</tr>
<tr>
<td align="left">2012 年</td>
<td align="left">微软发布了<code>Typescript</code>的第一个版本，让 Javascript 拥有了自己的类型</td>
</tr>
<tr>
<td align="left">2013 年</td>
<td align="left">Facebook 开源了其前端框架<code>React</code>，同年尤雨溪受到 Angular 启发开发了轻量级前端框架<code>Seed</code>，后更名为<code>Vue</code></td>
</tr>
<tr>
<td align="left">2014 年</td>
<td align="left">W3C 发布了<code>HTML5</code>标准</td>
</tr>
<tr>
<td align="left">2015 年</td>
<td align="left"><code>ECMAScript6</code>正式发布，后更名为<code>ECMAScript2015</code>，之截至目前 2022 年，每年都发布了对应的新版本</td>
</tr>
<tr>
<td align="left">2016 年</td>
<td align="left"><code>ECMAScript2016</code>正式发布</td>
</tr>
<tr>
<td align="left">2017 年</td>
<td align="left"><code>ECMAScript2017</code>正式发布</td>
</tr>
</tbody></table>
<!-- YCTODO -->
<h2 id="一些技术发展过程的梳理"><a href="#一些技术发展过程的梳理" class="headerlink" title="一些技术发展过程的梳理"></a>一些技术发展过程的梳理</h2><p>可以把前端发展的历程分为</p>
<h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>百度百科</li>
<li><a class="link"   href="http://www.javashuo.com/article/p-hvrlfhxo-gc.html" >前端的历史发展节点 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://zhuanlan.zhihu.com/p/196637639" >Web 开发的历史发展技术演变 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/qq_44273429/article/details/127462439" >Web 1.0、Web 2.0 和 Web 3.0 之间的比较 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>方法论</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/02/28/Algorithm/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>【API】MutationObserver</title>
    <url>/2023/01/11/APIMutationObserver/</url>
    <content><![CDATA[<h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" >MutationObserver <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2><blockquote>
<p><code>MutationObserver</code> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>
</blockquote>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>MutationObserver()</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。</span></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br></pre></td></tr></table></figure></div>
<p>this<br>new绑定 用于类的构造函数<br>显式绑定 call apply bind<br>隐式绑定 绑定到调用函数的对象<br>默认绑定</p>
<p>其他：<br>箭头函数 继承外层this</p>
]]></content>
      <categories>
        <category>API</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【实践】手写 call、apply、bind</title>
    <url>/2022/08/15/PracticeCallApply/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【实践】手写 Promise</title>
    <url>/2022/09/08/PracticePromise/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】Angular：性能优化清单</title>
    <url>/2022/09/16/ReprintAngularOptimization/</url>
    <content><![CDATA[<a class="link"   href="https://limeii.github.io/2020/06/angular-performance-checklists/" >【转载】Angular：性能优化清单 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>

<article class="post-container post-container--single" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-06-28 00:00:00 +0000" itemprop="datePublished" class="post-meta__date date">2020-06-28</time>
      • <span class="post-meta__tags tags">Angular</span>
    </div>
    <h1 class="post-title">Angular：性能优化清单</h1>
  </header>

  <section class="post">
    <p>性能优化主要是从两方面入手，一个是网络性能，另一个是页面渲染。在具体介绍性能优化方式之前，先来解释下为什么网络性能和页面渲染会影响性能。</p>

    <blockquote>
      <p>
        在这里讨论的网络带宽的性能问题都是基于 HTTP/1.X，在 HTTP/2 中很多性能问题都解决了。
      </p>
    </blockquote>

    <p>在 HTTP/1.X 连接有三种方式：短连接，长连接和 HTTP 流水线。</p>

    <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./angular-performance01.png"
                      alt="angular-performance" height="80%"
        width="80%"
                ></p>

    <p>短连接是 HTTP/1.0 的默认模型，它每发一个请求时都会创建见一个新的 TCP 连接，收到 response 的时候就立马关闭连接，每次创建一个 TCP
      连接都相当耗费资源，可想而知这种方式的性能很差，现在基本不用这种方式。</p>

    <p>在 HTTP/1.1 以后就有了长连接和流水线，长连接是指创建一个 TCP 连接后，可以保持连接完成多次连续的请求，减少了打开 TCP 连接的次数，在 HTTP/1.1
      以后的版本是默认的长连接的模式，长连接的缺点是，就算在空闲状态，它还是会消耗服务器资源。长连接是通过 <code
        class="language-plaintext highlighter-rouge">Keep-Alive</code>消息头来控制。</p>

    <p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到应答以后才会发出，由于受到网络延迟和带宽的限制，在下一个请求发出可能需要等很长时间。流水线是指在同一个 TCP
      长连接里连续发出请求，而不用等待前一个请求应答返回，理论上这种方式是最有效的，实现流水线是复杂的：传输中的资源大小，多少有效的 RTT
      会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显，在
      HTTP/2 已经有更好的方式替代流水线模式，流水线模式在浏览器里默认是不开启的。</p>

    <p>基于 HTTP/1.X 的连接限制，我们在开发中过程要尽量减少网络带宽的占用，比如尽可能的减小文件的大小和减少请求次数，可以从以下几方面考虑：</p>
    <ul>
      <li>Bundling</li>
      <li>Code Splitting</li>
      <li>Minify，Uglify</li>
      <li>Compression</li>
      <li>Tree-shaking</li>
      <li>Cache</li>
      <li>lazy loading 和 preloading</li>
      <li>如果是用了前端框架，部署的时候用 AoT 的编译方式</li>
      <li>Service Worker</li>
    </ul>

    <p>页面渲染，在正常情况下浏览器是60Hz的刷新率，每16.6ms会刷新一次页面，渲染页面的操作需要在这16.6ms内完成，否则就会导致页面失帧，提高页面渲染的性能，可以从以下几方面考虑：</p>
    <ul>
      <li>减少页面重排和重绘，尽量避免以下会导致页面重排和重绘的操作：
        <ul>
          <li>在 JS 代码中操作页面 DOM</li>
          <li>在页面 layout 稳定以后，增加和改变 CSS 样式</li>
          <li>改变：窗口大小，字体大小</li>
          <li>使用 table</li>
          <li>动画实现数度选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li>
          <li>读取 offsetwidth offsetheight</li>
          <li>CSS 伪类，比如 :hover 某个元素弹出一个消息框</li>
        </ul>
      </li>
      <li>JS 全阻塞，CSS 半阻塞（会阻塞 JS 执行和渲染树，但不阻塞 DOM 构建）
        <ul>
          <li>JS 阻塞构建 DOM CSSOM 树，从而会阻塞构建渲染树，而且同时还会阻塞其他静态资源（图片）的下载，所以要把<code
              class="language-plaintext highlighter-rouge">&lt;script&gt;</code>标签放到body最后，或者是在标签里添加<code
              class="language-plaintext highlighter-rouge">defer</code> 或者 <code
              class="language-plaintext highlighter-rouge">async</code> 属性。</li>
          <li>CSS 文件下载解析，不会阻塞 HTML 文件解析，不会阻塞 DOM 树的构建，但是会阻塞 CSSOM 树，从而会阻塞渲染树的构建，所以 CSS 文件的连接可以放在 head 里，不影响</li>
          <li>CSS 文件下载不会阻塞其他文件下载，但是会阻塞JS的文件执行</li>
        </ul>
      </li>
      <li>Web Worker</li>
      <li>服务器端渲染</li>
    </ul>

    <h2 id="网络性能">网络性能</h2>

    <p><strong>推荐用 Angular 自带的编译方式打包</strong></p>

    <p>Angular 内置了 webpack 打包方式，很多人在搭建 Angular(&lt; 6.0) 项目的时候，发现 Angular 内置的 webpack 并不能满足实际项目打包的一些需求，所以通过<code
        class="language-plaintext highlighter-rouge">ng eject</code>把内置的 webpack.config 文件暴露出来，然后根据自己项目需求重写整个
      webpack.config 配置，可以参考文章: 【<a class="link" 
         href="https://limeii.github.io/2018/09/angular-webpack/" >Angular：如何用Angular(&lt;6.0)和Webpack搭建项目 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <p>但是 Angular(&gt;= 6.0)，去掉了<code class="language-plaintext highlighter-rouge">ng eject</code>命令，鼓励大家用 Angular
      内置的打包方式开发 Angular 项目，因为<code class="language-plaintext highlighter-rouge">AoT</code> <code
        class="language-plaintext highlighter-rouge">Tree-Shaking</code> <code
        class="language-plaintext highlighter-rouge">ngc</code> <code
        class="language-plaintext highlighter-rouge">tsc</code> <code
        class="language-plaintext highlighter-rouge">minification</code> <code
        class="language-plaintext highlighter-rouge">Uglification</code> <code
        class="language-plaintext highlighter-rouge">Production mode</code>等等这些在 Angular 内置的打包方式中都是默认配置，不需要我们自己再去找第三方的
      loader 或者 plugin 来实现类似的功能；而且从性能上说内置的打包方式要比我们自己搭的要好。</p>

    <p>如何结合内置的打包方式和我们自己的 webpack 配置文件编译打包整个项目，可以参考文章：【<a class="link" 
         href="https://limeii.github.io/2019/08/angular-customize-webpack/" >Angular：如何在Angular(8.0)中配置Webpack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <p><strong>使用 AoT 编译</strong></p>

    <p>在打包过程中使用 AoT 编译，指的是把所有 HTML component NgModule CSS 都编译成浏览器可以识别的 es5 代码。从而用户访问 Angular 应用的时候，只需要下载相应的 budnle
      文件后直接渲染。不需要先下载<code
        class="language-plaintext highlighter-rouge">@angular/compiler</code>编译器编译模板文件，然后再渲染，大大提高了页面渲染性能。</p>

    <p>在模板文件中 Angular 有自己的 directive component pipe，如果不先编译成 es6 代码，就没办法做 Tree Shaking。AoT(ngc) 编译，可以把模板文件先打包成 es6
      (或者TypeScript)文件，这样就可以做 Tree Shaking，把一些没用的代码去掉，从而减少 bundle 文件的体积，也可以提高性能。</p>

    <p>关于深入理解 Angular 编译，可以参考这篇文章：【<a class="link" 
         href="https://limeii.github.io/2019/08/angular-compiler/" >Angular：深入理解Angular编译机制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <p><strong>Tree Shaking</strong></p>

    <p>如果项目中有一些代码(方法、文件)，在项目里完全没有被用到，这种代码称为 Dead Code。大量 Dead Code 如果编译打包进 bundle 文件，会导致 bundle 文件过大，页面渲染下载 bundle
      文件的时候会浪费带宽，也会影响性能。</p>

    <p>Tree Shaking 就是用来解决这种问题，它是指在编译打包过程中把 Dead Code 去掉，不把这些没用到的代码打包到最后的 bundle 文件里，从而可以减小 bundle
      文件的体积，提高应用性能。可以把整个应用想象成一棵树，function/component/service/lib 好比是树叶，而那些定义但又没有被调用的 function/component/service/lib
      好比是枯树叶，Tree Shaking 就是把那些枯树叶从树上摇下去。</p>

    <p>关于更多 Tree Shaking 的理解和应用可以参考这篇文章： <a class="link" 
         href="https://limeii.github.io/2019/08/angular-tree-shaking/" >Angular性能优化：Tree Shaking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

    <p><strong>lazy loading 和 preloading</strong></p>

    <p>如果把一个大项目所有文件都打包进一个 bundle 文件，用户打开浏览器访问这个网站的时候，首先要从服务器下载这个超大的 bundle 文件，加上还需要时间做一些解析，会导致网站响应过慢。在 Angular
      项目中可以通过配置 lazy loading 和 preloading 来提高性能。关于 lazy loading 和 preloading 在 Angular 项目中的理解和应用可以参考这篇文章：【<a class="link" 
         href="https://limeii.github.io/2018/09/angular-lazy-loading/" >Angular：lazy loading和preloading <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <p><strong>webpack Code Splitting</strong></p>

    <p>在项目中经常会有一些公用代码，被多个 module 或者 component 引用，如果在打包的时候直接把公用代码重复打包进不同的 bundle 文件，会造成代码冗余，也会影响应用性能。我们可以通过 webpack
      Code Splitting 做代码切割，把公用的代码单独提取出来放在 chunk 文件里，用户访问页面的时候只需要下载一次这个 chunk 文件就可以了。具体可以参考这篇文章：<a class="link" 
         href="https://limeii.github.io/2018/10/webpack-code-splitting/" >webpack(3)：代码切割 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>

    <p><strong>缓存</strong></p>

    <ul>
      <li>
        <p>用 RxJS 实现缓存效果
          Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Cold Observable，这导致每次调用 API，都会生成一个新的 Observable
          实例，有订阅之后才开始发送值，这也符合现在前端开发要求。但是实际开发过程中，有时候后端会有提供一些公用的常量 API，不同页面都需要用这些常量，按现在的调用 API 的方式，会导致常量 API
          在不同的页面重复多次被调用，这种方式显然性能不好。可以通过 ReplaySubject 实现缓存效果，第一次调用常量 API 之后把这些常量缓存起来，之后调用同样的 API 就可以直接在 ReplaySubject
          拿到值，不用每次都调用后端 API。具体实现可以参考文章：【<a class="link"   href="https://limeii.github.io/2019/08/rxjs-caching/" >RxJS：如何通过RxJS实现缓存 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】
        </p>
      </li>
      <li>
        <p>选择合适的浏览器缓存策略
          对于一些不经常改的静态资源，可以缓存在浏览器端，合理的缓存策略可以减少延迟，在重复利用缓存的资源文件同时，可以减少带宽和降低网络负荷，从而大大提高了性能。缓存机制可以参考文章：【<a class="link" 
             href="https://limeii.github.io/2018/11/web-cache/" >浏览器缓存机制：强缓存和协商缓存 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>
      </li>
      <li>
        <p>合理的利用浏览器数据存储
          对于一些常用的数据，可以存在浏览器里，这样可以减少延迟和带宽，从而可以提高性能，浏览器数据存储方式有：Cookies、SessionStorage、LocalStorage、IndexedDB。对于这些存储方式的用法和区别可以参考文章：【<a class="link" 
             href="https://limeii.github.io/2018/11/web-storage/" >浏览器数据存储方式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>
      </li>
    </ul>

    <p><strong>防抖</strong></p>

    <p>超高频触发网路请求，不仅效率低而且没办法保证请求结果的正确性，我们可以结合 RxJS 中的操作符<code
        class="language-plaintext highlighter-rouge">debounceTime</code> <code
        class="language-plaintext highlighter-rouge">map</code> <code
        class="language-plaintext highlighter-rouge">filter</code> <code
        class="language-plaintext highlighter-rouge">distinctUntilChanged</code> 和<code
        class="language-plaintext highlighter-rouge">switchMap</code>实现防抖。具体可以参考文章：【<a class="link" 
         href="https://limeii.github.io/2019/08/rxjs-searchable-input/" >RxJS：如何用RxJS实现高效的HTTP请求 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <p><strong>Service Worker</strong></p>

    <p>Service Worker
      可以理解为客户端和服务器端中间的一个代理服务器，它是独立于主线程的一个线程，在主线程运行的同时，它在后台运行，两者之间互不干扰。它可以拦截所有客户端的请求，也可以向服务器端发送请求，可以离线缓存资源，也可以后台同步。Service
      Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能，毫无疑问，Service Worker 也可以大大的提高页面性能。关于 Service Worker
      的理解和应用，可以参考文章：【<a class="link"   href="https://jakearchibald.com/2014/offline-cookbook/" >The offline cookbook <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <h2 id="页面渲染">页面渲染</h2>

    <p><strong>浏览器工作原理</strong></p>

    <p>在正常情况下浏览器是60Hz的刷新率，每16.6ms会刷新一次页面，渲染页面的操作需要在这16.6ms内完成，否则就会导致页面失帧。关于浏览器是如何解析运行 HTML CSS
      JS，浏览器的工作原理，可以参考参考文章：【<a class="link"   href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" >How Browsers
        Work: Behind the scenes of modern web browsers <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <p><strong>Web Worker</strong></p>

    <p>JS 是单线程的，并且是全阻塞的，全阻塞的意思是指：在浏览器中，只要 JS 引擎在执行 JS 代码，那么就会阻塞 HTML CSS 的解析执行，从而会阻塞页面渲染和交互，如果 JS
      代码执行时间比较长，那么会导致页面卡顿，影响用户体验。</p>

    <p>在 H5 中引入了 Web Worker，它的作用就是为 JS 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给 Worker 线程。在主线程运行的同时，Worker
      线程在后台运行，两者互不干扰，它的意义在于可以将一些耗时的数据处理操作（复杂耗时的计算，大文本分析上传，图像处理，canvas图像绘制等等）从主线程中剥离，让主线程专注于页面的渲染和交互，从而提高页面性能。关于 Web
      Worker 的具体用法可以参考文章：【<a class="link" 
         href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" >使用 Web Workers <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】
    </p>

    <p><strong>使用 ChangeDetectionStrategy.OnPush 策略</strong></p>

    <p>Angular 默认的变化检测机制是：异步事件 callback 结束后，NgZone 会触发整个组件树至上而下做变化检测，也就是说页面一个小小的 Click 事件就会触发所有组件的变化检测。虽然 Angular
      变化检测本身性能已经很好了，在毫秒内可以做成百上千次变化检测。但是随着项目越来越大，其实很多不必要的变化检测还是会在一定程度上影响性能。在 Angular 中可以通过 OnPush
      来跳过一些不必要的变化检测，从而优化整个应用的性能。更多关于 OnPush 策略的理解和应用可以参考这篇文章：【 <a class="link" 
         href="https://limeii.github.io/2019/06/angular-changeDetectionStrategy-OnPush/" >Angular Change
        Detection：变化检测策略 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

    <p><strong>服务器端渲染（Server Rendering）</strong></p>

    <p>一般来说，像 Angular 框架搭出来的 SPA 应用，都是客户端渲染（client-side rendering）。当路由到这个页面的时候，从服务器端下载相应的 bundle/chunk
      文件，在这个文件里一般只是只包含了 DOM 结构代码和 JS 代码，不是 HTML 文件。浏览器拿到这些代码，需要构建 DOM 树 / CSSOM 树 / 渲染树 / 解析执行 JS
      代码，最后才是页面渲染后跟用户进行交互，如果这其中某一个步骤耗时较长，就会导致用户只能看到空白页面一直在加载，显然性能和用户体验都不好。服务器端渲染就可以用来解决这个问题，当路由到某一个页面的时候，request
      发到服务器端，在服务器端会构建好这个页面（HTML文件），再把这个 HTML 文件直接发回给客户端，这样用户在一开始就能立马看到带有内容的页面，不用等浏览器构建页面、执行 JS 代码，大大提高了性能，有更好的用户体验。
    </p>

    <p><strong>域名拆分</strong></p>

    <p>我们知道，在 HTTP1.1 中，浏览器对同一域名的 TCP 连接数量有限制，一般是 6 到 8
      个，超过这个数量之后，就会阻塞后续的请求。有些网站为了提高性能，并行的去服务端请求更多的资源，会把资源分布到不同的域名商去，让浏览器利用更多的 TCP socket 连接。</p>

    <p>在 Angular 中，可以用 Angular Universal 来实现服务器端渲染，关于服务器端渲染和 Angular Universal 的文章可以参考：【<a class="link" 
         href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web" >Rendering on the Web <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】【<a class="link" 
         href="https://blog.angular-university.io/angular-universal/" >Angular Universal: a Complete Practical
        Guide <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>】</p>

  </section>
</article>]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】TypeScript装饰器完全指南</title>
    <url>/2023/02/16/ReprintTypscriptDecorator/</url>
    <content><![CDATA[<a class="link"   href="https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/" >【转载】TypeScript装饰器完全指南 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>

<section>
  <p>装饰器让TypeScript的世界更好。
    我们使用的许多库都基于这一强大特性构建,
    例如<a class="link"   href="https://angular.io/"  target="_blank" rel="nofollow noopener noreferrer">Angular <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>和<a class="link" 
       href="https://nestjs.com/"  target="_blank" rel="nofollow noopener noreferrer">Nestjs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。
    在这篇博客中我将介绍装饰器和它的许多细节。
    我希望在读完这篇文章后，你可以理解何时和如何使用这一强的的特性。</p>
  <h1>概览</h1>
  <p>装饰器本质上是一种特殊的函数被应用在于：</p>
  <ol>
    <li>类</li>
    <li>类属性</li>
    <li>类方法</li>
    <li>类访问器</li>
    <li>类方法的参数</li>
  </ol>
  <p>所以应用装饰器其实很像是组合一系列函数，类似于高阶函数和类。
    通过装饰器我们可以轻松实现<a class="link"   href="https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"  target="_blank"
      rel="nofollow noopener noreferrer">代理模式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>来使代码更简洁以及实现其它一些更有趣的能力。</p>
  <p>装饰器的语法十分简单，只需要在想使用的装饰器前加上<code class="language-text">@</code>符号，装饰器就会被应用到目标上：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">simpleDecorator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'---hi I am a decorator---'</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">simpleDecorator</span></span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre>
  </div>
  <p>一共有5种装饰器可被我们使用：</p>
  <ol>
    <li>类装饰器</li>
    <li>属性装饰器</li>
    <li>方法装饰器</li>
    <li>访问器装饰器</li>
    <li>参数装饰器</li>
  </ol>
  <p>让我们来快速认识一下这五种装饰器：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token comment">// 类装饰器</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">classDecorator</span></span>
<span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">&#123;</span>

  <span class="token comment">// 属性装饰器</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">propertyDecorator</span></span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 方法装饰器</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">methodDecorator</span></span>
  <span class="token function">fly</span><span class="token punctuation">(</span>
    <span class="token comment">// 参数装饰器</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">parameterDecorator</span></span>
      meters<span class="token operator">:</span> <span class="token builtin">number</span>
  <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  
  <span class="token comment">// 访问器装饰器</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">accessorDecorator</span></span>
  <span class="token keyword">get</span> <span class="token function">egg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
  </div>
  <h1>执行</h1>
  <h2>时机</h2>
  <p>装饰器只在解释执行时应用一次，例如：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'apply decorator'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token constant">C</span>
<span class="token punctuation">&#125;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token comment">// output: apply decorator</span></code></pre>
  </div>
  <p>这里的代码会在终端中打印<code class="language-text">apply decorator</code>，即便我们其实并没有使用类A。</p>
  <h2>执行顺序</h2>
  <p>不同类型的装饰器的执行顺序是明确定义的：</p>
  <ol>
    <li>实例成员：</li>
  </ol>
  <p>参数装饰器 -&gt; 方法 / 访问器 / 属性 装饰器
    2. 静态成员:<br>
    参数装饰器 -&gt; 方法 / 访问器 / 属性 装饰器
    3. 构造器: 参数装饰器
    4. 类装饰器</p>
  <p>例如，考虑以下代码：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"evaluate: "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"call: "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Class Decorator"</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Static Property"</span><span class="token punctuation">)</span>
  <span class="token keyword">static</span> prop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Static Method"</span><span class="token punctuation">)</span>
  <span class="token keyword">static</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Static Method Parameter"</span><span class="token punctuation">)</span> foo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Constructor Parameter"</span><span class="token punctuation">)</span> foo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Instance Method"</span><span class="token punctuation">)</span>
  <span class="token function">method</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Instance Method Parameter"</span><span class="token punctuation">)</span> foo<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Instance Property"</span><span class="token punctuation">)</span>
  prop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
  </div>
  <p>它将会打印出以下信息：</p>
  <div class="gatsby-highlight" data-language="bash">
    <pre class="language-bash"><code class="language-bash">evaluate:  Instance Method
evaluate:  Instance Method Parameter
call:  Instance Method Parameter
call:  Instance Method
evaluate:  Instance Property
call:  Instance Property
evaluate:  Static Property
call:  Static Property
evaluate:  Static Method
evaluate:  Static Method Parameter
call:  Static Method Parameter
call:  Static Method
evaluate:  Class Decorator
evaluate:  Constructor Parameter
call:  Constructor Parameter
call:  Class Decorator</code></pre>
  </div>
  <p>你也许会注意到执行实例属性<code class="language-text">prop</code>晚于实例方法<code class="language-text">method</code>
    然而执行静态属性<code class="language-text">static prop</code>早于静态方法<code class="language-text">static method</code>。
    这是因为对于属性/方法/访问器装饰器而言，执行顺序取决于声明它们的顺序。</p>
  <p>然而，同一方法中不同参数的装饰器的执行顺序是相反的，
    最后一个参数的装饰器会最先被执行：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"evaluate: "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"call: "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token function">method</span><span class="token punctuation">(</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Parameter Foo"</span><span class="token punctuation">)</span> foo<span class="token punctuation">,</span>
    <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Parameter Bar"</span><span class="token punctuation">)</span> bar
  <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
  </div>
  <p>这里的代码打印出的结果为：</p>
  <div class="gatsby-highlight" data-language="bash">
    <pre class="language-bash"><code class="language-bash">evaluate:  Parameter Foo
evaluate:  Parameter Bar
call:  Parameter Bar
call:  Parameter Foo</code></pre>
  </div>
  <h2>多个装饰器的组合</h2>
  <p>你可以对同一目标应用多个装饰器。它们的组合顺序为：</p>
  <ol>
    <li>求值外层装饰器</li>
    <li>求值内层装饰器</li>
    <li>调用内层装饰器</li>
    <li>调用外层装饰器</li>
  </ol>
  <p>例如:</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"evaluate: "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"call: "</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Outer Method"</span><span class="token punctuation">)</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">f</span></span><span class="token punctuation">(</span><span class="token string">"Inner Method"</span><span class="token punctuation">)</span>
  <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
  </div>
  <p>这里的代码打印出的结果为：</p>
  <div class="gatsby-highlight" data-language="bash">
    <pre class="language-bash"><code class="language-bash">evaluate: Outer Method
evaluate: Inner Method
call: Inner Method
call: Outer Method</code></pre>
  </div>
  <h1>定义</h1>
  <h2>类装饰器</h2>
  <p>类型声明：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ClassDecorator</span> <span class="token operator">=</span> <span class="token operator">&lt;</span>TFunction <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Function</span></span><span class="token operator">&gt;</span>
  <span class="token punctuation">(</span>target<span class="token operator">:</span> TFunction<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> TFunction <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre>
  </div>
  <ul>
    <li>@参数:
      <ol>
        <li><code class="language-text">target</code>: 类的构造器。</li>
      </ol>
    </li>
    <li>@返回:<br>
      如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。</li>
  </ul>
  <p>因此，类装饰器适合用于继承一个现有类并添加一些属性和方法。</p>
  <p>例如我们可以添加一个<code class="language-text">toString</code>方法给所有的类来覆盖它原有的<code class="language-text">toString</code>方法。
  </p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Consturctor</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">toString</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Consturctor<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>BaseClass<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">extends</span></span> BaseClass <span class="token punctuation">&#123;</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">toString</span></span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span> foo <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> num <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; &#123;"foo":"foo","num":24&#125;</span></code></pre>
  </div>
  <p>遗憾的是装饰器并没有类型保护，这意味着：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">Blah</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Blah</span></span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// Property 'foo' does not exist on type 'Foo'</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// Property 'foo' does not exist on type 'Foo'</span></code></pre>
  </div>
  <p>这是<a class="link"   href="https://github.com/microsoft/TypeScript/issues/4881"  target="_blank"
      rel="nofollow noopener noreferrer">一个TypeScript的已知的缺陷 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。
    目前我们能做的只有额外提供一个类用于提供类型信息：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">Blah</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">&#123;</span>foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>
  foo<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Blah</span></span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">&#123;</span>
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foo<span class="token punctuation">;</span></code></pre>
  </div>
  <h2>属性装饰器</h2>
  <p>类型声明：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">PropertyDecorator</span> <span class="token operator">=</span>
  <span class="token punctuation">(</span>target<span class="token operator">:</span> Object<span class="token punctuation">,</span> propertyKey<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre>
  </div>
  <ul>
    <li>@参数:
      <ol>
        <li><code class="language-text">target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>
        <li><code class="language-text">propertyKey</code>: 属性的名称。</li>
      </ol>
    </li>
    <li>@返回:<br>
      返回的结果将被忽略。</li>
  </ul>
  <p>除了用于收集信息外，属性装饰器也可以用来给类添加额外的方法和属性。
    例如我们可以写一个装饰器来给某些属性添加监听器。</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">capitalizeFirstLetter</span><span class="token punctuation">(</span>str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">observable</span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// prop -&gt; onPropChange</span>
  <span class="token keyword">const</span> targetKey <span class="token operator">=</span> <span class="token string">"on"</span> <span class="token operator">+</span> <span class="token function">capitalizeFirstLetter</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"Change"</span><span class="token punctuation">;</span>

  target<span class="token punctuation">[</span>targetKey<span class="token punctuation">]</span> <span class="token operator">=</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span>prev<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> next<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
        <span class="token function">set</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token function">fn</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
          prev <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">observable</span></span>
  foo <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">observable</span></span>
  bar <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

c<span class="token punctuation">.</span><span class="token function">onFooChange</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">prev: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>prev<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, next: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>next<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
c<span class="token punctuation">.</span><span class="token function">onBarChange</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">prev: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>prev<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, next: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>next<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>

c<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; prev: -1, next: 100</span>
c<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; prev: 100, next: -3.14</span>
c<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"baz"</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; prev: bar, next: baz</span>
c<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"sing"</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; prev: baz, next: sing</span></code></pre>
  </div>
  <h2>方法装饰器</h2>
  <p>类型声明：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">MethodDecorator</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  target<span class="token operator">:</span> Object<span class="token punctuation">,</span>
  propertyKey<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">,</span>
  descriptor<span class="token operator">:</span> TypedPropertyDescriptor<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> TypedPropertyDescriptor<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre>
  </div>
  <ul>
    <li>@参数：
      <ol>
        <li><code class="language-text">target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>
        <li><code class="language-text">propertyKey</code>: 属性的名称。</li>
        <li><code class="language-text">descriptor</code>: 属性的<a class="link" 
             href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" 
            target="_blank" rel="nofollow noopener noreferrer">描述器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li>
      </ol>
    </li>
    <li>@返回：
      如果返回了值，它会被用于替代属性的描述器。</li>
  </ul>
  <p>方法装饰器不同于属性装饰器的地方在于<code class="language-text">descriptor</code>参数。
    通过这个参数我们可以修改方法原本的实现，添加一些共用逻辑。
    例如我们可以给一些方法添加打印输入与输出的能力：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">logger</span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> propertyKey<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> descriptor<span class="token operator">:</span> PropertyDescriptor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>value<span class="token punctuation">;</span>

  descriptor<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'params: '</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'result: '</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">logger</span></span>
  <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// -&gt; params: 1, 2</span>
<span class="token comment">// -&gt; result: 3</span></code></pre>
  </div>
  <h2>访问器装饰器</h2>
  <p>访问器装饰器总体上讲和方法装饰器很接近，唯一的区别在于描述器中有的key不同：</p>
  <p>方法装饰器的描述器的key为：</p>
  <ul>
    <li><code class="language-text">value</code></li>
    <li><code class="language-text">writable</code></li>
    <li><code class="language-text">enumerable</code></li>
    <li><code class="language-text">configurable</code></li>
  </ul>
  <p>访问器装饰器的描述器的key为：</p>
  <ul>
    <li><code class="language-text">get</code></li>
    <li><code class="language-text">set</code></li>
    <li><code class="language-text">enumerable</code></li>
    <li><code class="language-text">configurable</code></li>
  </ul>
  <p>例如，我们可以将某个属性设为不可变值：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">immutable</span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> propertyKey<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> descriptor<span class="token operator">:</span> PropertyDescriptor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>set<span class="token punctuation">;</span>

  descriptor<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token operator">...</span>value <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">private</span> _point <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span>

  <span class="token decorator"><span class="token at operator">@</span><span class="token function">immutable</span></span>
  <span class="token keyword">set</span> <span class="token function">point</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_point <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">get</span> <span class="token function">point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_point<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> point <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span>
c<span class="token punctuation">.</span>point <span class="token operator">=</span> point<span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>point <span class="token operator">===</span> point<span class="token punctuation">)</span>
<span class="token comment">// -&gt; false</span></code></pre>
  </div>
  <h2>参数装饰器</h2>
  <p>类型声明：</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">ParameterDecorator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
  target<span class="token operator">:</span> Object<span class="token punctuation">,</span>
  propertyKey<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">,</span>
  parameterIndex<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span></code></pre>
  </div>
  <ul>
    <li>@参数：
      <ol>
        <li><code class="language-text">target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>
        <li><code class="language-text">propertyKey</code>: 属性的名称(注意是方法的名称，而不是参数的名称)。</li>
        <li><code class="language-text">parameterIndex</code>: 参数在方法中所处的位置的下标。</li>
      </ol>
    </li>
    <li>@返回：<br>
      返回的值将会被忽略。</li>
  </ul>
  <p>单独的参数装饰器能做的事情很有限，它一般都被用于记录可被其它装饰器使用的信息。</p>
  <h1>结合</h1>
  <p>对于一些复杂场景，
    我们可能需要结合使用不同的装饰器。
    例如如果我们不仅想给我们的接口添加静态检查，还想加上运行时检查的能力。</p>
  <p>我们可以用3个步骤来实现这个功能：</p>
  <ol>
    <li>标记需要检查的参数 (因为参数装饰器先于方法装饰器执行)。</li>
    <li>改变方法的<code class="language-text">descriptor</code>的<code
        class="language-text">value</code>的值，先运行参数检查器，如果失败就抛出异常。</li>
    <li>运行原有的接口实现。</li>
  </ol>
  <p>以下是代码:</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Validator</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

<span class="token comment">// save the marks</span>
<span class="token keyword">const</span> validateMap<span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Validator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 1. 标记需要检查的参数</span>
<span class="token keyword">function</span> <span class="token function">typedDecoratorFactory</span><span class="token punctuation">(</span>validator<span class="token operator">:</span> Validator<span class="token punctuation">)</span><span class="token operator">:</span> ParameterDecorator <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> key<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> target <span class="token operator">=</span> validateMap<span class="token punctuation">[</span>key <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">??</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    target<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> validator<span class="token punctuation">;</span>
    validateMap<span class="token punctuation">[</span>key <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">validate</span><span class="token punctuation">(</span>_<span class="token operator">:</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> descriptor<span class="token operator">:</span> PropertyDescriptor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> originalFn <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
  descriptor<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 2. 运行检查器</span>
    <span class="token keyword">const</span> validatorList <span class="token operator">=</span> validateMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>validatorList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      args<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">const</span> validator <span class="token operator">=</span> validatorList<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>validator<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">validator</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>
            <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Failed for parameter: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>arg<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> of the index: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>index<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 3. 运行原有的方法</span>
    <span class="token keyword">return</span> <span class="token function">originalFn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> isInt <span class="token operator">=</span> <span class="token function">typedDecoratorFactory</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> isString <span class="token operator">=</span> <span class="token function">typedDecoratorFactory</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">validate</span></span>
  <span class="token function">sayRepeat</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">isString</span></span> word<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token decorator"><span class="token at operator">@</span><span class="token function">isInt</span></span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">sayRepeat</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pass</span>
c<span class="token punctuation">.</span><span class="token function">sayRepeat</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'lol'</span> <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throw an error</span></code></pre>
  </div>
  <p>正如例子中展示的，
    对我们来说同时理解不同种类装饰器的执行顺序和职责都很重要。</p>
  <h1>元数据</h1>
  <p>严格地说，元数据和装饰器是EcmaScript中两个独立的部分。
    然而，如果你想实现像是<a class="link" 
       href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" 
      target="_blank" rel="nofollow noopener noreferrer">反射 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>这样的能力，你总是同时需要它们。</p>
  <p>如果我们回顾上一个例子，如果我们不想写各种不同的检查器呢？
    或者说，能否只写一个检查器能够通过我们编写的TS类型声明来自动运行类型检查？</p>
  <p>有了<a class="link"   href="https://github.com/rbuckton/reflect-metadata"  target="_blank"
      rel="nofollow noopener noreferrer">reflect-metadata <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的帮助，
    我们可以获取编译期的类型。</p>
  <div class="gatsby-highlight" data-language="typescript">
    <pre
      class="language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token string">'reflect-metadata'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">validate</span><span class="token punctuation">(</span>
  target<span class="token operator">:</span> Object<span class="token punctuation">,</span>
  key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  descriptor<span class="token operator">:</span> PropertyDescriptor
<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> originalFn <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>value<span class="token punctuation">;</span>

  <span class="token comment">// 获取参数的编译期类型</span>
  <span class="token keyword">const</span> designParamTypes <span class="token operator">=</span> Reflect
    <span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token string">'design:paramtypes'</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>

  descriptor<span class="token punctuation">.</span><span class="token function-variable function">value</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    args<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">&#123;</span>

      <span class="token keyword">const</span> paramType <span class="token operator">=</span> designParamTypes<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token keyword">const</span> result <span class="token operator">=</span> arg<span class="token punctuation">.</span>constructor <span class="token operator">===</span> paramType
        <span class="token operator">||</span> arg <span class="token keyword">instanceof</span> <span class="token class-name">paramType</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Failed for validating parameter: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>arg<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> of the index: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>index<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">originalFn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">&#123;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">validate</span></span>
  <span class="token function">sayRepeat</span><span class="token punctuation">(</span>word<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">C</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">sayRepeat</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pass</span>
c<span class="token punctuation">.</span><span class="token function">sayRepeat</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'lol'</span> <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// throw an error</span></code></pre>
  </div>
  <p>目前为止一共有三种编译期类型可以拿到：</p>
  <ul>
    <li><code class="language-text">design:type</code>: 属性的类型。</li>
    <li><code class="language-text">desin:paramtypes</code>: 方法的参数的类型。</li>
    <li><code class="language-text">design:returntype</code>: 方法的返回值的类型。</li>
  </ul>
  <p>这三种方式拿到的结果都是构造函数（例如<code class="language-text">String</code>和<code class="language-text">Number</code>）。规则是：</p>
  <ul>
    <li>number -&gt; <code class="language-text">Number</code></li>
    <li>string -&gt; <code class="language-text">String</code></li>
    <li>boolean -&gt; <code class="language-text">Boolean</code></li>
    <li>void/null/never -&gt; <code class="language-text">undefined</code></li>
    <li>Array/Tuple -&gt; <code class="language-text">Array</code></li>
    <li>Class -&gt; 类的构造函数</li>
    <li>Enum -&gt; 如果是纯数字枚举则为<code class="language-text">Number</code>, 否则是 <code class="language-text">Object</code>
    </li>
    <li>Function -&gt; <code class="language-text">Function</code></li>
    <li>其余都是<code class="language-text">Object</code></li>
  </ul>
  <h1>何时使用？</h1>
  <p>现在我们可以对于何时使用装饰器得出结论，
    在阅读上面的代码中你可能也有所感觉。</p>
  <p>我将例举一些常用的使用场景：</p>
  <ul>
    <li>Before/After钩子。</li>
    <li>监听属性改变或者方法调用。</li>
    <li>对方法的参数做转换。</li>
    <li>添加额外的方法和属性。</li>
    <li>运行时类型检查。</li>
    <li>自动编解码。</li>
    <li>依赖注入。</li>
  </ul>
  <p>我希望读完这篇文章后，你可以找到装饰器的更多使用场景，并且用它来简化你的代码。</p>
</section>]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
</search>
