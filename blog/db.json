{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","path":"assets/odometer-theme-minimal.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","path":"fontawesome/all.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","path":"fontawesome/brands.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","path":"fontawesome/duotone.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","path":"fontawesome/fontawesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","path":"fontawesome/light.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","path":"fontawesome/regular.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","path":"fontawesome/solid.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","path":"fontawesome/svg-with-js.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","path":"fontawesome/thin.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","path":"fontawesome/v4-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","path":"fontawesome/v4-shims.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","path":"fontawesome/v5-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","path":"images/loading.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","path":"images/redefine-avatar.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","path":"images/redefine-logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","path":"images/redefine-logo.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","path":"webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","path":"webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","path":"webfonts/fa-duotone-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","path":"webfonts/fa-duotone-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","path":"webfonts/fa-light-300.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","path":"webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","path":"webfonts/fa-light-300.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","path":"webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","path":"webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","path":"webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","path":"webfonts/fa-thin-100.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","path":"webfonts/fa-thin-100.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","path":"webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","path":"webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","path":"js/libs/anime.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","path":"js/layouts/lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","path":"js/libs/mermaid.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","path":"js/libs/mermaid.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","path":"js/libs/pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","path":"js/layouts/toc.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","path":"css/layout/archive-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","path":"css/layout/article-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","path":"css/layout/category-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","path":"css/layout/category-list.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","path":"css/common/animated.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","path":"css/common/basic.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","path":"css/layout/home-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","path":"css/layout/tag-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","path":"css/layout/page.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","path":"js/plugins/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","path":"css/common/markdown.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","path":"css/common/redefine-theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","path":"css/common/variables.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","path":"js/plugins/tabs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","path":"js/tools/runtime.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","path":"css/common/codeblock/code-block.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","path":"css/common/codeblock/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","path":"css/common/codeblock/code-theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","path":"assets/hbe.style.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","path":"fontawesome/sharp-solid.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/fonts.css","path":"fonts/fonts.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-700.woff","path":"fonts/noto-sans-sc-v26-chinese-simplified-700.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-regular.woff","path":"fonts/noto-sans-sc-v26-chinese-simplified-regular.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-regular.woff2","path":"fonts/noto-sans-sc-v26-chinese-simplified-regular.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-700.woff2","path":"fonts/noto-sans-sc-v26-chinese-simplified-700.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/ubuntu-mono-v15-latin-regular.woff","path":"fonts/ubuntu-mono-v15-latin-regular.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/ubuntu-mono-v15-latin-regular.woff2","path":"fonts/ubuntu-mono-v15-latin-regular.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","path":"images/redefine-favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","path":"images/wallhaven-wqery6-light.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","path":"images/wallhaven-wqery6-dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","path":"webfonts/fa-sharp-solid-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","path":"webfonts/fa-sharp-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","path":"css/layout/home-sidebar.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/build/styles.css","path":"assets/build/styles.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","path":"fonts/Chillax/Chillax-Variable.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","path":"fonts/Chillax/Chillax-Variable.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","path":"fonts/Chillax/Chillax-Variable.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","path":"fonts/Chillax/Chillax-Variable.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","path":"fonts/Chillax/chillax.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.eot","path":"fonts/Satoshi/Satoshi-Variable.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.ttf","path":"fonts/Satoshi/Satoshi-Variable.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.woff","path":"fonts/Satoshi/Satoshi-Variable.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.woff2","path":"fonts/Satoshi/Satoshi-Variable.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.eot","path":"fonts/Satoshi/Satoshi-VariableItalic.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.ttf","path":"fonts/Satoshi/Satoshi-VariableItalic.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.woff","path":"fonts/Satoshi/Satoshi-VariableItalic.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.woff2","path":"fonts/Satoshi/Satoshi-VariableItalic.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/satoshi.css","path":"fonts/Satoshi/satoshi.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","path":"js/layouts/categoryList.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","path":"js/layouts/navbarShrink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","path":"js/libs/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","path":"js/libs/Swup.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","path":"js/libs/Swup.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","path":"js/libs/SwupPreloadPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","path":"js/libs/APlayer.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","path":"js/libs/SwupPreloadPlugin.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","path":"js/libs/SwupProgressPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","path":"js/libs/SwupScriptsPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","path":"js/libs/SwupScrollPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","path":"js/libs/SwupScrollPlugin.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","path":"js/libs/SwupSlideTheme.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","path":"js/libs/Typed.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","path":"js/libs/minimasonry.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","path":"js/libs/odometer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","path":"js/libs/waline.mjs","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","path":"js/libs/waline.mjs.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","path":"js/plugins/masonry.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","path":"js/plugins/hbe.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","path":"js/plugins/typed.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","path":"js/tools/codeBlock.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","path":"js/tools/imageViewer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","path":"js/tools/localSearch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","path":"js/tools/lightDarkSwitch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","path":"js/tools/tocToggle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","path":"js/tools/scrollTopBottom.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1676625683197},{"_id":"source/_posts/APIMutationObserver.md","hash":"e2d05c35dd0c08f4835d61ae6bb7499f4b488975","modified":1678338025881},{"_id":"source/_posts/MethodologyFrontendEngineering.md","hash":"4bc8535918719361e6c66037735ddc1dc38db917","modified":1678850536553},{"_id":"source/_posts/MethodologyFrontendHistory.md","hash":"deeaf750e947fdb3be89b9e51cffcf012b9fa124","modified":1677763405797},{"_id":"source/_posts/MethodologyJSExcutionProcess.md","hash":"9dfd42eaedb97bb3095831d8ed109f85b0e5f086","modified":1677763406479},{"_id":"source/_posts/MethodologyRefactoring.md","hash":"0e4aca0271a1e9e7012348be3140bfe1a0d8ded5","modified":1677763407144},{"_id":"source/_posts/PracticeCallApply.md","hash":"a23175708f896df0253ecb39f8c3e73463a63422","modified":1678848175947},{"_id":"source/_posts/PracticePromise.md","hash":"29da1429b55de4a84d91413dcbd3c2035c73d07b","modified":1678848169841},{"_id":"source/_posts/MethodologyStateManagement.md","hash":"44751b7744875facee5e3fea66df19b3103aeb09","modified":1677762519713},{"_id":"source/about/index.md","hash":"ea162a253b966bc581b804046c49d3da911d9ef3","modified":1678097101820},{"_id":"source/_posts/ReprintAngularOptimization.md","hash":"da39cc90fbfce24f5e6dc1f122f704b91383ee6a","modified":1677760768827},{"_id":"source/_posts/MethodologyFrontendJSModularity .md","hash":"c66a7b3697a5c8a8712980a273d1040e18d3e039","modified":1700664123268},{"_id":"source/_posts/ReprintBrowserRender.md","hash":"20359a51de3dd5bc96c4d135131632d1ebebbb82","modified":1677763414253},{"_id":"source/_posts/ReprintJSEventLoop.md","hash":"5e5c2bfdb162a063488936fac76a62ca0dd97972","modified":1677760715235},{"_id":"source/_posts/ReprintTypscriptDecorator.md","hash":"c666991c1559ba695411d34e2e3e3a3ec5600d24","modified":1677760883274},{"_id":"source/_posts/ReprintVueCompositionAPI.md","hash":"b37ceff1021e9ad402335c07d98cb49a2c7153f9","modified":1677771724408},{"_id":"source/_posts/someInterestingQuestions04.md","hash":"2aef9a57c02e4b87fe2d46bfdc0723e2bbed8d83","modified":1700664157672},{"_id":"source/_posts/someInterestingQuestions05.md","hash":"a0b7008c392fcc405f695df4ad6305147ccb8ff8","modified":1677763409867},{"_id":"source/_posts/someInterestingQuestions01.md","hash":"da66473de890bdaffa5a5d7717d3ccad26b2a039","modified":1700664154176},{"_id":"source/_posts/vueSourceCodeStudy01.md","hash":"f67b665dc8033a3a05b0797f2a30c8bdcda3deb5","modified":1677763410501},{"_id":"source/_posts/someInterestingQuestions02.md","hash":"f3e862db0c57302bb0af94276aa4d152b434ae89","modified":1700664154686},{"_id":"source/_posts/someInterestingQuestions03.md","hash":"f8654ef6b8e8f02637452bd065589abde4475387","modified":1700664155232},{"_id":"source/_posts/vueSourceCodeStudy02.md","hash":"6645898326da553aff8acd703e4df92a5458d07a","modified":1677763411893},{"_id":"source/categories/index.md","hash":"5078291948cf897258007470951ef34cd129af80","modified":1675192987768},{"_id":"source/_posts/vueSourceCodeStudy03.md","hash":"438102bbf4356a7de34182d991e02696fbc88109","modified":1677763413410},{"_id":"source/_posts/someInterestingQuestions06.md","hash":"f149f5213248225800bc0dcebb9347ed39f8eaff","modified":1700664160229},{"_id":"source/cv/index.js","hash":"7500b7fc8cf2b363861c1680a2fa9504ebd77dd4","modified":1677759042202},{"_id":"source/_posts/.obsidian/app.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1677763529745},{"_id":"source/_posts/.obsidian/appearance.json","hash":"3a0edcaf29498e13439d9586ad392231b57d5552","modified":1677763529750},{"_id":"source/tags/index.md","hash":"5446c7484fbe4610611ac36065df0d6d6f6d12fe","modified":1675189707535},{"_id":"source/cv/index.html","hash":"809e99e2a8561c8241490eb262399117320d2763","modified":1677661811178},{"_id":"source/_posts/MethodologyFrontendEngineering/s1.png","hash":"f614910da7c56417905e7aa5abb54c6f2255500e","modified":1677758419124},{"_id":"source/_posts/.obsidian/hotkeys.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1677758419112},{"_id":"source/_posts/MethodologyFrontendEngineering/s2.png","hash":"41284a302db60fe0f2865e003d731b34e5c3f7c9","modified":1677758419125},{"_id":"source/_posts/.obsidian/core-plugins.json","hash":"eb138d03157a06efdb791f441be97c256aca472c","modified":1700664122390},{"_id":"source/_posts/.obsidian/core-plugins-migration.json","hash":"815fc344ed6c42e564bb0f829d610c2a9abba8aa","modified":1700664122398},{"_id":"source/_posts/PracticePromise/s1.png","hash":"c9aa0692e25558749268b2c0a5aa1e5400a48377","modified":1677758419143},{"_id":"source/_posts/MethodologyFrontendEngineering/s3.png","hash":"b9d84d6ae13d3071402cad6a0e383ff57d5795b6","modified":1677758419127},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop02.png","hash":"93ff24fbfd93e5b99d529cc00f2149c790644c39","modified":1677758419154},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop01.png","hash":"7a281cd1d656277c58255d68c46db2d8dbe9e070","modified":1677758419152},{"_id":"source/_posts/MethodologyFrontendEngineering/s4.png","hash":"97a7c99e4af7153f2d8a2e03a3244575c4d21e35","modified":1677758419129},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop03.png","hash":"7f95e0b62fd9ae0040fab231895410abf9d526b7","modified":1677758419155},{"_id":"source/_posts/MethodologyFrontendEngineering/s5.png","hash":"a9624bdf7f9dc3a3e82ac870c32b6a671f8bacad","modified":1677758419131},{"_id":"source/_posts/.obsidian/workspace.json","hash":"972560f2ab0c3ec98ab0fc38543928f529cb08cc","modified":1700706012682},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop06.png","hash":"347ee80e4dc7f343e58b15fedea956e360c1f68d","modified":1677758419158},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop05.png","hash":"7e3a6a6e47d245a5583a48d2936c372aa0d6b71e","modified":1677758419158},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop04.png","hash":"d59c83718dc41c1629890c7d914414f2302e195a","modified":1677758419156},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop12.png","hash":"540147c664a2eb5dfbaf33da40cfd17426b95f65","modified":1677758419167},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop07.png","hash":"250431ab613bced9bc1eacfec8c9a704d5f1ea72","modified":1677758419160},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop08.png","hash":"cd253aa9ea50a49f7fc8da77253b2cb026c01d37","modified":1677758419161},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop09.png","hash":"ae8162122e5fb292873fcc69c3c16fbb52f95b1e","modified":1677758419163},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop10.png","hash":"84bdb04de43b3bbc1b4d1bdb3c5ecb22581375cf","modified":1677758419164},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop11.png","hash":"bdfa84341a752062610fb3781a6f0a3d108ef7c6","modified":1677758419166},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop13.png","hash":"ef2d72c568f8af879afbc3f3ee56e911bc1ca6a4","modified":1677758419169},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop14.png","hash":"f2b0ee81d2a1a8ae5fc3f64fa68cc7986e425583","modified":1677758419169},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop15.png","hash":"0d9d787008e6b5310d4b99c0ecfb784796d1cc2e","modified":1677758419171},{"_id":"source/_posts/vueSourceCodeStudy02/s2-1.png","hash":"bb5f44da3cf6b932e2ac62fab6d46d106d6ed640","modified":1677758419206},{"_id":"source/_posts/someInterestingQuestions01/q2.png","hash":"ab246fa62b3c3fdf023fb533f7427705e8d2d505","modified":1677758419182},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop17.jpg","hash":"f5d3a3fe0a890abc041f2a9f567935b77f344a68","modified":1677758419174},{"_id":"source/_posts/someInterestingQuestions01/q1.png","hash":"51328a31d803cbe54c1986d329ae39a97f0c0852","modified":1677758419180},{"_id":"source/_posts/vueSourceCodeStudy02/s2-11.png","hash":"ea21eca2b7ad3cdba997cf6c1794476b4499ba78","modified":1677758419210},{"_id":"source/_posts/someInterestingQuestions01/q3.png","hash":"84b813171691c1aee44f99587f2f2ab396b1b072","modified":1677758419183},{"_id":"source/_posts/vueSourceCodeStudy02/s2-14.png","hash":"56f15fbb8bd9d33872a72040afb3c06594e72bf4","modified":1677758419213},{"_id":"source/_posts/vueSourceCodeStudy02/s2-3.png","hash":"b15ed7c05f54345ed7f60e9c601445a8cf84f64d","modified":1677758419219},{"_id":"source/_posts/vueSourceCodeStudy02/s2-4.png","hash":"8a88ec1634043270e224c53bcd105514a0ed14df","modified":1677758419220},{"_id":"source/_posts/vueSourceCodeStudy02/s2-6.png","hash":"1146414d813743c20228f0c2517be2a412f896eb","modified":1677758419223},{"_id":"source/_posts/vueSourceCodeStudy02/s2-5.png","hash":"077b04a0d1bd5f4f9bb384db7ad4924685182348","modified":1677758419222},{"_id":"source/_posts/vueSourceCodeStudy01/s1-2.png","hash":"a76fe14bb6e97de00b85910155a2626623e477c5","modified":1677758419196},{"_id":"source/_posts/vueSourceCodeStudy02/s2-7.png","hash":"d5276f1c2a20f569dcd3f63e1b6360ab0fd8236c","modified":1677758419224},{"_id":"source/_posts/vueSourceCodeStudy01/s1-1.png","hash":"9b14b0ac317afa93f041ba91b6776c5dc7c34616","modified":1677758419195},{"_id":"source/_posts/vueSourceCodeStudy01/s1-3.png","hash":"05bcd6d0a3b57aed291369a4bb25eb72b2f6b1f5","modified":1677758419197},{"_id":"source/_posts/vueSourceCodeStudy01/s1-5.png","hash":"bbb455e40091e15b9971c53bdc16647aaa9fcbfc","modified":1677758419199},{"_id":"source/_posts/vueSourceCodeStudy01/s1-4.png","hash":"c67e4bb4da213c6bb7a08a0ae0d9ae55a36cb028","modified":1677758419198},{"_id":"source/_posts/ReprintAngularOptimization/angular-performance01.png","hash":"3bb1ec112aca45abd29d94e0e8767d820591dea5","modified":1677758419148},{"_id":"source/_posts/MethodologyFrontendEngineering/s4-1.png","hash":"d12c26eac9bc105c2997689396daff080453d28f","modified":1677758419128},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop16.png","hash":"a82d6eae47b8187e8bad6e42d33c1e43fb399cac","modified":1677758419172},{"_id":"source/_posts/vueSourceCodeStudy02/s2-10.png","hash":"ba6e970962ef439ade2d69a57c23f460702738ac","modified":1677758419206},{"_id":"source/_posts/vueSourceCodeStudy02/s2-12.png","hash":"572a236f947710c79575e3e3cdd5617d32df3bfa","modified":1677758419212},{"_id":"source/_posts/vueSourceCodeStudy02/s2-13.png","hash":"c909a1adf9e4363473e8b311635c48436b866e8b","modified":1677758419213},{"_id":"source/_posts/vueSourceCodeStudy02/s2-2.png","hash":"7edb359a25e8e41d6fa1cad82cd775037139d9c3","modified":1677758419218},{"_id":"source/_posts/vueSourceCodeStudy01/s0.jpg","hash":"99a53f8d251a7786da76118619b8c6c8ef94d7c8","modified":1677758419194},{"_id":"source/_posts/vueSourceCodeStudy02/s2-8.png","hash":"4df0982ea7d09c073e403850eb074166eafa127c","modified":1677758419226},{"_id":"source/_posts/vueSourceCodeStudy02/s2-9.png","hash":"406ba4a71c8c0762c2d53ce34df7019d90427845","modified":1677758419226},{"_id":"source/_posts/vueSourceCodeStudy01/s1-6.png","hash":"b080e254aa2f094fe3bd8cbc6bd8dc0c9a1005b2","modified":1677758419201},{"_id":"source/_posts/vueSourceCodeStudy02/s0.png","hash":"e362937b7163f1d04576aeb0e11d8012b4a26e4b","modified":1677758419206},{"_id":"source/_posts/vueSourceCodeStudy02/s2-15.png","hash":"c03cc2fa65bb8bed84a677e1ddfb24a53d927b46","modified":1677758419217},{"_id":"source/_posts/MethodologyFrontendEngineering/s0.png","hash":"111c8e192ddc0d88aa08e287a69390262ea56301","modified":1677758419123},{"_id":"node_modules/hexo-theme-redefine/CODE_OF_CONDUCT.md","hash":"61a6276ef54989b7a1325f3ecb3183a4dfdf50cb","modified":1677758256739},{"_id":"node_modules/hexo-theme-redefine/LICENSE","hash":"a2f9ffbf32eeb6284afa81bc4fb4c27b80d044e9","modified":1700572858708},{"_id":"node_modules/hexo-theme-redefine/README_zh-CN.md","hash":"5cf370eab6baf2af2f23ac89227c53860ff746f0","modified":1700572860096},{"_id":"node_modules/hexo-theme-redefine/CONTRIBUTING.md","hash":"c6ef834f602b7ae02e2863a2a857e0ce8d392f15","modified":1700572860094},{"_id":"node_modules/hexo-theme-redefine/README.md","hash":"585ae63bad0354f7e674843b011864cc19d2d554","modified":1700572860098},{"_id":"node_modules/hexo-theme-redefine/README_zh-TW.md","hash":"8c2495230d0db3c08904b6119d2ea0fa245ffd4e","modified":1700572860097},{"_id":"node_modules/hexo-theme-redefine/_config.yml","hash":"a2d0467878641422a9facbe0da8f22bd49ebf6cc","modified":1700572880288},{"_id":"node_modules/hexo-theme-redefine/layout/404.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1677758256605},{"_id":"node_modules/hexo-theme-redefine/languages/en.yml","hash":"26b0abd54ece4073eb9716bc4afddc0bf6e5b7a7","modified":1700572880300},{"_id":"node_modules/hexo-theme-redefine/.editorconfig","hash":"a1c91f0a086bf92fddb02ccf23578ec2b51c099c","modified":1677758256547},{"_id":"node_modules/hexo-theme-redefine/package.json","hash":"625a8f5a72c0e474b410e6f20758405807311872","modified":1700623189701},{"_id":"node_modules/hexo-theme-redefine/languages/zh-CN.yml","hash":"eac90103634a331b094758cffec9c448df374771","modified":1700572880305},{"_id":"node_modules/hexo-theme-redefine/layout/archive-content.ejs","hash":"10d1423d77d7c128170c9179f9903c57a020ff03","modified":1700572858995},{"_id":"node_modules/hexo-theme-redefine/layout/article-content.ejs","hash":"b0f2ed49a8c0d5fcb913871dd67f3f2fcdd05f20","modified":1700623188740},{"_id":"node_modules/hexo-theme-redefine/languages/zh-TW.yml","hash":"1231bb0e2858235005761d2080e3c848cf14d97c","modified":1700572880306},{"_id":"node_modules/hexo-theme-redefine/layout/category-content.ejs","hash":"5c4fdc9c2b7f225edb7ebb2abf6925b81c5e698f","modified":1700572859001},{"_id":"node_modules/hexo-theme-redefine/layout/archive.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1677758256609},{"_id":"node_modules/hexo-theme-redefine/layout/home-content.ejs","hash":"e9aa5fd0cce47d5d5a9962f34a5dca0800f893e3","modified":1677826955754},{"_id":"node_modules/hexo-theme-redefine/layout/category-list.ejs","hash":"4bd20b18bdf10dfdce5ddcddfac2605800d18973","modified":1700572859002},{"_id":"node_modules/hexo-theme-redefine/layout/index.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1677758256634},{"_id":"node_modules/hexo-theme-redefine/layout/category.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1677758256618},{"_id":"node_modules/hexo-theme-redefine/layout/layout.ejs","hash":"e13ebcba0323e0641457d04009c6b548b914ef3d","modified":1700572859017},{"_id":"node_modules/hexo-theme-redefine/layout/page.ejs","hash":"0d43cc355011db0c5815610205851efd3ccbf691","modified":1700572859022},{"_id":"node_modules/hexo-theme-redefine/scripts/use-source-data.js","hash":"3ab07198fbca7015dcc4c061247681480058b0dc","modified":1677758256717},{"_id":"node_modules/hexo-theme-redefine/layout/tag.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1677758256651},{"_id":"node_modules/hexo-theme-redefine/layout/tag-content.ejs","hash":"6134aa2a112b9d8daa3eeaf9a1ee41bbeaf7eb24","modified":1700572859027},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/aliyun_cdn.yml","hash":"5b857a504539b739df992fa2894ba72fde6985ca","modified":1700572880292},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/npm-publish.yml","hash":"2b1771ae2a71e3c148b09d507f9be47d04e6e623","modified":1677758256931},{"_id":"node_modules/hexo-theme-redefine/layout/tags.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1677758256653},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/footer.ejs","hash":"12ac57a0d3683cc6f6b382779e5b3fd75fe7c01f","modified":1700660992080},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-report--english-version-.md","hash":"6b7cd67ce8911fdc0863da1b54e404514c7e85e5","modified":1677758256736},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-提交--中文版本-.md","hash":"ce8a586c2edfb66efe03d6c49e642ba566d302c5","modified":1677758256737},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/功能建议--中文版本-.md","hash":"ef69a31bcdbe2f749fd4990a4a85d51c300cd2dd","modified":1677758256747},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/feature-request--english-version-.md","hash":"243dbc4cf0678ca4f89fc2559eab3ace9fa881a7","modified":1677758256742},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/page-template.ejs","hash":"5d03f543ae291598ee227af758da73304a51633e","modified":1700572859021},{"_id":"node_modules/hexo-theme-redefine/scripts/events/404.js","hash":"169245d7b2af1ff401cf76e718c28b4e38f637c7","modified":1677758256659},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/head.ejs","hash":"2fda75fcd1d53357561022a202042cd3c57d11d7","modified":1700572859010},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/pjax.ejs","hash":"6416c0e4c7583db85d7f738b82e5aaa8f254876e","modified":1677758256643},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/menu.ejs","hash":"cf433e065c6d12b83f7209ccc349fb744028d83a","modified":1677758256638},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/scripts.ejs","hash":"6e8b93048dafe13279a321ba0d7b44b54b76b93a","modified":1700572859025},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lazyload-handle.js","hash":"7a8fd4996b9720c8d4cdb3042bfe5a1008f7c5fd","modified":1677758256684},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btn.js","hash":"3e4c1b01a1f922f712895e9ac06c030231b35cf2","modified":1677758256668},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/link-handle.js","hash":"a92ed888dad340809ee558020e0bb9f41e6413ee","modified":1677758256688},{"_id":"node_modules/hexo-theme-redefine/scripts/events/welcome.js","hash":"09409e5bc4f48d21936773ee37f789535bc97ea8","modified":1700623189700},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btns.js","hash":"a91492e772287114527a3fbc85f0c7c1c1b15eb3","modified":1677758256670},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/folding.js","hash":"cfa6646c1350c557430149bd52578c6cac59063b","modified":1700572859260},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note-large.js","hash":"b3e19b9a5c57e3e029bf9ead84aac750f799a9b3","modified":1700572859339},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/tabs.js","hash":"74e3b0cdd009206f7b78b04dcb96eccd86e7a996","modified":1700572859366},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/articleRecommend.js","hash":"11fd78ef30b45ae88a8dddeaeb7ce357617673ab","modified":1700572859245},{"_id":"node_modules/hexo-theme-redefine/source/assets/fonts.css","hash":"39f2b7042486b4a1df2f4304a6569b21559804e6","modified":1677758256588},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","hash":"793c31feb38e241a5ff6ecc5e65e61751507d728","modified":1677758256590},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","hash":"5119c35bbd273d2ea2501997827f6d644da93164","modified":1700572858739},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/autoCanonical.js","hash":"f3ea74759129c71041371a1d77c687eb6aa88d3a","modified":1677758256666},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note.js","hash":"8fc9f2e7d78fe2d1644828d8a79e2c48597f6103","modified":1700572859341},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/helper.js","hash":"8b02ae0ce5ae0f179602a9e19c9b7a0d9e17e3a4","modified":1677758256682},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/export-config.js","hash":"fafb01a50c52d20725ffcae06bad827e01cdee77","modified":1677758256676},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","hash":"18a176eb2486db4e938e568083fa578b641ccc83","modified":1700572858975},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/generate_seo.js","hash":"e0059a60cc5978be6792dcf795a2ece3a509f41a","modified":1677758256679},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","hash":"d27c4fed54dacff688010e51f611d950dd6e0aca","modified":1700572858978},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","hash":"e727feabedb171fb0b398151870d7739ef4e2432","modified":1700572858981},{"_id":"node_modules/hexo-theme-redefine/source/fonts/OPTIMA.woff","hash":"ddefd7389a3aaf00d50e2ecc99f71eefe853c4b3","modified":1677758256870},{"_id":"node_modules/hexo-theme-redefine/source/fonts/OPTIMA_B.woff","hash":"129a1b30e7b829b9894245b3c99e1c6c016e4147","modified":1677758256866},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","hash":"f4c08e37c4d44b3ed7a3f377d1cb5d7fca4d04bc","modified":1700572858985},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","hash":"0be987628c8b485b39f064da41c90f15c0596c1f","modified":1700572858986},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","hash":"3d46be31379b07ffb24d69c6c915725eaa2e89e9","modified":1700572858985},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Optima Medium.woff","hash":"f18b71ba83f68f1478b0af64cf76a99971c4fd9a","modified":1677758256864},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","hash":"96f037860b8e9b59af8e47571ea98791616dbfd8","modified":1700572858987},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","hash":"260ea7a5e0b89963a5dcf2600a4decdf0f408f3f","modified":1700572858989},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","hash":"938c2a41c8ba18e37ed659e481696e40a4c8f3a4","modified":1700572860169},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Optima_Italic.woff","hash":"7200bef189fb05f741555e734908df59d0f20e2f","modified":1677758256868},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","hash":"d9450b06a5391ba6f62690bfef2071a1c8e7e893","modified":1700572860156},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","hash":"d0d20061bda08894a82d7691b660be7c6aaa0608","modified":1700572860170},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","hash":"a9ce4d8a91ddc7811cf9715be1f857cd899d7382","modified":1700572859289},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","hash":"b8cbd5658c0b75b12f0a8b0e80b33e3ace9dbb0b","modified":1700572859377},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","hash":"472776b6f013aad44706fee6c94201c96ee83932","modified":1700572860172},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","hash":"0a07e3fb6d9125dee44798c8c110187b16fb42a9","modified":1700572862199},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","hash":"b54531dd09c5089eb93b12ce8f90ff521855ff8a","modified":1700572862077},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","hash":"d02b1adc81fd5bec023e25a7770779b99d6dd742","modified":1700572874933},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/posts/article-copyright-info.ejs","hash":"77e13720374efb902ee3d4d04d13b62de033a3ae","modified":1677758256614},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/posts/toc.ejs","hash":"b3ab8e1f6c08090f6b59fa6ffc802f6427ea3c37","modified":1677758256654},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/components/404-template.ejs","hash":"7729caa836a1c2208860cada53d674e9e9ff61f3","modified":1677758256604},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/components/archive-list.ejs","hash":"7c33e49286d54824cd8f3483e30de5579951edc6","modified":1677758256608},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/components/friends-link.ejs","hash":"3787e5c947e04e2cac3ed31d19380f4aeeba8641","modified":1677758256625},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/components/first-screen.ejs","hash":"d613cd05dfc34760f60101bac45c592bf8bf7d3c","modified":1677758256622},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/posts/article-meta-info.ejs","hash":"8cc3b2615207aaff38c3facfcf618207b21f5eb5","modified":1677758256615},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/components/home-article-meta-info.ejs","hash":"7175050b978518041355d517d9e8623f03fbd079","modified":1677758256630},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/tools/image-viewer.ejs","hash":"beb3dec5e08856a29d585fe0eb94a8a6ddade4dd","modified":1677758256633},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/comments/comment.ejs","hash":"4ca12a0bcb85a03dec368c5e12eebf2905aeb404","modified":1700572859004},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/tools/local-search.ejs","hash":"72c9acca0280f0e63e6a5d31618dd2707bdbec3f","modified":1677758256637},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/comments/gitalk.ejs","hash":"482c45e6f5b04a4cce2b8e94530c8b0a33c55009","modified":1700572859010},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/comments/twikoo.ejs","hash":"2945e818e4406fbb5628a465023c7e4d445c0975","modified":1700572859031},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/comments/waline.ejs","hash":"7b2eb135b4171b94836e10befa07399ce974d4d0","modified":1700572859032},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/tools/post-tools.ejs","hash":"6418d8d9b1d9f9dc5361fabe280507c8a50d9513","modified":1677758256644},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/tools/paginator.ejs","hash":"cfd4d9a30bd20ee0750b79226cb94562439013bf","modified":1677758256642},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/tools/progress-bar.ejs","hash":"d893fb2761220282efa6461c0d4107de3e2bcfdb","modified":1677758256646},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/tools/side-tools.ejs","hash":"9f8fdf30f308bd20488aa76f134c516972b190cc","modified":1677758256649},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1677758256663},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","hash":"c06323d68bbdebbb685db5010e7655b8ed0caf42","modified":1700572859271},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/tools/tagcloud.ejs","hash":"cd29a21b9747f39ff1761c3dbbf22523953e19d2","modified":1677758256652},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/menu-shrink.js","hash":"de907057c0d162664e92880aaf457002c51dd5b6","modified":1677758256694},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1677758256706},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1700572859346},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","hash":"4e329547447c716c986e0b4a4f54afc59fc6b486","modified":1700572860114},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","hash":"1addb3435a3007c1bb49dbd6ddf295d38b538989","modified":1700623196977},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","hash":"9959507beb382779a0bef9bf19bda9117a9568d6","modified":1700572860124},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","hash":"4f9a5559b5269ec74b5f49ac113268f747bf0243","modified":1700572860123},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","hash":"ab52b066c427cee62d67e4da136878114c7b1afe","modified":1700572860109},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","hash":"299a383d78d1ddbeafbdf39dad5d007d5ee300f8","modified":1700572860139},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","hash":"6c9ec582c1d8699bdff5a4cd1524121cc6ca8522","modified":1700572860158},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","hash":"303254d382869ed618025fcb328426bd10314583","modified":1700572859292},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","hash":"e5c0b44623d18d0c2674069b3796546dd9857b8d","modified":1700572860149},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","hash":"7a768982f6cb1f40552cce063d5743fe862db762","modified":1700572859372},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","hash":"964ec5c25a8d78763ba2ba9bfbd5b1b49ed05381","modified":1700572859367},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/code-block.js","hash":"0c80da6fcf17d0785ae6f68be50a9131e46e1121","modified":1677758256673},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","hash":"0493e7ae8c2b07cf1172fa1b68ea1ec74795878b","modified":1700572860121},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","hash":"bc1d8961fb21a3c59c1b3ebf71c4f1051072e241","modified":1700623197142},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/go-top-bottom.js","hash":"f5f6f6ba96e288a5fd1427b7f3761139623e8fcd","modified":1677758256680},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/dark-light-toggle.js","hash":"1c12e83fd94d51b4476c8f480165312424d62f4a","modified":1677758256675},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/local-search.js","hash":"bc9e888ee05c4fb0e8fd1962423a04f63c1e393e","modified":1677758256690},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","hash":"eb0374b6f033f7ac25f49b1b079aa163e14b0fcd","modified":1700572859347},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","hash":"ff099b1959829e3070e5077c4a3b13e1c1573e79","modified":1700572860153},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/buttons.styl","hash":"18bd3c1d00e2cc6416cef69433b207ae5c947ba1","modified":1700572860123},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/toc-toggle.js","hash":"eeab6a799bf23a2d4c58921dcf8b15203e1d3bfd","modified":1677758256714},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/notes.styl","hash":"37b2a4a0669414c74498ed0ecae873c90b15fe6e","modified":1700572860146},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/folding.styl","hash":"b5e5c2407eb83ae4b3ee4ed73490dcd41edef705","modified":1700572860132},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","hash":"369616699fd9a0ca831e4b6a6f07171ff1cd63fc","modified":1700572860164},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/tabs.styl","hash":"dbf47ca4ceb2951843b3170ec893077216158191","modified":1700572860157},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","hash":"05e95f07589b1f78081f95cef4749a7041f24b81","modified":1700572860128},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/404.styl","hash":"16215f6fe664d1ddc5744a626405bc774dc30f70","modified":1700572860108},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/archive-list.styl","hash":"83e56a7640af063b8f47d09ca8b3e3517c986b1a","modified":1700572860115},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","hash":"0593c3555640bb9132caaccac9821225ea3b97c8","modified":1700572860127},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-copyright-info.styl","hash":"810d182789bce6fc27a30e2eafc21d3d292fb9af","modified":1700572860117},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-meta-info.styl","hash":"1f680910751b36c4445a48c5a48eda3187412eaf","modified":1700572860119},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/footer.styl","hash":"b9028c74a9f75536d5a7cee77a25a5d77469515a","modified":1700572860133},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/first-screen.styl","hash":"694c2670bc04bd5284700c453d3e99c7a399110b","modified":1677758256780},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/image-viewer.styl","hash":"6c8eeb7a96cae110cd9a684a3a5076148b8154d8","modified":1700572860141},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","hash":"39a8032d5ca2872ef9268856a77d212200d07651","modified":1700572860137},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/local-search.styl","hash":"a9c99c57b27afbe7f00f1f14f0e46c41748affb5","modified":1700572860142},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/menu.styl","hash":"d7002d8486fde897aa1547ebd5d29b7f155fb3bc","modified":1677758256793},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/page-template.styl","hash":"69c4a1fe97d37dcc359d1a955d7baa36b1bbd2fb","modified":1700572860147},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/post-tools.styl","hash":"d602c2fe191d2c639f7cd8c4d0ee618f8c80f5c1","modified":1700572860152},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/progress-bar.styl","hash":"f94780762572055a0eb56b41e0e676262b38cf6a","modified":1700572860153},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/paginator.styl","hash":"53421b731f3d7ed34a3a4c87405e06ae3d6519e0","modified":1700572860150},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/comment.styl","hash":"5d1b3424845a065b3082fe577081da60845db05e","modified":1700572860131},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/side-tools.styl","hash":"995982b8c228f7386d352042f64587d06663716e","modified":1700572860154},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/gitalk.styl","hash":"85f26189ec6dee13a0a743687e7b5391f170c33f","modified":1700572860135},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/toc.styl","hash":"13949981a5afa2b0483da1836af5999d992961f9","modified":1700572860160},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/tagcloud.styl","hash":"d66f59c0b2d5b9ed64ef50bffee3a3d0bef1f114","modified":1700572860159},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/waline.styl","hash":"24ad25f1344b51f0ccb436644e70d95e84fd8f40","modified":1700572860167},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/twikoo.styl","hash":"448cbc045bcffa2d666094b81dd99eb980676fff","modified":1700572860161},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","hash":"a358912d781e6249a8d291e4ce9ebd0a9ab9452e","modified":1700572870859},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","hash":"44e6d666b45a6875e4fce11159876129e7a1cceb","modified":1700572858967},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","hash":"ba9322d66c19f635e15e458cc39fcb509818332f","modified":1700572860193},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","hash":"0becc4b085bd9d377a8ff4b5160f8e19c8ec27a0","modified":1700572858851},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","hash":"486fed640153de1de84f460834c73daef060ed20","modified":1700572873567},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","hash":"e73d164db2aff2c91d18c07da03e8db9d0c5dfd4","modified":1700572874325},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","hash":"2cc24434345b80a844a6bda1139539fe41e4df53","modified":1700572871874},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","hash":"def760895375328ccdcf62b2b9b9001a21947acd","modified":1700572872628},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","hash":"630bf0e29410ec27622f65d1270c6bc435cdff21","modified":1700572858737},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","hash":"e0a4482c20f6b67784df54965539a317a3bd681b","modified":1700572874931},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","hash":"40b536c3667547db70ee9ca6f3c94fbc33e0cab7","modified":1700572861535},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","hash":"c11ca6043d8dae028448a808105f8c888faac8f5","modified":1677758256701},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","hash":"cdec068700dc440530e5bbeff7e8bb33a01b4132","modified":1700572861164},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","hash":"cc5d9f4f994c82e23f58cdde1eec8792d81633c7","modified":1700572860816},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","hash":"e0313a772ea710cb5ea4bd08f5dedb0a0025f8ca","modified":1700572860580},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","hash":"c1fee6e6986b14533ce022afada5fbe10c0f6562","modified":1700572862069},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","hash":"7d303cf926754817c4360f92e6c39b8c390cdbdb","modified":1677758256734},{"_id":"public/cv/index.js","hash":"9f5e82911a419f9fc0201ed500717c0cfb4a0d0d","modified":1678848337350},{"_id":"public/about/index.html","hash":"8f16db772b89fad36b4fd97021beeec58cd1a314","modified":1700887274169},{"_id":"public/search.xml","hash":"fe257a5ddffcc84176c7f5edab70062527c07f2c","modified":1700887274169},{"_id":"public/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1678848337350},{"_id":"public/tags/index.html","hash":"e963715938ba82ed81f01fb281cdd81ffc8e9d49","modified":1700887274169},{"_id":"public/categories/index.html","hash":"80cf4482771b1ea5c2f3696ec67a750e8b2c0a35","modified":1700887274169},{"_id":"public/cv/index.html","hash":"bbee7b6c1ac40dd9a028fbe06b280c28bc3e76f0","modified":1700887274169},{"_id":"public/404.html","hash":"04be360e5f6862718855a4029f12175ec378f89b","modified":1700887274169},{"_id":"public/2023/02/21/MethodologyJSExcutionProcess/index.html","hash":"8742a77c4f4ecd84284bf37a7b44a588f43e8451","modified":1700887274169},{"_id":"public/2023/02/11/MethodologyRefactoring/index.html","hash":"44972b5bbe5fb5d84ed15dc31d23d036cabc9bb0","modified":1700887274169},{"_id":"public/2023/01/11/APIMutationObserver/index.html","hash":"0a763cac12ddecf3ea3e9f5bee7d8cf915bad6d6","modified":1700887274169},{"_id":"public/2022/11/02/ReprintTypscriptDecorator/index.html","hash":"6865e070ad32ccaa17231e73093a8b27ed78312c","modified":1700887274169},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/index.html","hash":"373e49a1dde7bc2469ff4c856d4eaf7ed8297a1b","modified":1700887274169},{"_id":"public/2022/06/03/vueSourceCodeStudy01/index.html","hash":"69f9d811ad2c0a8510fd26dae3ae924dba94c93b","modified":1700887274169},{"_id":"public/2022/06/15/MethodologyStateManagement/index.html","hash":"92e27415aac6215f870fac79956207cacaabd2ca","modified":1700887274169},{"_id":"public/2022/06/03/vueSourceCodeStudy02/index.html","hash":"edfc6fa0fd61e08005a5dc2aef5acccfe75a3f10","modified":1700887274169},{"_id":"public/2022/06/03/vueSourceCodeStudy03/index.html","hash":"b21d37304972ec52cf8c49ed52799e8e2dd6aa92","modified":1700887274169},{"_id":"public/2022/05/02/ReprintVueCompositionAPI/index.html","hash":"b5c05b1c611d29755cf6a614c2aeccf1f0d5262b","modified":1700887274169},{"_id":"public/2022/05/02/ReprintAngularOptimization/index.html","hash":"3e724ac52d06c984036220cb4dd18e39b99ff719","modified":1700887274169},{"_id":"public/2022/03/20/MethodologyFrontendHistory/index.html","hash":"1d7337b98619d6d235d5873c37d4f739fb9c59dc","modified":1700887274169},{"_id":"public/2022/03/09/MethodologyFrontendJSModularity /index.html","hash":"2038e66bb2fc6820a26a931bbe15429d1d6d3a0b","modified":1700887274169},{"_id":"public/2021/10/15/PracticeCallApply/index.html","hash":"d9e57fc0aa80a78951323f65868ddeb82bcb9113","modified":1700887274169},{"_id":"public/2021/09/12/ReprintJSEventLoop/index.html","hash":"8ed4095e9390d0ad8e617213023dac456584cd45","modified":1700887274169},{"_id":"public/2021/09/08/PracticePromise/index.html","hash":"d506fc65b6371e6355bcb9d1658a608d7d8fa83b","modified":1700887274169},{"_id":"public/2021/03/27/someInterestingQuestions06/index.html","hash":"e700d2e0212de12d9668f60bf47731e275e780b5","modified":1700887274169},{"_id":"public/2021/03/20/someInterestingQuestions05/index.html","hash":"93d3c05a2682b781c496c4c17ba2b08b6916dc3c","modified":1700887274169},{"_id":"public/2021/03/14/someInterestingQuestions04/index.html","hash":"0774795ee622a9a64e9a551308222c0ba660949a","modified":1700887274169},{"_id":"public/2021/03/06/someInterestingQuestions03/index.html","hash":"f6fdc21e673ba75d45eee695a665a44ca241e7f8","modified":1700887274169},{"_id":"public/archives/index.html","hash":"9a32b2601b9c78100582663e28427325de17b50c","modified":1700887274169},{"_id":"public/2021/03/02/ReprintBrowserRender/index.html","hash":"1bfff2a6369d4d40b8190651c5483c6ffdf77bb1","modified":1700887274169},{"_id":"public/2021/02/25/someInterestingQuestions02/index.html","hash":"789a127fa96fb0709a5cea9d14abb3544bc0dc85","modified":1700887274169},{"_id":"public/2021/02/23/someInterestingQuestions01/index.html","hash":"3d66635fccb13f9bdc5fffc2df2c8f53d4f8420d","modified":1700887274169},{"_id":"public/archives/page/2/index.html","hash":"9f7d4e50db2a6e885b32377e0f06e2493b25c836","modified":1700887274169},{"_id":"public/archives/page/3/index.html","hash":"e76ea2050319e5dd24ad0cb2fa23042acb37c18e","modified":1700887274169},{"_id":"public/archives/2021/index.html","hash":"f96bb9ed8946ff061c03f205edb04ab1562901a9","modified":1700887274169},{"_id":"public/archives/2021/02/index.html","hash":"8fad9e3dc0b15178a5e9a992c5872a8058a1edb8","modified":1700887274169},{"_id":"public/archives/2021/03/index.html","hash":"16595adf8025f0ed9618d1dd216aab2fb5d6a353","modified":1700887274169},{"_id":"public/archives/2021/09/index.html","hash":"fde0da80add78cdfd2ae996a60ea8e1e0eb56d9c","modified":1700887274169},{"_id":"public/archives/2021/10/index.html","hash":"3e0df464d90d9b01ac44629f541917e7ea3398fb","modified":1700887274169},{"_id":"public/archives/2022/index.html","hash":"980227c624516fe10770970f63859f1ddb6f0c2f","modified":1700887274169},{"_id":"public/archives/2022/03/index.html","hash":"cd24af9136b34ae4aa5b0acc120982f63cb2bafa","modified":1700887274169},{"_id":"public/archives/2022/05/index.html","hash":"a6987b7db54c5e1c404ffe625ee4b4c455a343b5","modified":1700887274169},{"_id":"public/archives/2022/06/index.html","hash":"a6c1017b7f486f81afb6e8e6755a1d8629095ebc","modified":1700887274169},{"_id":"public/archives/2022/07/index.html","hash":"d45d54a1e7ffdccb663dccf66ff7fedd71d450d4","modified":1700887274169},{"_id":"public/archives/2022/11/index.html","hash":"b01eb7dc1a9cb8608782c426aa9d2d8cb7370197","modified":1700887274169},{"_id":"public/archives/2023/index.html","hash":"11970afe84e7b8ed2773b674ed153249eceae10e","modified":1700887274169},{"_id":"public/archives/2023/01/index.html","hash":"b14f7dd3711e7d5f2f56e12c50a51b640d1bb471","modified":1700887274169},{"_id":"public/archives/2023/02/index.html","hash":"a73b2da9f8b7186cf7c6021006bf19634a959c64","modified":1700887274169},{"_id":"public/categories/API/index.html","hash":"be7c9b8978f865ca4ccaad7b60f0495db49a98d1","modified":1700887274169},{"_id":"public/categories/方法论/index.html","hash":"ff46414f67b2b6d9125f351146cc38bff13b92f7","modified":1700887274169},{"_id":"public/categories/实践/index.html","hash":"9cd16d7935c5ed8c3d55ffba412223b1f581a87c","modified":1700887274169},{"_id":"public/categories/转载/index.html","hash":"68fef4cc55ac397e3e0bb67155a5671340129a24","modified":1700887274169},{"_id":"public/categories/一些有趣的问题/index.html","hash":"2a1978251b5e7e888bb8abc71f05d43b28659439","modified":1700887274169},{"_id":"public/categories/源码/index.html","hash":"c0064a0ec545b10a17b7a4c79def6950ccaba331","modified":1700887274169},{"_id":"public/page/2/index.html","hash":"a23089bd96bd34b2e752844c0b67dd414fd007dd","modified":1700887274169},{"_id":"public/tags/JS/index.html","hash":"3b2ffd2fff60806ffa995bc4cded6403e5ee11a3","modified":1700887274169},{"_id":"public/page/3/index.html","hash":"1a83bb0e4308d924200936090ecb5cfac1e927f8","modified":1700887274169},{"_id":"public/index.html","hash":"a4cb8659ba0d073f2113f4e7c0dd66ade2f98756","modified":1700887274169},{"_id":"public/tags/JS/page/2/index.html","hash":"fe679bdb61c31727770ed92372314252d26dd65c","modified":1700887274169},{"_id":"public/tags/前端工程化/index.html","hash":"a49f13a33cdf05bb4a97fce7337daf38fffaf0b5","modified":1700887274169},{"_id":"public/tags/angular/index.html","hash":"f81a8a51ae152825023aa23a78038ac43cd3756b","modified":1700887274169},{"_id":"public/tags/browser/index.html","hash":"1ba7636a5613b08b0e5828af62aa22c5200fa6fc","modified":1700887274169},{"_id":"public/tags/typescript/index.html","hash":"d4737ab7427296b598300dcb31f98f29557b4873","modified":1700887274169},{"_id":"public/tags/vue/index.html","hash":"ffd6ea0c1b247a653c6b0e35041b806242d22bd3","modified":1700887274169},{"_id":"public/fonts/OPTIMA.woff","hash":"ddefd7389a3aaf00d50e2ecc99f71eefe853c4b3","modified":1678848337350},{"_id":"public/images/loading.svg","hash":"364550d66fb15b740c038da4780ff4c78c500c70","modified":1678848337350},{"_id":"public/images/redefine-logo.svg","hash":"015e3b4e7d1cefd31db0f4a07651aa09626ff522","modified":1678848337350},{"_id":"public/images/redefine-avatar.svg","hash":"2f9054f6889cb6fe648f65a04370b1bf5a08ab98","modified":1678848337350},{"_id":"public/fonts/OPTIMA_B.woff","hash":"129a1b30e7b829b9894245b3c99e1c6c016e4147","modified":1678848337350},{"_id":"public/fonts/Optima Medium.woff","hash":"f18b71ba83f68f1478b0af64cf76a99971c4fd9a","modified":1678848337350},{"_id":"public/images/redefine-logo.webp","hash":"1d37c4ea27006b51d5e48c028329de57475f53bd","modified":1678848337350},{"_id":"public/fonts/Optima_Italic.woff","hash":"7200bef189fb05f741555e734908df59d0f20e2f","modified":1678848337350},{"_id":"public/webfonts/fa-v4compatibility.ttf","hash":"24f298867c8f7d42240dba3a17da1a0224bd6a94","modified":1678848337350},{"_id":"public/webfonts/fa-v4compatibility.woff2","hash":"1d51fca676afe5d0cbaa854d650a99d23e2f8219","modified":1678848337350},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/s1.png","hash":"f614910da7c56417905e7aa5abb54c6f2255500e","modified":1678848337350},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/s2.png","hash":"41284a302db60fe0f2865e003d731b34e5c3f7c9","modified":1678848337350},{"_id":"public/2021/09/08/PracticePromise/s1.png","hash":"c9aa0692e25558749268b2c0a5aa1e5400a48377","modified":1678848337350},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/s3.png","hash":"b9d84d6ae13d3071402cad6a0e383ff57d5795b6","modified":1678848337350},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/s4.png","hash":"97a7c99e4af7153f2d8a2e03a3244575c4d21e35","modified":1678848337350},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/s5.png","hash":"a9624bdf7f9dc3a3e82ac870c32b6a671f8bacad","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop01.png","hash":"7a281cd1d656277c58255d68c46db2d8dbe9e070","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop02.png","hash":"93ff24fbfd93e5b99d529cc00f2149c790644c39","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop03.png","hash":"7f95e0b62fd9ae0040fab231895410abf9d526b7","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop04.png","hash":"d59c83718dc41c1629890c7d914414f2302e195a","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop05.png","hash":"7e3a6a6e47d245a5583a48d2936c372aa0d6b71e","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop06.png","hash":"347ee80e4dc7f343e58b15fedea956e360c1f68d","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop07.png","hash":"250431ab613bced9bc1eacfec8c9a704d5f1ea72","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop08.png","hash":"cd253aa9ea50a49f7fc8da77253b2cb026c01d37","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop09.png","hash":"ae8162122e5fb292873fcc69c3c16fbb52f95b1e","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop10.png","hash":"84bdb04de43b3bbc1b4d1bdb3c5ecb22581375cf","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop12.png","hash":"540147c664a2eb5dfbaf33da40cfd17426b95f65","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop11.png","hash":"bdfa84341a752062610fb3781a6f0a3d108ef7c6","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop13.png","hash":"ef2d72c568f8af879afbc3f3ee56e911bc1ca6a4","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop14.png","hash":"f2b0ee81d2a1a8ae5fc3f64fa68cc7986e425583","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop15.png","hash":"0d9d787008e6b5310d4b99c0ecfb784796d1cc2e","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop17.jpg","hash":"f5d3a3fe0a890abc041f2a9f567935b77f344a68","modified":1678848337350},{"_id":"public/2021/02/23/someInterestingQuestions01/q1.png","hash":"51328a31d803cbe54c1986d329ae39a97f0c0852","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy01/s1-1.png","hash":"9b14b0ac317afa93f041ba91b6776c5dc7c34616","modified":1678848337350},{"_id":"public/2021/02/23/someInterestingQuestions01/q3.png","hash":"84b813171691c1aee44f99587f2f2ab396b1b072","modified":1678848337350},{"_id":"public/2021/02/23/someInterestingQuestions01/q2.png","hash":"ab246fa62b3c3fdf023fb533f7427705e8d2d505","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy01/s1-2.png","hash":"a76fe14bb6e97de00b85910155a2626623e477c5","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy01/s1-3.png","hash":"05bcd6d0a3b57aed291369a4bb25eb72b2f6b1f5","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-1.png","hash":"bb5f44da3cf6b932e2ac62fab6d46d106d6ed640","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy01/s1-5.png","hash":"bbb455e40091e15b9971c53bdc16647aaa9fcbfc","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy01/s1-4.png","hash":"c67e4bb4da213c6bb7a08a0ae0d9ae55a36cb028","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-11.png","hash":"ea21eca2b7ad3cdba997cf6c1794476b4499ba78","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-14.png","hash":"56f15fbb8bd9d33872a72040afb3c06594e72bf4","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-3.png","hash":"b15ed7c05f54345ed7f60e9c601445a8cf84f64d","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-4.png","hash":"8a88ec1634043270e224c53bcd105514a0ed14df","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-5.png","hash":"077b04a0d1bd5f4f9bb384db7ad4924685182348","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-6.png","hash":"1146414d813743c20228f0c2517be2a412f896eb","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-7.png","hash":"d5276f1c2a20f569dcd3f63e1b6360ab0fd8236c","modified":1678848337350},{"_id":"public/assets/fonts.css","hash":"39f2b7042486b4a1df2f4304a6569b21559804e6","modified":1678848337350},{"_id":"public/assets/odometer-theme-minimal.css","hash":"793c31feb38e241a5ff6ecc5e65e61751507d728","modified":1678848337350},{"_id":"public/fontawesome/light.min.css","hash":"1e252b2b3e8486d3d6e4a6fa36157aaad73d9bee","modified":1678848337350},{"_id":"public/fontawesome/regular.min.css","hash":"8b6a0f2a240efd3175e6aef9928b92c62ffd43d8","modified":1678848337350},{"_id":"public/fontawesome/solid.min.css","hash":"9dfe544d3afe0a3dfbe61bbb3bbb6ac94995d90c","modified":1678848337350},{"_id":"public/fontawesome/thin.min.css","hash":"65038cffbfb1e0f087d44abf9758ad16a08caf82","modified":1678848337350},{"_id":"public/js/main.js","hash":"1feb45991ffce095b0b31a7ab0156cd9cdb8cfd7","modified":1678848337350},{"_id":"public/fontawesome/v4-font-face.min.css","hash":"57df6abf04b71d0946fa20e66e946d3a2fa66667","modified":1678848337350},{"_id":"public/fontawesome/v5-font-face.min.css","hash":"758a98c7bacc6d72bc3f53ecad34424096729699","modified":1678848337350},{"_id":"public/js/utils.js","hash":"1bccc453283eb1a817b1ad7efe46864750c71865","modified":1678848337350},{"_id":"public/css/style.css","hash":"02637d4c6680f83f54bed6c9826a0daa944c720c","modified":1678848337350},{"_id":"public/fontawesome/brands.min.css","hash":"956a0381099e0204c870fc447b8522b2f4b063b8","modified":1678848337350},{"_id":"public/fontawesome/svg-with-js.min.css","hash":"28ba38557852bff7d4f81a589958ceead70b3b2d","modified":1678848337350},{"_id":"public/fontawesome/fontawesome.min.css","hash":"4caeaf71d849d565eb73d6cfa2a885b8fd5a1585","modified":1678848337350},{"_id":"public/fontawesome/v4-shims.min.css","hash":"3f1f1977ce39f47e963194ae11a1f3dbbe4d951e","modified":1678848337350},{"_id":"public/fontawesome/duotone.min.css","hash":"2a4c024238017920b3fd07ec8ace147fa813131d","modified":1678848337350},{"_id":"public/fontawesome/all.min.css","hash":"1aca70954817e603412964fdbfb231f03137af7c","modified":1678848337350},{"_id":"public/webfonts/fa-brands-400.woff2","hash":"132096157a1bd06ee90d0e099b30858e55f44a2f","modified":1678848337350},{"_id":"public/2022/05/02/ReprintAngularOptimization/angular-performance01.png","hash":"3bb1ec112aca45abd29d94e0e8767d820591dea5","modified":1678848337350},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/s4-1.png","hash":"d12c26eac9bc105c2997689396daff080453d28f","modified":1678848337350},{"_id":"public/2021/09/12/ReprintJSEventLoop/js-eventloop16.png","hash":"a82d6eae47b8187e8bad6e42d33c1e43fb399cac","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy01/s0.jpg","hash":"99a53f8d251a7786da76118619b8c6c8ef94d7c8","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy01/s1-6.png","hash":"b080e254aa2f094fe3bd8cbc6bd8dc0c9a1005b2","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-10.png","hash":"ba6e970962ef439ade2d69a57c23f460702738ac","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-12.png","hash":"572a236f947710c79575e3e3cdd5617d32df3bfa","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-2.png","hash":"7edb359a25e8e41d6fa1cad82cd775037139d9c3","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-13.png","hash":"c909a1adf9e4363473e8b311635c48436b866e8b","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-8.png","hash":"4df0982ea7d09c073e403850eb074166eafa127c","modified":1678848337350},{"_id":"public/webfonts/fa-brands-400.ttf","hash":"3539eea45ea45122110ca826e4cf461a9fc24bfd","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-9.png","hash":"406ba4a71c8c0762c2d53ce34df7019d90427845","modified":1678848337350},{"_id":"public/js/layouts/lazyload.js","hash":"298c51d15c0286acbebe420369daf87edf8aada7","modified":1678848337350},{"_id":"public/js/layouts/menu-shrink.js","hash":"de907057c0d162664e92880aaf457002c51dd5b6","modified":1678848337350},{"_id":"public/js/layouts/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1678848337350},{"_id":"public/js/layouts/toc.js","hash":"d832e2fa48626d0c79ceee83a070639a9edd5347","modified":1678848337350},{"_id":"public/css/layout/archive-content.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1678848337350},{"_id":"public/css/layout/article-content.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1678848337350},{"_id":"public/css/layout/category-content.css","hash":"068db2c1ea9a6dc2a0822affff5200547732753a","modified":1678848337350},{"_id":"public/css/layout/category-list.css","hash":"672859a61a4e93c0514772112fb557395306e940","modified":1678848337350},{"_id":"public/css/common/animated.css","hash":"5eb3f4369948955ea0a4543957af6086b2eed7b8","modified":1678848337350},{"_id":"public/css/layout/home-content.css","hash":"444e33875e33be0553b83a316d4223372eefab8e","modified":1678848337350},{"_id":"public/css/common/basic.css","hash":"c0a711be8982985ebb9708c1d983a108139d8a65","modified":1678848337350},{"_id":"public/css/layout/tag-content.css","hash":"33984cff48fe2f37286f6f0151b0c7cc2d5b9454","modified":1678848337350},{"_id":"public/css/layout/page.css","hash":"ba171f197791adc7eb890e54da12b3dcbaedfa10","modified":1678848337350},{"_id":"public/js/plugins/tabs.js","hash":"01d151fc85f6c5744132112eb81f072cbb688d44","modified":1678848337350},{"_id":"public/js/plugins/mermaid.js","hash":"84b8147c7ff1f949f0b7215060376751590111d6","modified":1678848337350},{"_id":"public/js/tools/code-block.js","hash":"0c80da6fcf17d0785ae6f68be50a9131e46e1121","modified":1678848337350},{"_id":"public/css/common/markdown.css","hash":"aceff6f3efb7d9b0d303cd7b6476296bcbf2ea0b","modified":1678848337350},{"_id":"public/css/common/redefine-theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1678848337350},{"_id":"public/js/tools/go-top-bottom.js","hash":"f5f6f6ba96e288a5fd1427b7f3761139623e8fcd","modified":1678848337350},{"_id":"public/css/common/variables.css","hash":"c9d161293fc460bf0a9d28315862ecff94ab6ddb","modified":1678848337350},{"_id":"public/js/tools/dark-light-toggle.js","hash":"1c12e83fd94d51b4476c8f480165312424d62f4a","modified":1678848337350},{"_id":"public/js/tools/local-search.js","hash":"bc9e888ee05c4fb0e8fd1962423a04f63c1e393e","modified":1678848337350},{"_id":"public/js/tools/runtime.js","hash":"cfc1a9b582b281e9dd1688a55cfbc5e89d3bd968","modified":1678848337350},{"_id":"public/js/tools/toc-toggle.js","hash":"eeab6a799bf23a2d4c58921dcf8b15203e1d3bfd","modified":1678848337350},{"_id":"public/css/common/codeblock/code-block.css","hash":"93b7c994fc70c83f49e186c563f00d6ed7e32ae3","modified":1678848337350},{"_id":"public/css/common/codeblock/code-theme.css","hash":"5dc5a06445bcd234f68e3489e3f0bfcb6d5f4ee8","modified":1678848337350},{"_id":"public/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1678848337350},{"_id":"public/js/libs/pjax.min.js","hash":"57ec40cb4898d7ba74a03603d608af378e5431f8","modified":1678848337350},{"_id":"public/css/common/codeblock/highlight.css","hash":"da467d3b1515dc7dc1ad93e74282e02831c49cbd","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s0.png","hash":"e362937b7163f1d04576aeb0e11d8012b4a26e4b","modified":1678848337350},{"_id":"public/2022/06/03/vueSourceCodeStudy02/s2-15.png","hash":"c03cc2fa65bb8bed84a677e1ddfb24a53d927b46","modified":1678848337350},{"_id":"public/js/libs/mermaid.min.js","hash":"c11ca6043d8dae028448a808105f8c888faac8f5","modified":1678848337350},{"_id":"public/webfonts/fa-regular-400.woff2","hash":"63bee62a49b1e129dd410a7804c36f600e45e9ef","modified":1678848337350},{"_id":"public/webfonts/fa-solid-900.woff2","hash":"e62b834496e8808e09d69b157dd8d30767ab281d","modified":1678848337350},{"_id":"public/webfonts/fa-duotone-900.woff2","hash":"582f653eaef29d0cd2e05e104f2cb5776cb8ff43","modified":1678848337350},{"_id":"public/webfonts/fa-light-300.woff2","hash":"43e3f3b70a4a803054641c8d946b46978dfcbc23","modified":1678848337350},{"_id":"public/webfonts/fa-thin-100.woff2","hash":"90725403a3ee84c1703acbdc0e913147345e46fb","modified":1678848337350},{"_id":"public/2022/07/28/MethodologyFrontendEngineering/s0.png","hash":"111c8e192ddc0d88aa08e287a69390262ea56301","modified":1678848337350},{"_id":"public/webfonts/fa-solid-900.ttf","hash":"26722d8063ee4161197b007488dbfb0bd45d543d","modified":1678848337350},{"_id":"public/webfonts/fa-regular-400.ttf","hash":"44a016037ea5a3573ab827be35355262850678b4","modified":1678848337350},{"_id":"public/webfonts/fa-light-300.ttf","hash":"fe73f4c9149947d93fde22f82e13c4186b341b43","modified":1678848337350},{"_id":"public/webfonts/fa-thin-100.ttf","hash":"e237771f52ad4d3a041c6b9f51ca66b0811655c9","modified":1678848337350},{"_id":"public/webfonts/fa-duotone-900.ttf","hash":"6403f57a485e73326e731359cc246a7ecacf96db","modified":1678848337350},{"_id":"public/js/libs/mermaid.min.js.map","hash":"7d303cf926754817c4360f92e6c39b8c390cdbdb","modified":1678848337350},{"_id":"source/_posts/ALGSort.md","hash":"9f3656dfa1013a8c0a6441873fff9139e9f12f69","modified":1700705314182},{"_id":"source/_posts/ALGSort/sort.png","hash":"d56b4ee34471bc6000647878aa93c6c5eb0fe6df","modified":1678850258137},{"_id":"node_modules/hexo-theme-redefine/DONATION.md","hash":"e67a56561c207ece8f19d2ebbacfc4fd82aca43c","modified":1700572860095},{"_id":"node_modules/hexo-theme-redefine/scripts/dataHandle.js","hash":"3a069d3f529dceed3fd98e99d5940989f1087305","modified":1700572859258},{"_id":"node_modules/hexo-theme-redefine/languages/ja.yml","hash":"cac82dd1dbcf086a6b022e26db1202e5496477a6","modified":1700572880303},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-chinese.yml","hash":"b55c4e79ea4946318324c79b8be61a8ae16cc5c9","modified":1700572880301},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-chinese.yml","hash":"5616b1ba5ddcd91755fce55fdb6d13022e5d39c0","modified":1700572880294},{"_id":"node_modules/hexo-theme-redefine/tailwind.config.js","hash":"ea2653b0bbde6e865f3fb01f0e11700829f3ca42","modified":1700572859368},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-english.yml","hash":"e43dc9d37f8ad5cdfd12aacf6f85b71346ae6e9b","modified":1700572880302},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-english.yml","hash":"23bcdb79064f0e967258be662777c3a424140782","modified":1700572880296},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/404-template.ejs","hash":"e3574f623ea22ec3e90413909321a9a3b447f7e2","modified":1700572858991},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/home-background.ejs","hash":"1ced31279e1ff946eed8497692bd11c6b81a4b46","modified":1700572859012},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/home-content.ejs","hash":"9443d55dd5ae33350fec8181b43057b93f831604","modified":1700572859014},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/home-banner.ejs","hash":"2d8b5501eeda2dc521cb411c30ecce43ecabf3df","modified":1700572859013},{"_id":"node_modules/hexo-theme-redefine/layout/_meta/article-copyright.ejs","hash":"8e97d76ded33d1e334c376451e2f3d5fd177a958","modified":1700572858999},{"_id":"node_modules/hexo-theme-redefine/layout/_plugins/aplayer.ejs","hash":"c8f275cdbbe14b4673c69f7c1463b1f830ec8e40","modified":1700572858994},{"_id":"node_modules/hexo-theme-redefine/layout/_meta/home-article.ejs","hash":"b54a0df26341fa5f26a6e1eedb91cd11014d50c5","modified":1700572859011},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/home-sidebar.ejs","hash":"e04b6d13f7e1fff51928f4c2d2005e4d8eb7e210","modified":1700572859015},{"_id":"node_modules/hexo-theme-redefine/layout/_plugins/swup.ejs","hash":"9fbfd2872dfbe92ec715357d5238647987d8cbdf","modified":1700572859027},{"_id":"node_modules/hexo-theme-redefine/layout/_meta/article-info.ejs","hash":"1d551beb7cc47d6c841ce63a7f0f0ffb30c1770b","modified":1700572859000},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/navbar.ejs","hash":"55f072d45967fc3dc522ff8e56c8b17d9f63c964","modified":1700572859019},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/archive-list.ejs","hash":"e5a76d50661b913d2dbfd0163cf0fd83ac4ceca2","modified":1700572858996},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/image-viewer.ejs","hash":"beb3dec5e08856a29d585fe0eb94a8a6ddade4dd","modified":1700572859016},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/paginator.ejs","hash":"a237e7b858e0cf32ca67553d540f7c5f7239a8d0","modified":1700572859023},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/local-search.ejs","hash":"72c9acca0280f0e63e6a5d31618dd2707bdbec3f","modified":1700572859018},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/essays.ejs","hash":"e4332342b7dd95449c2a84edfe8323f54db6f4b5","modified":1700572859005},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/masonry.ejs","hash":"6b8ec5cff3dcf9f494b32237e6911c6e1e9dd9a1","modified":1700572859018},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/post-tools.ejs","hash":"c2d193e84e0781423ce1c018ee2be1116359d694","modified":1700572859024},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/friends-link.ejs","hash":"bacaf6f0e958fa7d9be17a59d3a8bae4b9119501","modified":1700572859007},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/progress-bar.ejs","hash":"0a9fee70154e068dc4f3e11bc378d9762d41753e","modified":1700572859024},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/encrypt.js","hash":"0daf029e7441426afcab94f5f9e1ed316e3b71f6","modified":1700572859259},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/imgHandle.js","hash":"b396fe7b6cbc331f2952aa7561f96c1f250d8c52","modified":1700572859269},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lazyloadHandle.js","hash":"f8ae44311e6463e887c07a41910ebade8766bac2","modified":1700572859273},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/linkHandle.js","hash":"7d8cb128dbfed1a4ef9b07142a63ba0c6c383628","modified":1700572859283},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/tableHandle.js","hash":"c500c45cd9221788df1f31939c5399eabb62ebb5","modified":1700572859365},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/stylHandle.js","hash":"8a8bf069ce096bd7b42952c8e50c3c89758cbc13","modified":1700572859351},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/seoGenerate.js","hash":"e0059a60cc5978be6792dcf795a2ece3a509f41a","modified":1700572859349},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/configExport.js","hash":"c1e5b36a8d8e97218c8cc1aab77ec38d5457c846","modified":1700572859257},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/themeHelpers.js","hash":"b16c8e1b494691660b0cdb972ba5110ec75a1d5a","modified":1700572859370},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/toc.ejs","hash":"46ef94dca9be59d163f6b4cba16e1695e8020bc3","modified":1700572859030},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/tagcloud.ejs","hash":"640e40c859c610ae1d97b1fac7fb39b986b9f676","modified":1700572859029},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1700572858974},{"_id":"node_modules/hexo-theme-redefine/layout/_widgets/side-tools.ejs","hash":"3b6b75a902ba673f8f0a144db63bd144d0d5b648","modified":1700572859026},{"_id":"node_modules/hexo-theme-redefine/source/fonts/fonts.css","hash":"850cf3679dfc1f5b7fe44b1377f2f85f1ec8531f","modified":1700572858971},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","hash":"7d1a13c6b8178b29f5bcb1a639a1998fc9de16c4","modified":1700572858981},{"_id":"node_modules/hexo-theme-redefine/source/fonts/ubuntu-mono-v15-latin-regular.woff","hash":"c7abad03bf081ed35bb434cb5b34b5c59c852f16","modified":1700572870460},{"_id":"node_modules/hexo-theme-redefine/source/fonts/ubuntu-mono-v15-latin-regular.woff2","hash":"e583803593916547b1101a56c216526fa2d26d1c","modified":1700572880286},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","hash":"d25389973d0359b78f1e9c74a850ef425690ba40","modified":1700572862269},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lib/hbe.default.js","hash":"fee2c92011ef007121b992193bbab0f3b196d873","modified":1700572859262},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","hash":"d0066e0b025ae748448a3d6a96165d45a55d2f22","modified":1700572862264},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","hash":"420f930a1df64a3c4391ff80326a8a2d7d5a6418","modified":1700572860171},{"_id":"node_modules/hexo-theme-redefine/source/assets/build/styles.css","hash":"ebd23770bbce29b9f93b70c2fb19fa2f794ac4dc","modified":1700572858983},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","hash":"3a63a4f1beb1462b78e41419c8c7c2ce5abf1d8c","modified":1700572860140},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","hash":"fc0e791429c274c4c9312d810e7ae9503cab34ab","modified":1700572862287},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","hash":"ac7d8777d601070e08fb262ec6d7bc97c508afa7","modified":1700572858741},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","hash":"fc5d99b40db9deca7d151f9bd16b96ff160828b7","modified":1700572870630},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.woff","hash":"d731068e2b28d4f1dfe5b4dbe8cce9c082fa8572","modified":1700572870416},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.woff2","hash":"2d34d398b398a7fd88d21fae7642cdca908bf3ee","modified":1700572880195},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.woff","hash":"e44272b921c0a14e77c640cc4cf209c4b80cb205","modified":1700572870438},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.woff2","hash":"dafa429c1d0a4b053b8fbb8c70478b8dbcb9ee9c","modified":1700572880273},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/satoshi.css","hash":"59b058f8bc9144c7799b86af728cf44dc7b3921c","modified":1700572858980},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","hash":"eb1af2cd0726f56ff7861222ea543315fe295a17","modified":1700572859252},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","hash":"a64da92a9b4dc34f424496c8e92a830b4454a0e0","modified":1700572859336},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1700572859352},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1700572859354},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1700572859243},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","hash":"40513fec1323b601667876a97a9ef8a0c88bff63","modified":1700572859877},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1700572859356},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1700572859360},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1700572859362},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","hash":"63cf04ba556b256379e103ef7d3ba12d629449a4","modified":1700572859878},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1700572859363},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1700572859335},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1700572859376},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1700572859342},{"_id":"node_modules/hexo-theme-redefine/layout/_partials/comments/giscus.ejs","hash":"5a20975c17daeed5a602dedd0682a29d7c56e42f","modified":1700572859008},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","hash":"150ceb910584ccd0b4a9558d9e2360c1409c1149","modified":1700572859240},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","hash":"92734a30a21f8b16f20aa75208f6c082890275fb","modified":1700572859290},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","hash":"01799d5c07633f33b1d2893f524054074d56ec65","modified":1700572859375},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","hash":"abd3b27238e26dc3bdd65e0e69fa514fa432a75b","modified":1700572859266},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","hash":"344e6c83e6ffda22f6e5bc724d603066b49a7d8b","modified":1700572859255},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","hash":"f2ed02b6489c601821cd257c6ffa28c25f07bdd7","modified":1700572859268},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","hash":"f6e59f65c676457198c2cf5d78bd06052499ee38","modified":1700572859285},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","hash":"33a2e97b630db736948a6b45d2d8cd18f5a5c36f","modified":1700572859373},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/aplayer.styl","hash":"f3943142b2415a0ff7c2c36729e8f8939b548222","modified":1700572860112},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","hash":"97b7e68f871dc218fceca77b85ac051c7c6306af","modified":1700572859280},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","hash":"9e54fa4310bb98ea5ba61780a9ef56d05d475203","modified":1700572859348},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/home-banner.styl","hash":"2080e21c920ced618a3c4c8a11d6a02cabb72693","modified":1700572860138},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/navbar.styl","hash":"3617a4521ef70074b540f61f076c5b60c619b309","modified":1700572860145},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.eot","hash":"2b6ff9014b62876c03d8f579bf00ffcc6ac44bd8","modified":1700572859219},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-Variable.ttf","hash":"d49872a745842f389bc9d24b73d0a3090fce50b1","modified":1700572862084},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.eot","hash":"7525ee5ad63e4bb198910286ff176587f43fc5c3","modified":1700572859231},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Satoshi/Satoshi-VariableItalic.ttf","hash":"62c34444221ff17e93a8e1cadfea5a8c68ea705b","modified":1700572862197},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","hash":"f74755d9318a86939791027767f631472b876207","modified":1700572859874},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","hash":"50a4e2ab17155fe7449e0ee488a6242180f3b256","modified":1700572859085},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","hash":"01aafadc0ca4ace59127a5594a8f534e83b84879","modified":1700572860176},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1700572859385},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","hash":"b53165275a5606f6d26bba216f4b218dcc790837","modified":1700572860104},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","hash":"74d0af1108ab8157993ca03cef80e89e35e2408d","modified":1700572873765},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","hash":"0d710cd7bd1b7ff574e88bb812de82babe45e415","modified":1700572861261},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","hash":"a58abd8799bfa9580d5835ea6a79862c059aedcd","modified":1700572860084},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-regular.woff2","hash":"eb3b3063cf2be7bd96146051168f11327f4e28d7","modified":1700572880079},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-700.woff2","hash":"3a046e40a1b2a8537a2d60db4f3b4f915852a722","modified":1700572877648},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-regular.woff","hash":"7c2e7b6873eabd4dc1fe2aee5c6d542fe8743356","modified":1700572870329},{"_id":"node_modules/hexo-theme-redefine/source/fonts/noto-sans-sc-v26-chinese-simplified-700.woff","hash":"11df5a4313f3730378dd78fcfcb444d845b389e1","modified":1700572864513},{"_id":"public/2023/02/13/ALGSort/index.html","hash":"911117bb3d52d356a44bebbbb6f5d6a4c9dabdbc","modified":1700887274169},{"_id":"public/categories/ALG/index.html","hash":"47c3d125640adefb2ee07e2d5a735b26fa971524","modified":1700661624877},{"_id":"public/tags/算法/index.html","hash":"a634013ad764a6c2b7857a5d20c6cd3a77a83882","modified":1700887274169},{"_id":"public/fonts/ubuntu-mono-v15-latin-regular.woff","hash":"c7abad03bf081ed35bb434cb5b34b5c59c852f16","modified":1700624899708},{"_id":"public/fonts/ubuntu-mono-v15-latin-regular.woff2","hash":"e583803593916547b1101a56c216526fa2d26d1c","modified":1700624899708},{"_id":"public/images/redefine-favicon.svg","hash":"420f930a1df64a3c4391ff80326a8a2d7d5a6418","modified":1700624899708},{"_id":"public/images/wallhaven-wqery6-light.webp","hash":"d25389973d0359b78f1e9c74a850ef425690ba40","modified":1700624899708},{"_id":"public/images/wallhaven-wqery6-dark.webp","hash":"d0066e0b025ae748448a3d6a96165d45a55d2f22","modified":1700624899708},{"_id":"public/fonts/Chillax/Chillax-Variable.woff","hash":"fc0e791429c274c4c9312d810e7ae9503cab34ab","modified":1700624899708},{"_id":"public/fonts/Chillax/Chillax-Variable.woff2","hash":"fc5d99b40db9deca7d151f9bd16b96ff160828b7","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-Variable.woff","hash":"d731068e2b28d4f1dfe5b4dbe8cce9c082fa8572","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-Variable.woff2","hash":"2d34d398b398a7fd88d21fae7642cdca908bf3ee","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-VariableItalic.woff2","hash":"dafa429c1d0a4b053b8fbb8c70478b8dbcb9ee9c","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-VariableItalic.woff","hash":"e44272b921c0a14e77c640cc4cf209c4b80cb205","modified":1700624899708},{"_id":"public/js/libs/SwupPreloadPlugin.min.js.map","hash":"40513fec1323b601667876a97a9ef8a0c88bff63","modified":1700624899708},{"_id":"public/js/libs/SwupScrollPlugin.min.js.map","hash":"63cf04ba556b256379e103ef7d3ba12d629449a4","modified":1700624899708},{"_id":"public/css/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1700624899708},{"_id":"public/2023/02/13/ALGSort/sort.png","hash":"d56b4ee34471bc6000647878aa93c6c5eb0fe6df","modified":1700624899708},{"_id":"public/lib/hbe.js","hash":"abd3b27238e26dc3bdd65e0e69fa514fa432a75b","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-Variable.eot","hash":"2b6ff9014b62876c03d8f579bf00ffcc6ac44bd8","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-Variable.ttf","hash":"d49872a745842f389bc9d24b73d0a3090fce50b1","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-VariableItalic.ttf","hash":"62c34444221ff17e93a8e1cadfea5a8c68ea705b","modified":1700624899708},{"_id":"public/fonts/Satoshi/Satoshi-VariableItalic.eot","hash":"7525ee5ad63e4bb198910286ff176587f43fc5c3","modified":1700624899708},{"_id":"public/js/libs/Swup.min.js.map","hash":"f74755d9318a86939791027767f631472b876207","modified":1700624899708},{"_id":"public/assets/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1700624899708},{"_id":"public/fonts/fonts.css","hash":"850cf3679dfc1f5b7fe44b1377f2f85f1ec8531f","modified":1700624899708},{"_id":"public/fontawesome/sharp-solid.min.css","hash":"7d1a13c6b8178b29f5bcb1a639a1998fc9de16c4","modified":1700624899708},{"_id":"public/css/layout/home-sidebar.css","hash":"d22a2713c9f30f66a7f873bd7e3f7d6b53403886","modified":1700624899708},{"_id":"public/fonts/Chillax/chillax.css","hash":"ac7d8777d601070e08fb262ec6d7bc97c508afa7","modified":1700624899708},{"_id":"public/fonts/Satoshi/satoshi.css","hash":"59b058f8bc9144c7799b86af728cf44dc7b3921c","modified":1700624899708},{"_id":"public/js/layouts/categoryList.js","hash":"eb1af2cd0726f56ff7861222ea543315fe295a17","modified":1700624899708},{"_id":"public/js/layouts/navbarShrink.js","hash":"a64da92a9b4dc34f424496c8e92a830b4454a0e0","modified":1700624899708},{"_id":"public/js/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1700624899708},{"_id":"public/js/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1700624899708},{"_id":"public/js/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1700624899708},{"_id":"public/js/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1700624899708},{"_id":"public/js/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1700624899708},{"_id":"public/js/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1700624899708},{"_id":"public/js/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1700624899708},{"_id":"public/js/plugins/aplayer.js","hash":"150ceb910584ccd0b4a9558d9e2360c1409c1149","modified":1700624899708},{"_id":"public/js/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1700624899708},{"_id":"public/js/plugins/masonry.js","hash":"92734a30a21f8b16f20aa75208f6c082890275fb","modified":1700624899708},{"_id":"public/js/plugins/hbe.js","hash":"abd3b27238e26dc3bdd65e0e69fa514fa432a75b","modified":1700624899708},{"_id":"public/js/plugins/typed.js","hash":"01799d5c07633f33b1d2893f524054074d56ec65","modified":1700624899708},{"_id":"public/js/tools/codeBlock.js","hash":"344e6c83e6ffda22f6e5bc724d603066b49a7d8b","modified":1700624899708},{"_id":"public/js/tools/localSearch.js","hash":"f6e59f65c676457198c2cf5d78bd06052499ee38","modified":1700624899708},{"_id":"public/js/tools/imageViewer.js","hash":"f2ed02b6489c601821cd257c6ffa28c25f07bdd7","modified":1700624899708},{"_id":"public/js/tools/tocToggle.js","hash":"33a2e97b630db736948a6b45d2d8cd18f5a5c36f","modified":1700624899708},{"_id":"public/js/tools/lightDarkSwitch.js","hash":"97b7e68f871dc218fceca77b85ac051c7c6306af","modified":1700624899708},{"_id":"public/js/tools/scrollTopBottom.js","hash":"9e54fa4310bb98ea5ba61780a9ef56d05d475203","modified":1700624899708},{"_id":"public/assets/build/styles.css","hash":"ebd23770bbce29b9f93b70c2fb19fa2f794ac4dc","modified":1700624899708},{"_id":"public/js/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1700624899708},{"_id":"public/js/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1700624899708},{"_id":"public/fonts/Chillax/Chillax-Variable.eot","hash":"50a4e2ab17155fe7449e0ee488a6242180f3b256","modified":1700624899708},{"_id":"public/fonts/Chillax/Chillax-Variable.ttf","hash":"01aafadc0ca4ace59127a5594a8f534e83b84879","modified":1700624899708},{"_id":"public/js/libs/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1700624899708},{"_id":"public/js/libs/waline.mjs","hash":"b53165275a5606f6d26bba216f4b218dcc790837","modified":1700624899708},{"_id":"public/webfonts/fa-sharp-solid-900.woff2","hash":"74d0af1108ab8157993ca03cef80e89e35e2408d","modified":1700624899708},{"_id":"public/webfonts/fa-sharp-solid-900.ttf","hash":"0d710cd7bd1b7ff574e88bb812de82babe45e415","modified":1700624899708},{"_id":"public/js/libs/waline.mjs.map","hash":"a58abd8799bfa9580d5835ea6a79862c059aedcd","modified":1700624899708},{"_id":"public/fonts/noto-sans-sc-v26-chinese-simplified-regular.woff2","hash":"eb3b3063cf2be7bd96146051168f11327f4e28d7","modified":1700624899708},{"_id":"public/fonts/noto-sans-sc-v26-chinese-simplified-700.woff2","hash":"3a046e40a1b2a8537a2d60db4f3b4f915852a722","modified":1700624899708},{"_id":"public/fonts/noto-sans-sc-v26-chinese-simplified-regular.woff","hash":"7c2e7b6873eabd4dc1fe2aee5c6d542fe8743356","modified":1700624899708},{"_id":"public/fonts/noto-sans-sc-v26-chinese-simplified-700.woff","hash":"11df5a4313f3730378dd78fcfcb444d845b389e1","modified":1700624899708},{"_id":"source/blog/.obsidian/app.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1700664076587},{"_id":"source/blog/.obsidian/hotkeys.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1700664075585},{"_id":"source/blog/.obsidian/appearance.json","hash":"9439122150a0431e432676115220bc925af96094","modified":1700664076592},{"_id":"source/blog/.obsidian/core-plugins-migration.json","hash":"688b44c61ce85d9ac421b1a310a72c1348bc9b51","modified":1700664076103},{"_id":"source/blog/.obsidian/workspace.json","hash":"fae3e006caa2f717ad0929ffe3014ca8ecf256a6","modified":1700664076651},{"_id":"source/blog/.obsidian/core-plugins.json","hash":"eb138d03157a06efdb791f441be97c256aca472c","modified":1700664076095},{"_id":"source/_posts/.obsidian/graph.json","hash":"a93bba9a59cf4c87a0b0e2242289276c8b47417f","modified":1700706013844},{"_id":"public/categories/算法/index.html","hash":"cc8ab92c7ddad62f143538d773c547123daa0ae4","modified":1700887274169}],"Category":[{"name":"API","_id":"clf92ycgs00047gh8g31sgu9q"},{"name":"方法论","_id":"clf92ycgx000c7gh81gvl9aw9"},{"name":"实践","_id":"clf92ychc000z7gh8dpq49j9g"},{"name":"转载","_id":"clf92ychg001c7gh81fs88bja"},{"name":"一些有趣的问题","_id":"clf92ycho00227gh894oj8niu"},{"name":"源码","_id":"clf92ychs002p7gh8eld8248t"},{"name":"ALG","_id":"clf946zgh0001xwh8hhnh7ad7"},{"name":"算法","_id":"clp9vmgcj0000mkh81fwifzma"}],"Data":[],"Page":[{"_content":"# ABOUT ME\n\n## `雷猴呀`\n\n这里是我的一些个人信息\n\n## 个人信息\n- 名字：严子诚\n- 手机：15388956175\n- 邮箱：zxc66war3@outlook.com\n- 微信：ped-Yc\n- github：https://github.com/ped-Yc\n- 工作年限：3年+\n\n## 教育背景\n- 毕业院校：湖南科技学院\n- 专业：信息与计算科学\n- 证书：省级数学建模大赛2等奖、CET4\n\n## 技术栈\n- 常用技术栈：Angular+RxJS，Vue+Vite，Webpack，了解过Node和Koa，但不熟练\n- 熟悉常用基础算法，leetcode题目数量100+，通过率60%\n- 对前端工程化有一定理解，撰写过文章，实现过自定义脚手架，实践过Webpack配置、包模块分析\n- 对前端可视化有一定了解，实践过ECharts来实现多图表、大屏等需求\n- 热衷于知识管理，维护项目前端域的开发wiki，独立撰写过项目前端域的新人引导文档\n- 熟悉敏捷开发、DevOps开发流程，能把握在什么时候做什么事\n- 目前专注于做一个更自律更积极的人：工作、锻炼、读书、学习算法、写博客，努力成为更好的自己\n\n## 工作经历\n- 北京易诚互动网络技术股份有限公司 2019~2020\n- 北京中软国际信息技术有限公司 2021~2022\n\n## 重点项目\n- 顺德农商银行手机app\n  - 项目介绍：顺德农商银行手机app是一个中大型的金融银行类app，项目采用大中台、小前台类架构模式，采用敏捷式开发。实现了常用金融项目的全部功能模块，例如基金、理财、风险评估、我的、贷款、取款、私人银行、安全中心等。\n  - 技术栈：ynet（vue2再封装） + mPasS（支付宝移动开发平台） + AntMobile（UI组件库）+ Webpack（打包）\n  - 参与模块：我的、基金、风险评估、理财等。\n  - 负责任务：前后端交流实现需求，贡献部分公共组件、方法，公共组件API撰写，部分Webpack配置。\n  - 难点：\n    - 1.移动端兼容性问题。难点在于定位问题，通过深入ynet框架了解到是配置的mPasS对应的webview版本太高，没做兼容性适配导致的，后来加了判断条件兼容了多种webview。通过这个问题了解npm命令工作流程，也懂得了怎样定位一个并不好定位的问题。\n    - 2.白屏时间过长问题。做了一些优化，按需引用第三方库(babel-plugin-component)，静态资源gzip压缩，对长列表组件进行了优化，改成了虚拟列表懒渲染，做了代码分割，对一些较大较老的公共方法文件进行了优化。\n\n- CloudCMDB\n  - 项目介绍：华为云资源配置管理库，该项目主要用于华为云资源的分配管理，隶属于华为云运维平台，采用DevOps开发工作流程，实现的功能有：标签管理、告警管理、配置管理、系统管理、权限管理、Agent管理、前端监控等。\n  - 技术栈：AngularJS(重构前)、Angular(重构后) + 华为Console框架（提供公共服务和视图） + TinyUI(UI组件库) + Webpack（打包）\n  - 负责任务：重构前代码开发维护、项目重构、新人引导文档撰写、部分公共组件、方法、指令、装饰器编写，少量大屏需求，首屏优化（埋点、重构）。\n  - 难点：\n    - 1.重构初期的选型与实施。因为是第一次做重构，先期有许多要点搞不清楚，怎样保证原有功能的完整性并且构建一个健壮的可维护项目是一个难题，另外旧项目代码量巨大，旧版本AngularJS许多公共方法和组件重叠在一起，要抽离哪些可用方法和组件，删除或重构哪些方法和组件都需要抉择。解决方案是回顾先期需求、要求后端更新完整的API文档、组件和方法遵从由大粒度到小粒度的重构原则，先期约定好代码规范、提交规范，优先抽离全局组件和方法，约定好代码模板和指令装饰器编写方式等等。\n    - 2.首屏优化和不常用功能剥离，主要做的有组件懒加载、本地缓存、通过Webpack Bundle Analyzer分析优化不需要的库和代码（Angular本身会做tree shaking）,使用AoT编译，业务逻辑分离减少首屏http请求等。\n\n\n\n\n## 兴趣爱好\n- 游戏：DOTA2（万古水平）、魂系、ACT类（战神、鬼泣）、魔兽骨灰玩家、解谜类\n- 运动：晚跑、足球（好久没踢了）\n- 音乐：喜欢陈奕迅、张学友、毛不易\n- 读书：喜欢社科类、历史类，喜欢战国策、古文观止，喜欢李白、辛弃疾\n- 编程：前端程序员，喜欢Vue、Typescript，对后端真不熟\n- 其他：对摄影有兴趣，不过还没开始，会一点点口琴，和不会也差不多\n\n## `那就这样咯`\n\n差不多就这样、囧","source":"about/index.md","raw":"# ABOUT ME\n\n## `雷猴呀`\n\n这里是我的一些个人信息\n\n## 个人信息\n- 名字：严子诚\n- 手机：15388956175\n- 邮箱：zxc66war3@outlook.com\n- 微信：ped-Yc\n- github：https://github.com/ped-Yc\n- 工作年限：3年+\n\n## 教育背景\n- 毕业院校：湖南科技学院\n- 专业：信息与计算科学\n- 证书：省级数学建模大赛2等奖、CET4\n\n## 技术栈\n- 常用技术栈：Angular+RxJS，Vue+Vite，Webpack，了解过Node和Koa，但不熟练\n- 熟悉常用基础算法，leetcode题目数量100+，通过率60%\n- 对前端工程化有一定理解，撰写过文章，实现过自定义脚手架，实践过Webpack配置、包模块分析\n- 对前端可视化有一定了解，实践过ECharts来实现多图表、大屏等需求\n- 热衷于知识管理，维护项目前端域的开发wiki，独立撰写过项目前端域的新人引导文档\n- 熟悉敏捷开发、DevOps开发流程，能把握在什么时候做什么事\n- 目前专注于做一个更自律更积极的人：工作、锻炼、读书、学习算法、写博客，努力成为更好的自己\n\n## 工作经历\n- 北京易诚互动网络技术股份有限公司 2019~2020\n- 北京中软国际信息技术有限公司 2021~2022\n\n## 重点项目\n- 顺德农商银行手机app\n  - 项目介绍：顺德农商银行手机app是一个中大型的金融银行类app，项目采用大中台、小前台类架构模式，采用敏捷式开发。实现了常用金融项目的全部功能模块，例如基金、理财、风险评估、我的、贷款、取款、私人银行、安全中心等。\n  - 技术栈：ynet（vue2再封装） + mPasS（支付宝移动开发平台） + AntMobile（UI组件库）+ Webpack（打包）\n  - 参与模块：我的、基金、风险评估、理财等。\n  - 负责任务：前后端交流实现需求，贡献部分公共组件、方法，公共组件API撰写，部分Webpack配置。\n  - 难点：\n    - 1.移动端兼容性问题。难点在于定位问题，通过深入ynet框架了解到是配置的mPasS对应的webview版本太高，没做兼容性适配导致的，后来加了判断条件兼容了多种webview。通过这个问题了解npm命令工作流程，也懂得了怎样定位一个并不好定位的问题。\n    - 2.白屏时间过长问题。做了一些优化，按需引用第三方库(babel-plugin-component)，静态资源gzip压缩，对长列表组件进行了优化，改成了虚拟列表懒渲染，做了代码分割，对一些较大较老的公共方法文件进行了优化。\n\n- CloudCMDB\n  - 项目介绍：华为云资源配置管理库，该项目主要用于华为云资源的分配管理，隶属于华为云运维平台，采用DevOps开发工作流程，实现的功能有：标签管理、告警管理、配置管理、系统管理、权限管理、Agent管理、前端监控等。\n  - 技术栈：AngularJS(重构前)、Angular(重构后) + 华为Console框架（提供公共服务和视图） + TinyUI(UI组件库) + Webpack（打包）\n  - 负责任务：重构前代码开发维护、项目重构、新人引导文档撰写、部分公共组件、方法、指令、装饰器编写，少量大屏需求，首屏优化（埋点、重构）。\n  - 难点：\n    - 1.重构初期的选型与实施。因为是第一次做重构，先期有许多要点搞不清楚，怎样保证原有功能的完整性并且构建一个健壮的可维护项目是一个难题，另外旧项目代码量巨大，旧版本AngularJS许多公共方法和组件重叠在一起，要抽离哪些可用方法和组件，删除或重构哪些方法和组件都需要抉择。解决方案是回顾先期需求、要求后端更新完整的API文档、组件和方法遵从由大粒度到小粒度的重构原则，先期约定好代码规范、提交规范，优先抽离全局组件和方法，约定好代码模板和指令装饰器编写方式等等。\n    - 2.首屏优化和不常用功能剥离，主要做的有组件懒加载、本地缓存、通过Webpack Bundle Analyzer分析优化不需要的库和代码（Angular本身会做tree shaking）,使用AoT编译，业务逻辑分离减少首屏http请求等。\n\n\n\n\n## 兴趣爱好\n- 游戏：DOTA2（万古水平）、魂系、ACT类（战神、鬼泣）、魔兽骨灰玩家、解谜类\n- 运动：晚跑、足球（好久没踢了）\n- 音乐：喜欢陈奕迅、张学友、毛不易\n- 读书：喜欢社科类、历史类，喜欢战国策、古文观止，喜欢李白、辛弃疾\n- 编程：前端程序员，喜欢Vue、Typescript，对后端真不熟\n- 其他：对摄影有兴趣，不过还没开始，会一点点口琴，和不会也差不多\n\n## `那就这样咯`\n\n差不多就这样、囧","date":"2023-03-06T10:05:01.820Z","updated":"2023-03-06T10:05:01.820Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"clf92ycgl00007gh8g51tckf4","content":"<h1 id=\"ABOUT-ME\"><a href=\"#ABOUT-ME\" class=\"headerlink\" title=\"ABOUT ME\"></a>ABOUT ME</h1><h2 id=\"雷猴呀\"><a href=\"#雷猴呀\" class=\"headerlink\" title=\"雷猴呀\"></a><code>雷猴呀</code></h2><p>这里是我的一些个人信息</p>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>名字：严子诚</li>\n<li>手机：15388956175</li>\n<li>邮箱：<a class=\"link\"   href=\"mailto:&#122;&#x78;&#x63;&#54;&#x36;&#119;&#97;&#114;&#51;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#x6f;&#x6b;&#46;&#99;&#x6f;&#x6d;\" >&#122;&#x78;&#x63;&#54;&#x36;&#119;&#97;&#114;&#51;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#x6f;&#x6b;&#46;&#99;&#x6f;&#x6d; <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li>微信：ped-Yc</li>\n<li>github：<a class=\"link\"   href=\"https://github.com/ped-Yc\" >https://github.com/ped-Yc <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li>工作年限：3年+</li>\n</ul>\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li>毕业院校：湖南科技学院</li>\n<li>专业：信息与计算科学</li>\n<li>证书：省级数学建模大赛2等奖、CET4</li>\n</ul>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><ul>\n<li>常用技术栈：Angular+RxJS，Vue+Vite，Webpack，了解过Node和Koa，但不熟练</li>\n<li>熟悉常用基础算法，leetcode题目数量100+，通过率60%</li>\n<li>对前端工程化有一定理解，撰写过文章，实现过自定义脚手架，实践过Webpack配置、包模块分析</li>\n<li>对前端可视化有一定了解，实践过ECharts来实现多图表、大屏等需求</li>\n<li>热衷于知识管理，维护项目前端域的开发wiki，独立撰写过项目前端域的新人引导文档</li>\n<li>熟悉敏捷开发、DevOps开发流程，能把握在什么时候做什么事</li>\n<li>目前专注于做一个更自律更积极的人：工作、锻炼、读书、学习算法、写博客，努力成为更好的自己</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li>北京易诚互动网络技术股份有限公司 2019~2020</li>\n<li>北京中软国际信息技术有限公司 2021~2022</li>\n</ul>\n<h2 id=\"重点项目\"><a href=\"#重点项目\" class=\"headerlink\" title=\"重点项目\"></a>重点项目</h2><ul>\n<li><p>顺德农商银行手机app</p>\n<ul>\n<li>项目介绍：顺德农商银行手机app是一个中大型的金融银行类app，项目采用大中台、小前台类架构模式，采用敏捷式开发。实现了常用金融项目的全部功能模块，例如基金、理财、风险评估、我的、贷款、取款、私人银行、安全中心等。</li>\n<li>技术栈：ynet（vue2再封装） + mPasS（支付宝移动开发平台） + AntMobile（UI组件库）+ Webpack（打包）</li>\n<li>参与模块：我的、基金、风险评估、理财等。</li>\n<li>负责任务：前后端交流实现需求，贡献部分公共组件、方法，公共组件API撰写，部分Webpack配置。</li>\n<li>难点：<ul>\n<li>1.移动端兼容性问题。难点在于定位问题，通过深入ynet框架了解到是配置的mPasS对应的webview版本太高，没做兼容性适配导致的，后来加了判断条件兼容了多种webview。通过这个问题了解npm命令工作流程，也懂得了怎样定位一个并不好定位的问题。</li>\n<li>2.白屏时间过长问题。做了一些优化，按需引用第三方库(babel-plugin-component)，静态资源gzip压缩，对长列表组件进行了优化，改成了虚拟列表懒渲染，做了代码分割，对一些较大较老的公共方法文件进行了优化。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CloudCMDB</p>\n<ul>\n<li>项目介绍：华为云资源配置管理库，该项目主要用于华为云资源的分配管理，隶属于华为云运维平台，采用DevOps开发工作流程，实现的功能有：标签管理、告警管理、配置管理、系统管理、权限管理、Agent管理、前端监控等。</li>\n<li>技术栈：AngularJS(重构前)、Angular(重构后) + 华为Console框架（提供公共服务和视图） + TinyUI(UI组件库) + Webpack（打包）</li>\n<li>负责任务：重构前代码开发维护、项目重构、新人引导文档撰写、部分公共组件、方法、指令、装饰器编写，少量大屏需求，首屏优化（埋点、重构）。</li>\n<li>难点：<ul>\n<li>1.重构初期的选型与实施。因为是第一次做重构，先期有许多要点搞不清楚，怎样保证原有功能的完整性并且构建一个健壮的可维护项目是一个难题，另外旧项目代码量巨大，旧版本AngularJS许多公共方法和组件重叠在一起，要抽离哪些可用方法和组件，删除或重构哪些方法和组件都需要抉择。解决方案是回顾先期需求、要求后端更新完整的API文档、组件和方法遵从由大粒度到小粒度的重构原则，先期约定好代码规范、提交规范，优先抽离全局组件和方法，约定好代码模板和指令装饰器编写方式等等。</li>\n<li>2.首屏优化和不常用功能剥离，主要做的有组件懒加载、本地缓存、通过Webpack Bundle Analyzer分析优化不需要的库和代码（Angular本身会做tree shaking）,使用AoT编译，业务逻辑分离减少首屏http请求等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>游戏：DOTA2（万古水平）、魂系、ACT类（战神、鬼泣）、魔兽骨灰玩家、解谜类</li>\n<li>运动：晚跑、足球（好久没踢了）</li>\n<li>音乐：喜欢陈奕迅、张学友、毛不易</li>\n<li>读书：喜欢社科类、历史类，喜欢战国策、古文观止，喜欢李白、辛弃疾</li>\n<li>编程：前端程序员，喜欢Vue、Typescript，对后端真不熟</li>\n<li>其他：对摄影有兴趣，不过还没开始，会一点点口琴，和不会也差不多</li>\n</ul>\n<h2 id=\"那就这样咯\"><a href=\"#那就这样咯\" class=\"headerlink\" title=\"那就这样咯\"></a><code>那就这样咯</code></h2><p>差不多就这样、囧</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ABOUT-ME\"><a href=\"#ABOUT-ME\" class=\"headerlink\" title=\"ABOUT ME\"></a>ABOUT ME</h1><h2 id=\"雷猴呀\"><a href=\"#雷猴呀\" class=\"headerlink\" title=\"雷猴呀\"></a><code>雷猴呀</code></h2><p>这里是我的一些个人信息</p>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>名字：严子诚</li>\n<li>手机：15388956175</li>\n<li>邮箱：<a class=\"link\"   href=\"mailto:&#122;&#x78;&#x63;&#54;&#x36;&#119;&#97;&#114;&#51;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#x6f;&#x6b;&#46;&#99;&#x6f;&#x6d;\" >&#122;&#x78;&#x63;&#54;&#x36;&#119;&#97;&#114;&#51;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#x6f;&#x6b;&#46;&#99;&#x6f;&#x6d; <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li>微信：ped-Yc</li>\n<li>github：<a class=\"link\"   href=\"https://github.com/ped-Yc\" >https://github.com/ped-Yc <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li>工作年限：3年+</li>\n</ul>\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><ul>\n<li>毕业院校：湖南科技学院</li>\n<li>专业：信息与计算科学</li>\n<li>证书：省级数学建模大赛2等奖、CET4</li>\n</ul>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><ul>\n<li>常用技术栈：Angular+RxJS，Vue+Vite，Webpack，了解过Node和Koa，但不熟练</li>\n<li>熟悉常用基础算法，leetcode题目数量100+，通过率60%</li>\n<li>对前端工程化有一定理解，撰写过文章，实现过自定义脚手架，实践过Webpack配置、包模块分析</li>\n<li>对前端可视化有一定了解，实践过ECharts来实现多图表、大屏等需求</li>\n<li>热衷于知识管理，维护项目前端域的开发wiki，独立撰写过项目前端域的新人引导文档</li>\n<li>熟悉敏捷开发、DevOps开发流程，能把握在什么时候做什么事</li>\n<li>目前专注于做一个更自律更积极的人：工作、锻炼、读书、学习算法、写博客，努力成为更好的自己</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li>北京易诚互动网络技术股份有限公司 2019~2020</li>\n<li>北京中软国际信息技术有限公司 2021~2022</li>\n</ul>\n<h2 id=\"重点项目\"><a href=\"#重点项目\" class=\"headerlink\" title=\"重点项目\"></a>重点项目</h2><ul>\n<li><p>顺德农商银行手机app</p>\n<ul>\n<li>项目介绍：顺德农商银行手机app是一个中大型的金融银行类app，项目采用大中台、小前台类架构模式，采用敏捷式开发。实现了常用金融项目的全部功能模块，例如基金、理财、风险评估、我的、贷款、取款、私人银行、安全中心等。</li>\n<li>技术栈：ynet（vue2再封装） + mPasS（支付宝移动开发平台） + AntMobile（UI组件库）+ Webpack（打包）</li>\n<li>参与模块：我的、基金、风险评估、理财等。</li>\n<li>负责任务：前后端交流实现需求，贡献部分公共组件、方法，公共组件API撰写，部分Webpack配置。</li>\n<li>难点：<ul>\n<li>1.移动端兼容性问题。难点在于定位问题，通过深入ynet框架了解到是配置的mPasS对应的webview版本太高，没做兼容性适配导致的，后来加了判断条件兼容了多种webview。通过这个问题了解npm命令工作流程，也懂得了怎样定位一个并不好定位的问题。</li>\n<li>2.白屏时间过长问题。做了一些优化，按需引用第三方库(babel-plugin-component)，静态资源gzip压缩，对长列表组件进行了优化，改成了虚拟列表懒渲染，做了代码分割，对一些较大较老的公共方法文件进行了优化。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CloudCMDB</p>\n<ul>\n<li>项目介绍：华为云资源配置管理库，该项目主要用于华为云资源的分配管理，隶属于华为云运维平台，采用DevOps开发工作流程，实现的功能有：标签管理、告警管理、配置管理、系统管理、权限管理、Agent管理、前端监控等。</li>\n<li>技术栈：AngularJS(重构前)、Angular(重构后) + 华为Console框架（提供公共服务和视图） + TinyUI(UI组件库) + Webpack（打包）</li>\n<li>负责任务：重构前代码开发维护、项目重构、新人引导文档撰写、部分公共组件、方法、指令、装饰器编写，少量大屏需求，首屏优化（埋点、重构）。</li>\n<li>难点：<ul>\n<li>1.重构初期的选型与实施。因为是第一次做重构，先期有许多要点搞不清楚，怎样保证原有功能的完整性并且构建一个健壮的可维护项目是一个难题，另外旧项目代码量巨大，旧版本AngularJS许多公共方法和组件重叠在一起，要抽离哪些可用方法和组件，删除或重构哪些方法和组件都需要抉择。解决方案是回顾先期需求、要求后端更新完整的API文档、组件和方法遵从由大粒度到小粒度的重构原则，先期约定好代码规范、提交规范，优先抽离全局组件和方法，约定好代码模板和指令装饰器编写方式等等。</li>\n<li>2.首屏优化和不常用功能剥离，主要做的有组件懒加载、本地缓存、通过Webpack Bundle Analyzer分析优化不需要的库和代码（Angular本身会做tree shaking）,使用AoT编译，业务逻辑分离减少首屏http请求等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>游戏：DOTA2（万古水平）、魂系、ACT类（战神、鬼泣）、魔兽骨灰玩家、解谜类</li>\n<li>运动：晚跑、足球（好久没踢了）</li>\n<li>音乐：喜欢陈奕迅、张学友、毛不易</li>\n<li>读书：喜欢社科类、历史类，喜欢战国策、古文观止，喜欢李白、辛弃疾</li>\n<li>编程：前端程序员，喜欢Vue、Typescript，对后端真不熟</li>\n<li>其他：对摄影有兴趣，不过还没开始，会一点点口琴，和不会也差不多</li>\n</ul>\n<h2 id=\"那就这样咯\"><a href=\"#那就这样咯\" class=\"headerlink\" title=\"那就这样咯\"></a><code>那就这样咯</code></h2><p>差不多就这样、囧</p>\n"},{"_content":"const editBtn = document.querySelector(\".edit\")\nconst statement = document.querySelector(\".statement .title\")\nconst detail = document.querySelector(\".statement .detail\")\nconst updateTime = document.querySelector(\"#updateTime\")\n\nconsole.log(updateTime);\nupdateTime.innerHTML=`2022-7-13`\neditBtn.onclick = function () {\n  if (document.designMode === \"off\") {\n    document.designMode = \"on\"\n    this.className = \"btn2 onEdit\"\n    this.innerText = \"退出编辑\"\n  } else {\n    document.designMode = \"off\"\n    this.className = \"btn2 edit\"\n    this.innerText = \"编辑\"\n  }\n\n}\n\n// statement.onclick = function () {\n//   detail.classList.toggle('hidden');\n// }\n\n// import htmlToPdf from './utils/htmlToPdf'\n// console.log(htmlToPdf);","source":"cv/index.js","raw":"const editBtn = document.querySelector(\".edit\")\nconst statement = document.querySelector(\".statement .title\")\nconst detail = document.querySelector(\".statement .detail\")\nconst updateTime = document.querySelector(\"#updateTime\")\n\nconsole.log(updateTime);\nupdateTime.innerHTML=`2022-7-13`\neditBtn.onclick = function () {\n  if (document.designMode === \"off\") {\n    document.designMode = \"on\"\n    this.className = \"btn2 onEdit\"\n    this.innerText = \"退出编辑\"\n  } else {\n    document.designMode = \"off\"\n    this.className = \"btn2 edit\"\n    this.innerText = \"编辑\"\n  }\n\n}\n\n// statement.onclick = function () {\n//   detail.classList.toggle('hidden');\n// }\n\n// import htmlToPdf from './utils/htmlToPdf'\n// console.log(htmlToPdf);","date":"2023-03-02T12:10:42.202Z","updated":"2023-03-02T12:10:42.202Z","path":"cv/index.js","layout":"false","title":"","comments":1,"_id":"clf92ycgq00027gh8d3sqcfkb","content":"const editBtn = document.querySelector(\".edit\")\nconst statement = document.querySelector(\".statement .title\")\nconst detail = document.querySelector(\".statement .detail\")\nconst updateTime = document.querySelector(\"#updateTime\")\n\nconsole.log(updateTime);\nupdateTime.innerHTML=`2022-7-13`\neditBtn.onclick = function () {\n  if (document.designMode === \"off\") {\n    document.designMode = \"on\"\n    this.className = \"btn2 onEdit\"\n    this.innerText = \"退出编辑\"\n  } else {\n    document.designMode = \"off\"\n    this.className = \"btn2 edit\"\n    this.innerText = \"编辑\"\n  }\n\n}\n\n// statement.onclick = function () {\n//   detail.classList.toggle('hidden');\n// }\n\n// import htmlToPdf from './utils/htmlToPdf'\n// console.log(htmlToPdf);","site":{"data":{}},"excerpt":"","more":"const editBtn = document.querySelector(\".edit\")\nconst statement = document.querySelector(\".statement .title\")\nconst detail = document.querySelector(\".statement .detail\")\nconst updateTime = document.querySelector(\"#updateTime\")\n\nconsole.log(updateTime);\nupdateTime.innerHTML=`2022-7-13`\neditBtn.onclick = function () {\n  if (document.designMode === \"off\") {\n    document.designMode = \"on\"\n    this.className = \"btn2 onEdit\"\n    this.innerText = \"退出编辑\"\n  } else {\n    document.designMode = \"off\"\n    this.className = \"btn2 edit\"\n    this.innerText = \"编辑\"\n  }\n\n}\n\n// statement.onclick = function () {\n//   detail.classList.toggle('hidden');\n// }\n\n// import htmlToPdf from './utils/htmlToPdf'\n// console.log(htmlToPdf);"},{"title":"tags","date":"2023-01-31T18:28:27.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-02-01 02:28:27\n---\n","updated":"2023-01-31T18:28:27.535Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clf92ycgu00067gh88mp18bsp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2023-01-31T19:23:07.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-02-01 03:23:07\n---\n","updated":"2023-01-31T19:23:07.768Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clf92ycgv00087gh88s2u2yia","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>简历</title>\n</head>\n\n<body>\n  <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n  <div id=\"app\">{{ message }}</div>\n\n  <script>\n    const { createApp } = Vue\n\n    createApp({\n      data() {\n        return {\n          message: 'Hello Vue!'\n        }\n      }\n    }).mount('#app')\n  </script>\n\n</body>\n\n</html>","source":"cv/index.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>简历</title>\n</head>\n\n<body>\n  <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n  <div id=\"app\">{{ message }}</div>\n\n  <script>\n    const { createApp } = Vue\n\n    createApp({\n      data() {\n        return {\n          message: 'Hello Vue!'\n        }\n      }\n    }).mount('#app')\n  </script>\n\n</body>\n\n</html>","date":"2023-03-01T09:10:11.178Z","updated":"2023-03-01T09:10:11.178Z","path":"cv/index.html","title":"","comments":1,"layout":"page","_id":"clf92ycgw000a7gh80lkd8quj","content":"<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>简历</title>\n</head>\n\n<body>\n  <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n  <div id=\"app\"></div>\n\n  <script>\n    const { createApp } = Vue\n\n    createApp({\n      data() {\n        return {\n          message: 'Hello Vue!'\n        }\n      }\n    }).mount('#app')\n  </script>\n\n</body>\n\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>简历</title>\n</head>\n\n<body>\n  <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n  <div id=\"app\"></div>\n\n  <script>\n    const { createApp } = Vue\n\n    createApp({\n      data() {\n        return {\n          message: 'Hello Vue!'\n        }\n      }\n    }).mount('#app')\n  </script>\n\n</body>\n\n</html>"}],"Post":[{"title":"【API】MutationObserver","date":"2023-01-11T01:30:57.000Z","_content":"\n在使用第三方库时，常用需求之一是在 DOM 元素创建时注册一个时间监听器或 DOM 元素删除时注销事件监听器，但我们难以知道具体 DOM 元素的创建时间、删除时间，所以一般的实现方式是使用轮询的方法，判断 DOM 元素是否存在，如果存在则继续逻辑，这种轮询的方式也可以用 Promise 优化一下改成异步执行。但即使如此也仍有不小的额外开销，而 MutationObserver 提供了一种原生的检测方式。\n\n## [MutationObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)\n> `MutationObserver` 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。\n\n## 构造函数\n\nMutationObserver()\n\n语法：\n```javascript\n// 创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。\nvar observer = new MutationObserver(callback);\n\nfunction callback(mutationList, observer) {\n  mutationList.forEach((mutation) => {\n    switch(mutation.type) {\n      case 'childList':\n        /* 从树上添加或移除一个或更多的子节点；参见 mutation.addedNodes 与\n           mutation.removedNodes */\n        break;\n      case 'attributes':\n        /* mutation.target 中某节点的一个属性值被更改；该属性名称在 mutation.attributeName 中，\n           该属性之前的值为 mutation.oldValue */\n        break;\n    }\n  });\n}\n```\n- callback\n  - 一个回调函数，每当被指定的节点或子树以及配置项有 DOM 变动时会被调用。回调函数拥有两个参数：一个是描述所有被触发改动的 `MutationRecord` 对象数组，另一个是调用该函数的 MutationObserver 对象。参见下方的示例了解更多细节\n  - [MutationRecord](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord)\n    - MutationRecord.type\n    - MutationRecord.target\n    - MutationRecord.addedNodes\n    - MutationRecord.removedNodes\n    - MutationRecord.previousSibling\n    - MutationRecord.nextSibling\n    - MutationRecord.attributeName\n    - MutationRecord.attributeNamespace\n    - MutationRecord.oldValue\n- return\n  - 一个新的、包含监听 DOM 变化回调函数的 MutationObserver 对象。\n\n## 方法\n- disconnect：阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe() 方法，该观察者对象包含的回调函数都不会再被调用。\n- [observe](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe)：配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。\n  - target：DOM 树中的一个要观察变化的 DOM Node (可能是一个 Element)，或者是被观察的子节点树的根节点。\n  - options：此对象的配置项描述了 DOM 的哪些变化应该报告给 MutationObserver 的 callback。当调用 observe() 时，childList、attributes 和 characterData 中，必须有一个参数为 true。否则会抛出 TypeError 异常。\n- takeRecords：从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。\n\n## 示例\n```javascript\n // 选择需要观察变动的节点\nconst targetNode = document.getElementById('some-id');\n\n// 观察器的配置（需要观察什么变动）\nconst config = { attributes: true, childList: true, subtree: true };\n\n// 当观察到变动时执行的回调函数\nconst callback = function(mutationsList, observer) {\n    // Use traditional 'for loops' for IE 11\n    for(let mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n            console.log('A child node has been added or removed.');\n        }\n        else if (mutation.type === 'attributes') {\n            console.log('The ' + mutation.attributeName + ' attribute was modified.');\n        }\n    }\n};\n\n// 创建一个观察器实例并传入回调函数\nconst observer = new MutationObserver(callback);\n\n// 以上述配置开始观察目标节点\nobserver.observe(targetNode, config);\n\n// 之后，可停止观察\nobserver.disconnect();\n```","source":"_posts/APIMutationObserver.md","raw":"---\ntitle: 【API】MutationObserver\ndate: 2023-01-11 09:30:57\ntags: [JS]\ncategories: [API]\n---\n\n在使用第三方库时，常用需求之一是在 DOM 元素创建时注册一个时间监听器或 DOM 元素删除时注销事件监听器，但我们难以知道具体 DOM 元素的创建时间、删除时间，所以一般的实现方式是使用轮询的方法，判断 DOM 元素是否存在，如果存在则继续逻辑，这种轮询的方式也可以用 Promise 优化一下改成异步执行。但即使如此也仍有不小的额外开销，而 MutationObserver 提供了一种原生的检测方式。\n\n## [MutationObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)\n> `MutationObserver` 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。\n\n## 构造函数\n\nMutationObserver()\n\n语法：\n```javascript\n// 创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。\nvar observer = new MutationObserver(callback);\n\nfunction callback(mutationList, observer) {\n  mutationList.forEach((mutation) => {\n    switch(mutation.type) {\n      case 'childList':\n        /* 从树上添加或移除一个或更多的子节点；参见 mutation.addedNodes 与\n           mutation.removedNodes */\n        break;\n      case 'attributes':\n        /* mutation.target 中某节点的一个属性值被更改；该属性名称在 mutation.attributeName 中，\n           该属性之前的值为 mutation.oldValue */\n        break;\n    }\n  });\n}\n```\n- callback\n  - 一个回调函数，每当被指定的节点或子树以及配置项有 DOM 变动时会被调用。回调函数拥有两个参数：一个是描述所有被触发改动的 `MutationRecord` 对象数组，另一个是调用该函数的 MutationObserver 对象。参见下方的示例了解更多细节\n  - [MutationRecord](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord)\n    - MutationRecord.type\n    - MutationRecord.target\n    - MutationRecord.addedNodes\n    - MutationRecord.removedNodes\n    - MutationRecord.previousSibling\n    - MutationRecord.nextSibling\n    - MutationRecord.attributeName\n    - MutationRecord.attributeNamespace\n    - MutationRecord.oldValue\n- return\n  - 一个新的、包含监听 DOM 变化回调函数的 MutationObserver 对象。\n\n## 方法\n- disconnect：阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe() 方法，该观察者对象包含的回调函数都不会再被调用。\n- [observe](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe)：配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。\n  - target：DOM 树中的一个要观察变化的 DOM Node (可能是一个 Element)，或者是被观察的子节点树的根节点。\n  - options：此对象的配置项描述了 DOM 的哪些变化应该报告给 MutationObserver 的 callback。当调用 observe() 时，childList、attributes 和 characterData 中，必须有一个参数为 true。否则会抛出 TypeError 异常。\n- takeRecords：从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。\n\n## 示例\n```javascript\n // 选择需要观察变动的节点\nconst targetNode = document.getElementById('some-id');\n\n// 观察器的配置（需要观察什么变动）\nconst config = { attributes: true, childList: true, subtree: true };\n\n// 当观察到变动时执行的回调函数\nconst callback = function(mutationsList, observer) {\n    // Use traditional 'for loops' for IE 11\n    for(let mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n            console.log('A child node has been added or removed.');\n        }\n        else if (mutation.type === 'attributes') {\n            console.log('The ' + mutation.attributeName + ' attribute was modified.');\n        }\n    }\n};\n\n// 创建一个观察器实例并传入回调函数\nconst observer = new MutationObserver(callback);\n\n// 以上述配置开始观察目标节点\nobserver.observe(targetNode, config);\n\n// 之后，可停止观察\nobserver.disconnect();\n```","slug":"APIMutationObserver","published":1,"updated":"2023-03-09T05:00:25.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ycgo00017gh88oc5fjzm","content":"<p>在使用第三方库时，常用需求之一是在 DOM 元素创建时注册一个时间监听器或 DOM 元素删除时注销事件监听器，但我们难以知道具体 DOM 元素的创建时间、删除时间，所以一般的实现方式是使用轮询的方法，判断 DOM 元素是否存在，如果存在则继续逻辑，这种轮询的方式也可以用 Promise 优化一下改成异步执行。但即使如此也仍有不小的额外开销，而 MutationObserver 提供了一种原生的检测方式。</p>\n<h2 id=\"MutationObserver\"><a href=\"#MutationObserver\" class=\"headerlink\" title=\"MutationObserver\"></a><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\" >MutationObserver <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></h2><blockquote>\n<p><code>MutationObserver</code> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>\n</blockquote>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>MutationObserver()</p>\n<p>语法：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(callback);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">callback</span>(<span class=\"params\">mutationList, observer</span>) &#123;</span><br><span class=\"line\">  mutationList.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">mutation</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(mutation.<span class=\"property\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;childList&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\">/* 从树上添加或移除一个或更多的子节点；参见 mutation.addedNodes 与</span></span><br><span class=\"line\"><span class=\"comment\">           mutation.removedNodes */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;attributes&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\">/* mutation.target 中某节点的一个属性值被更改；该属性名称在 mutation.attributeName 中，</span></span><br><span class=\"line\"><span class=\"comment\">           该属性之前的值为 mutation.oldValue */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>callback<ul>\n<li>一个回调函数，每当被指定的节点或子树以及配置项有 DOM 变动时会被调用。回调函数拥有两个参数：一个是描述所有被触发改动的 <code>MutationRecord</code> 对象数组，另一个是调用该函数的 MutationObserver 对象。参见下方的示例了解更多细节</li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord\" >MutationRecord <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a><ul>\n<li>MutationRecord.type</li>\n<li>MutationRecord.target</li>\n<li>MutationRecord.addedNodes</li>\n<li>MutationRecord.removedNodes</li>\n<li>MutationRecord.previousSibling</li>\n<li>MutationRecord.nextSibling</li>\n<li>MutationRecord.attributeName</li>\n<li>MutationRecord.attributeNamespace</li>\n<li>MutationRecord.oldValue</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>return<ul>\n<li>一个新的、包含监听 DOM 变化回调函数的 MutationObserver 对象。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ul>\n<li>disconnect：阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe() 方法，该观察者对象包含的回调函数都不会再被调用。</li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe\" >observe <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>：配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。<ul>\n<li>target：DOM 树中的一个要观察变化的 DOM Node (可能是一个 Element)，或者是被观察的子节点树的根节点。</li>\n<li>options：此对象的配置项描述了 DOM 的哪些变化应该报告给 MutationObserver 的 callback。当调用 observe() 时，childList、attributes 和 characterData 中，必须有一个参数为 true。否则会抛出 TypeError 异常。</li>\n</ul>\n</li>\n<li>takeRecords：从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 选择需要观察变动的节点</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetNode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;some-id&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 观察器的配置（需要观察什么变动）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123; <span class=\"attr\">attributes</span>: <span class=\"literal\">true</span>, <span class=\"attr\">childList</span>: <span class=\"literal\">true</span>, <span class=\"attr\">subtree</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当观察到变动时执行的回调函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> callback = <span class=\"keyword\">function</span>(<span class=\"params\">mutationsList, observer</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use traditional &#x27;for loops&#x27; for IE 11</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> mutation <span class=\"keyword\">of</span> mutationsList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;childList&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;A child node has been added or removed.&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;attributes&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;The &#x27;</span> + mutation.<span class=\"property\">attributeName</span> + <span class=\"string\">&#x27; attribute was modified.&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个观察器实例并传入回调函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(callback);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上述配置开始观察目标节点</span></span><br><span class=\"line\">observer.<span class=\"title function_\">observe</span>(targetNode, config);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 之后，可停止观察</span></span><br><span class=\"line\">observer.<span class=\"title function_\">disconnect</span>();</span><br></pre></td></tr></table></figure></div>","site":{"data":{}},"excerpt":"","more":"<p>在使用第三方库时，常用需求之一是在 DOM 元素创建时注册一个时间监听器或 DOM 元素删除时注销事件监听器，但我们难以知道具体 DOM 元素的创建时间、删除时间，所以一般的实现方式是使用轮询的方法，判断 DOM 元素是否存在，如果存在则继续逻辑，这种轮询的方式也可以用 Promise 优化一下改成异步执行。但即使如此也仍有不小的额外开销，而 MutationObserver 提供了一种原生的检测方式。</p>\n<h2 id=\"MutationObserver\"><a href=\"#MutationObserver\" class=\"headerlink\" title=\"MutationObserver\"></a><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\" >MutationObserver <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></h2><blockquote>\n<p><code>MutationObserver</code> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>\n</blockquote>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>MutationObserver()</p>\n<p>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(callback);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">callback</span>(<span class=\"params\">mutationList, observer</span>) &#123;</span><br><span class=\"line\">  mutationList.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">mutation</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(mutation.<span class=\"property\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;childList&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\">/* 从树上添加或移除一个或更多的子节点；参见 mutation.addedNodes 与</span></span><br><span class=\"line\"><span class=\"comment\">           mutation.removedNodes */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;attributes&#x27;</span>:</span><br><span class=\"line\">        <span class=\"comment\">/* mutation.target 中某节点的一个属性值被更改；该属性名称在 mutation.attributeName 中，</span></span><br><span class=\"line\"><span class=\"comment\">           该属性之前的值为 mutation.oldValue */</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>callback<ul>\n<li>一个回调函数，每当被指定的节点或子树以及配置项有 DOM 变动时会被调用。回调函数拥有两个参数：一个是描述所有被触发改动的 <code>MutationRecord</code> 对象数组，另一个是调用该函数的 MutationObserver 对象。参见下方的示例了解更多细节</li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord\" >MutationRecord <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a><ul>\n<li>MutationRecord.type</li>\n<li>MutationRecord.target</li>\n<li>MutationRecord.addedNodes</li>\n<li>MutationRecord.removedNodes</li>\n<li>MutationRecord.previousSibling</li>\n<li>MutationRecord.nextSibling</li>\n<li>MutationRecord.attributeName</li>\n<li>MutationRecord.attributeNamespace</li>\n<li>MutationRecord.oldValue</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>return<ul>\n<li>一个新的、包含监听 DOM 变化回调函数的 MutationObserver 对象。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><ul>\n<li>disconnect：阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe() 方法，该观察者对象包含的回调函数都不会再被调用。</li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe\" >observe <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>：配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。<ul>\n<li>target：DOM 树中的一个要观察变化的 DOM Node (可能是一个 Element)，或者是被观察的子节点树的根节点。</li>\n<li>options：此对象的配置项描述了 DOM 的哪些变化应该报告给 MutationObserver 的 callback。当调用 observe() 时，childList、attributes 和 characterData 中，必须有一个参数为 true。否则会抛出 TypeError 异常。</li>\n</ul>\n</li>\n<li>takeRecords：从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 选择需要观察变动的节点</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetNode = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;some-id&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 观察器的配置（需要观察什么变动）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123; <span class=\"attr\">attributes</span>: <span class=\"literal\">true</span>, <span class=\"attr\">childList</span>: <span class=\"literal\">true</span>, <span class=\"attr\">subtree</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当观察到变动时执行的回调函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> callback = <span class=\"keyword\">function</span>(<span class=\"params\">mutationsList, observer</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use traditional &#x27;for loops&#x27; for IE 11</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> mutation <span class=\"keyword\">of</span> mutationsList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;childList&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;A child node has been added or removed.&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutation.<span class=\"property\">type</span> === <span class=\"string\">&#x27;attributes&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;The &#x27;</span> + mutation.<span class=\"property\">attributeName</span> + <span class=\"string\">&#x27; attribute was modified.&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个观察器实例并传入回调函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">MutationObserver</span>(callback);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上述配置开始观察目标节点</span></span><br><span class=\"line\">observer.<span class=\"title function_\">observe</span>(targetNode, config);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 之后，可停止观察</span></span><br><span class=\"line\">observer.<span class=\"title function_\">disconnect</span>();</span><br></pre></td></tr></table></figure>"},{"title":"【方法论】前端发展历程梳理","date":"2022-03-20T07:49:39.000Z","_content":"\n## 前言\n\n了解前端的发展历史有助于从一个全局的视角来重新认知前端技术，脱离单独某一种视角的窠臼。\n\n- `Node.js`的出现意味着什么？\n- 为什么要从`jquery`转入三大框架？\n- 既然已经有了`javascript`为什么还要使用`babel`来转化？\n- `CommonJS`、`AMD`、`CMD`、`ESModule`又是什么？\n\n类似的问题不胜枚举，而这篇文章有助于解决此类问题。\n\n## 1. 需求驱动和问题驱动\n\n一种技术能够出现并且不断的发展，一定具有某种内在的驱动力，我认为这种驱动力存在两种：\n1. 需求驱动\n2. 问题驱动\n\n需求驱动顾名思义就是当前的技术工具支持不了新的需求，所以推动了新技术的产生。而问题驱动则是实现某种需求的过程中产生了困难，老旧的技术工具解决不了或者解决起来很麻烦困难，所以推动了新技术的产生。\n\n## 2. 前端大事件的时间节点\n\n| 时间               | 事件                                                                                                                                                                                                                                                                |\n| :----------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `web1.0 1991~2004` | 只读网络，网站提供内容，用户阅读内容                                                                                                                                                                                                                                |\n| 1989 年             | `HTML`由 Web 的发明者 Tim Berners-Lee 创立，这也是前端的起始                                                                                                                                                                                                            |\n| 1994 年             | 世界上的第一款浏览器`NCSAMosaic`由 Netscape（网景）公司开发，同年`W3C`（世界万维网联盟）成立                                                                                                                                                                          |\n| 1995 年             | `JavaScript`由网景公司的 Brendan Eich 设计                                                                                                                                                                                                                            |\n| 1996 年             | W3C 发布了`CSS1`标准，从此前端有了样式规范                                                                                                                                                                                                                           |\n| 1997 年             | `ECMAScript1`由 ECMA 国际正式发布，从此 Javascript 有了自己的标准，同年 W3C 发布了`HTML4.0`标准，这是使用时间最长的一个版本                                                                                                                                               |\n| 1998 年             | W3C 发布了`XML（可扩展标记语言）`标准，同年`Ajax`（异步 Javascript 和 XML）技术开始得到应用                                                                                                                                                                               |\n| 2001 年             | Douglas Crockford 开始推广使用`JSON`数据格式，它比 XML 更加简洁清晰                                                                                                                                                                                                    |\n| `web2.0 2004~至今` | 交互网络，用户产生内容，通过网站与他人交互                                                                                                                                                                                                                          |\n| 2006 年             | John Resig 发布了`JQuery`的第一个版本，这是迄今为止最成功的 JS 库，同年 W3C 正式发布`XMLHttpRequest`标准，为以后的 Ajax 爆发提供技术基础。                                                                                                                                 |\n| 2008 年             | Google 开源了高性能的 Javascript 引擎`V8`                                                                                                                                                                                                                              |\n| 2009 年             | Ryan Dahl 开发了基于 V8 引擎的`NodeJS`运行时环境，从此 javascript 可以运行在服务端；同年`ECMAScript5`发布，这是使用时间最长，各个浏览器兼容性最好，如今大部分程序也依然在使用的一代标准；同年 Miško Hevery 创造了`AngularJS`框架，基于 MVC 模式，并且实现了 SPA（单页面应用） |\n| 2010 年             | `NPM`（NodeJS 包管理工具）发布了第一个版本，从此前端有了自己的包管理器                                                                                                                                                                                               |\n| 2011 年             | Twitter 开源了其前端框架`Bootstrap`                                                                                                                                                                                                                                  |\n| 2012 年             | 微软发布了`Typescript`的第一个版本，让 Javascript 拥有了自己的类型                                                                                                                                                                                                    |\n| 2013 年             | Facebook 开源了其前端框架`React`，同年尤雨溪受到 Angular 启发开发了轻量级前端框架`Seed`，后更名为`Vue`                                                                                                                                                                 |\n| 2014 年             | W3C 发布了`HTML5`标准                                                                                                                                                                                                                                                |\n| 2015 年             | `ECMAScript6`正式发布，后更名为`ECMAScript2015`，之截至目前 2022 年，每年都发布了对应的新版本                                                                                                                                                                         |\n| 2016 年             | `ECMAScript2016`正式发布                                                                                                                                                                                                                                            |\n| 2017 年             | `ECMAScript2017`正式发布                                                                                                                                                                                                                                            |\n<!-- YCTODO -->\n## 一些技术发展过程的梳理\n\n可以把前端发展的历程分为\n\n## 展望未来\n\n## 参考资料\n- 百度百科\n- [前端的历史发展节点](http://www.javashuo.com/article/p-hvrlfhxo-gc.html)\n- [Web 开发的历史发展技术演变](https://zhuanlan.zhihu.com/p/196637639)\n- [Web 1.0、Web 2.0 和 Web 3.0 之间的比较](https://blog.csdn.net/qq_44273429/article/details/127462439)","source":"_posts/MethodologyFrontendHistory.md","raw":"---\ntitle: 【方法论】前端发展历程梳理\ndate: 2022-03-20 15:49:39\ntags: [JS]\ncategories: [方法论]\n---\n\n## 前言\n\n了解前端的发展历史有助于从一个全局的视角来重新认知前端技术，脱离单独某一种视角的窠臼。\n\n- `Node.js`的出现意味着什么？\n- 为什么要从`jquery`转入三大框架？\n- 既然已经有了`javascript`为什么还要使用`babel`来转化？\n- `CommonJS`、`AMD`、`CMD`、`ESModule`又是什么？\n\n类似的问题不胜枚举，而这篇文章有助于解决此类问题。\n\n## 1. 需求驱动和问题驱动\n\n一种技术能够出现并且不断的发展，一定具有某种内在的驱动力，我认为这种驱动力存在两种：\n1. 需求驱动\n2. 问题驱动\n\n需求驱动顾名思义就是当前的技术工具支持不了新的需求，所以推动了新技术的产生。而问题驱动则是实现某种需求的过程中产生了困难，老旧的技术工具解决不了或者解决起来很麻烦困难，所以推动了新技术的产生。\n\n## 2. 前端大事件的时间节点\n\n| 时间               | 事件                                                                                                                                                                                                                                                                |\n| :----------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `web1.0 1991~2004` | 只读网络，网站提供内容，用户阅读内容                                                                                                                                                                                                                                |\n| 1989 年             | `HTML`由 Web 的发明者 Tim Berners-Lee 创立，这也是前端的起始                                                                                                                                                                                                            |\n| 1994 年             | 世界上的第一款浏览器`NCSAMosaic`由 Netscape（网景）公司开发，同年`W3C`（世界万维网联盟）成立                                                                                                                                                                          |\n| 1995 年             | `JavaScript`由网景公司的 Brendan Eich 设计                                                                                                                                                                                                                            |\n| 1996 年             | W3C 发布了`CSS1`标准，从此前端有了样式规范                                                                                                                                                                                                                           |\n| 1997 年             | `ECMAScript1`由 ECMA 国际正式发布，从此 Javascript 有了自己的标准，同年 W3C 发布了`HTML4.0`标准，这是使用时间最长的一个版本                                                                                                                                               |\n| 1998 年             | W3C 发布了`XML（可扩展标记语言）`标准，同年`Ajax`（异步 Javascript 和 XML）技术开始得到应用                                                                                                                                                                               |\n| 2001 年             | Douglas Crockford 开始推广使用`JSON`数据格式，它比 XML 更加简洁清晰                                                                                                                                                                                                    |\n| `web2.0 2004~至今` | 交互网络，用户产生内容，通过网站与他人交互                                                                                                                                                                                                                          |\n| 2006 年             | John Resig 发布了`JQuery`的第一个版本，这是迄今为止最成功的 JS 库，同年 W3C 正式发布`XMLHttpRequest`标准，为以后的 Ajax 爆发提供技术基础。                                                                                                                                 |\n| 2008 年             | Google 开源了高性能的 Javascript 引擎`V8`                                                                                                                                                                                                                              |\n| 2009 年             | Ryan Dahl 开发了基于 V8 引擎的`NodeJS`运行时环境，从此 javascript 可以运行在服务端；同年`ECMAScript5`发布，这是使用时间最长，各个浏览器兼容性最好，如今大部分程序也依然在使用的一代标准；同年 Miško Hevery 创造了`AngularJS`框架，基于 MVC 模式，并且实现了 SPA（单页面应用） |\n| 2010 年             | `NPM`（NodeJS 包管理工具）发布了第一个版本，从此前端有了自己的包管理器                                                                                                                                                                                               |\n| 2011 年             | Twitter 开源了其前端框架`Bootstrap`                                                                                                                                                                                                                                  |\n| 2012 年             | 微软发布了`Typescript`的第一个版本，让 Javascript 拥有了自己的类型                                                                                                                                                                                                    |\n| 2013 年             | Facebook 开源了其前端框架`React`，同年尤雨溪受到 Angular 启发开发了轻量级前端框架`Seed`，后更名为`Vue`                                                                                                                                                                 |\n| 2014 年             | W3C 发布了`HTML5`标准                                                                                                                                                                                                                                                |\n| 2015 年             | `ECMAScript6`正式发布，后更名为`ECMAScript2015`，之截至目前 2022 年，每年都发布了对应的新版本                                                                                                                                                                         |\n| 2016 年             | `ECMAScript2016`正式发布                                                                                                                                                                                                                                            |\n| 2017 年             | `ECMAScript2017`正式发布                                                                                                                                                                                                                                            |\n<!-- YCTODO -->\n## 一些技术发展过程的梳理\n\n可以把前端发展的历程分为\n\n## 展望未来\n\n## 参考资料\n- 百度百科\n- [前端的历史发展节点](http://www.javashuo.com/article/p-hvrlfhxo-gc.html)\n- [Web 开发的历史发展技术演变](https://zhuanlan.zhihu.com/p/196637639)\n- [Web 1.0、Web 2.0 和 Web 3.0 之间的比较](https://blog.csdn.net/qq_44273429/article/details/127462439)","slug":"MethodologyFrontendHistory","published":1,"updated":"2023-03-02T13:23:25.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ycgq00037gh88ll8cv8b","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>了解前端的发展历史有助于从一个全局的视角来重新认知前端技术，脱离单独某一种视角的窠臼。</p>\n<ul>\n<li><code>Node.js</code>的出现意味着什么？</li>\n<li>为什么要从<code>jquery</code>转入三大框架？</li>\n<li>既然已经有了<code>javascript</code>为什么还要使用<code>babel</code>来转化？</li>\n<li><code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>、<code>ESModule</code>又是什么？</li>\n</ul>\n<p>类似的问题不胜枚举，而这篇文章有助于解决此类问题。</p>\n<h2 id=\"1-需求驱动和问题驱动\"><a href=\"#1-需求驱动和问题驱动\" class=\"headerlink\" title=\"1. 需求驱动和问题驱动\"></a>1. 需求驱动和问题驱动</h2><p>一种技术能够出现并且不断的发展，一定具有某种内在的驱动力，我认为这种驱动力存在两种：</p>\n<ol>\n<li>需求驱动</li>\n<li>问题驱动</li>\n</ol>\n<p>需求驱动顾名思义就是当前的技术工具支持不了新的需求，所以推动了新技术的产生。而问题驱动则是实现某种需求的过程中产生了困难，老旧的技术工具解决不了或者解决起来很麻烦困难，所以推动了新技术的产生。</p>\n<h2 id=\"2-前端大事件的时间节点\"><a href=\"#2-前端大事件的时间节点\" class=\"headerlink\" title=\"2. 前端大事件的时间节点\"></a>2. 前端大事件的时间节点</h2><table>\n<thead>\n<tr>\n<th align=\"left\">时间</th>\n<th align=\"left\">事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>web1.0 1991~2004</code></td>\n<td align=\"left\">只读网络，网站提供内容，用户阅读内容</td>\n</tr>\n<tr>\n<td align=\"left\">1989 年</td>\n<td align=\"left\"><code>HTML</code>由 Web 的发明者 Tim Berners-Lee 创立，这也是前端的起始</td>\n</tr>\n<tr>\n<td align=\"left\">1994 年</td>\n<td align=\"left\">世界上的第一款浏览器<code>NCSAMosaic</code>由 Netscape（网景）公司开发，同年<code>W3C</code>（世界万维网联盟）成立</td>\n</tr>\n<tr>\n<td align=\"left\">1995 年</td>\n<td align=\"left\"><code>JavaScript</code>由网景公司的 Brendan Eich 设计</td>\n</tr>\n<tr>\n<td align=\"left\">1996 年</td>\n<td align=\"left\">W3C 发布了<code>CSS1</code>标准，从此前端有了样式规范</td>\n</tr>\n<tr>\n<td align=\"left\">1997 年</td>\n<td align=\"left\"><code>ECMAScript1</code>由 ECMA 国际正式发布，从此 Javascript 有了自己的标准，同年 W3C 发布了<code>HTML4.0</code>标准，这是使用时间最长的一个版本</td>\n</tr>\n<tr>\n<td align=\"left\">1998 年</td>\n<td align=\"left\">W3C 发布了<code>XML（可扩展标记语言）</code>标准，同年<code>Ajax</code>（异步 Javascript 和 XML）技术开始得到应用</td>\n</tr>\n<tr>\n<td align=\"left\">2001 年</td>\n<td align=\"left\">Douglas Crockford 开始推广使用<code>JSON</code>数据格式，它比 XML 更加简洁清晰</td>\n</tr>\n<tr>\n<td align=\"left\"><code>web2.0 2004~至今</code></td>\n<td align=\"left\">交互网络，用户产生内容，通过网站与他人交互</td>\n</tr>\n<tr>\n<td align=\"left\">2006 年</td>\n<td align=\"left\">John Resig 发布了<code>JQuery</code>的第一个版本，这是迄今为止最成功的 JS 库，同年 W3C 正式发布<code>XMLHttpRequest</code>标准，为以后的 Ajax 爆发提供技术基础。</td>\n</tr>\n<tr>\n<td align=\"left\">2008 年</td>\n<td align=\"left\">Google 开源了高性能的 Javascript 引擎<code>V8</code></td>\n</tr>\n<tr>\n<td align=\"left\">2009 年</td>\n<td align=\"left\">Ryan Dahl 开发了基于 V8 引擎的<code>NodeJS</code>运行时环境，从此 javascript 可以运行在服务端；同年<code>ECMAScript5</code>发布，这是使用时间最长，各个浏览器兼容性最好，如今大部分程序也依然在使用的一代标准；同年 Miško Hevery 创造了<code>AngularJS</code>框架，基于 MVC 模式，并且实现了 SPA（单页面应用）</td>\n</tr>\n<tr>\n<td align=\"left\">2010 年</td>\n<td align=\"left\"><code>NPM</code>（NodeJS 包管理工具）发布了第一个版本，从此前端有了自己的包管理器</td>\n</tr>\n<tr>\n<td align=\"left\">2011 年</td>\n<td align=\"left\">Twitter 开源了其前端框架<code>Bootstrap</code></td>\n</tr>\n<tr>\n<td align=\"left\">2012 年</td>\n<td align=\"left\">微软发布了<code>Typescript</code>的第一个版本，让 Javascript 拥有了自己的类型</td>\n</tr>\n<tr>\n<td align=\"left\">2013 年</td>\n<td align=\"left\">Facebook 开源了其前端框架<code>React</code>，同年尤雨溪受到 Angular 启发开发了轻量级前端框架<code>Seed</code>，后更名为<code>Vue</code></td>\n</tr>\n<tr>\n<td align=\"left\">2014 年</td>\n<td align=\"left\">W3C 发布了<code>HTML5</code>标准</td>\n</tr>\n<tr>\n<td align=\"left\">2015 年</td>\n<td align=\"left\"><code>ECMAScript6</code>正式发布，后更名为<code>ECMAScript2015</code>，之截至目前 2022 年，每年都发布了对应的新版本</td>\n</tr>\n<tr>\n<td align=\"left\">2016 年</td>\n<td align=\"left\"><code>ECMAScript2016</code>正式发布</td>\n</tr>\n<tr>\n<td align=\"left\">2017 年</td>\n<td align=\"left\"><code>ECMAScript2017</code>正式发布</td>\n</tr>\n</tbody></table>\n<!-- YCTODO -->\n<h2 id=\"一些技术发展过程的梳理\"><a href=\"#一些技术发展过程的梳理\" class=\"headerlink\" title=\"一些技术发展过程的梳理\"></a>一些技术发展过程的梳理</h2><p>可以把前端发展的历程分为</p>\n<h2 id=\"展望未来\"><a href=\"#展望未来\" class=\"headerlink\" title=\"展望未来\"></a>展望未来</h2><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>百度百科</li>\n<li><a class=\"link\"   href=\"http://www.javashuo.com/article/p-hvrlfhxo-gc.html\" >前端的历史发展节点 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/196637639\" >Web 开发的历史发展技术演变 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/qq_44273429/article/details/127462439\" >Web 1.0、Web 2.0 和 Web 3.0 之间的比较 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>了解前端的发展历史有助于从一个全局的视角来重新认知前端技术，脱离单独某一种视角的窠臼。</p>\n<ul>\n<li><code>Node.js</code>的出现意味着什么？</li>\n<li>为什么要从<code>jquery</code>转入三大框架？</li>\n<li>既然已经有了<code>javascript</code>为什么还要使用<code>babel</code>来转化？</li>\n<li><code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>、<code>ESModule</code>又是什么？</li>\n</ul>\n<p>类似的问题不胜枚举，而这篇文章有助于解决此类问题。</p>\n<h2 id=\"1-需求驱动和问题驱动\"><a href=\"#1-需求驱动和问题驱动\" class=\"headerlink\" title=\"1. 需求驱动和问题驱动\"></a>1. 需求驱动和问题驱动</h2><p>一种技术能够出现并且不断的发展，一定具有某种内在的驱动力，我认为这种驱动力存在两种：</p>\n<ol>\n<li>需求驱动</li>\n<li>问题驱动</li>\n</ol>\n<p>需求驱动顾名思义就是当前的技术工具支持不了新的需求，所以推动了新技术的产生。而问题驱动则是实现某种需求的过程中产生了困难，老旧的技术工具解决不了或者解决起来很麻烦困难，所以推动了新技术的产生。</p>\n<h2 id=\"2-前端大事件的时间节点\"><a href=\"#2-前端大事件的时间节点\" class=\"headerlink\" title=\"2. 前端大事件的时间节点\"></a>2. 前端大事件的时间节点</h2><table>\n<thead>\n<tr>\n<th align=\"left\">时间</th>\n<th align=\"left\">事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>web1.0 1991~2004</code></td>\n<td align=\"left\">只读网络，网站提供内容，用户阅读内容</td>\n</tr>\n<tr>\n<td align=\"left\">1989 年</td>\n<td align=\"left\"><code>HTML</code>由 Web 的发明者 Tim Berners-Lee 创立，这也是前端的起始</td>\n</tr>\n<tr>\n<td align=\"left\">1994 年</td>\n<td align=\"left\">世界上的第一款浏览器<code>NCSAMosaic</code>由 Netscape（网景）公司开发，同年<code>W3C</code>（世界万维网联盟）成立</td>\n</tr>\n<tr>\n<td align=\"left\">1995 年</td>\n<td align=\"left\"><code>JavaScript</code>由网景公司的 Brendan Eich 设计</td>\n</tr>\n<tr>\n<td align=\"left\">1996 年</td>\n<td align=\"left\">W3C 发布了<code>CSS1</code>标准，从此前端有了样式规范</td>\n</tr>\n<tr>\n<td align=\"left\">1997 年</td>\n<td align=\"left\"><code>ECMAScript1</code>由 ECMA 国际正式发布，从此 Javascript 有了自己的标准，同年 W3C 发布了<code>HTML4.0</code>标准，这是使用时间最长的一个版本</td>\n</tr>\n<tr>\n<td align=\"left\">1998 年</td>\n<td align=\"left\">W3C 发布了<code>XML（可扩展标记语言）</code>标准，同年<code>Ajax</code>（异步 Javascript 和 XML）技术开始得到应用</td>\n</tr>\n<tr>\n<td align=\"left\">2001 年</td>\n<td align=\"left\">Douglas Crockford 开始推广使用<code>JSON</code>数据格式，它比 XML 更加简洁清晰</td>\n</tr>\n<tr>\n<td align=\"left\"><code>web2.0 2004~至今</code></td>\n<td align=\"left\">交互网络，用户产生内容，通过网站与他人交互</td>\n</tr>\n<tr>\n<td align=\"left\">2006 年</td>\n<td align=\"left\">John Resig 发布了<code>JQuery</code>的第一个版本，这是迄今为止最成功的 JS 库，同年 W3C 正式发布<code>XMLHttpRequest</code>标准，为以后的 Ajax 爆发提供技术基础。</td>\n</tr>\n<tr>\n<td align=\"left\">2008 年</td>\n<td align=\"left\">Google 开源了高性能的 Javascript 引擎<code>V8</code></td>\n</tr>\n<tr>\n<td align=\"left\">2009 年</td>\n<td align=\"left\">Ryan Dahl 开发了基于 V8 引擎的<code>NodeJS</code>运行时环境，从此 javascript 可以运行在服务端；同年<code>ECMAScript5</code>发布，这是使用时间最长，各个浏览器兼容性最好，如今大部分程序也依然在使用的一代标准；同年 Miško Hevery 创造了<code>AngularJS</code>框架，基于 MVC 模式，并且实现了 SPA（单页面应用）</td>\n</tr>\n<tr>\n<td align=\"left\">2010 年</td>\n<td align=\"left\"><code>NPM</code>（NodeJS 包管理工具）发布了第一个版本，从此前端有了自己的包管理器</td>\n</tr>\n<tr>\n<td align=\"left\">2011 年</td>\n<td align=\"left\">Twitter 开源了其前端框架<code>Bootstrap</code></td>\n</tr>\n<tr>\n<td align=\"left\">2012 年</td>\n<td align=\"left\">微软发布了<code>Typescript</code>的第一个版本，让 Javascript 拥有了自己的类型</td>\n</tr>\n<tr>\n<td align=\"left\">2013 年</td>\n<td align=\"left\">Facebook 开源了其前端框架<code>React</code>，同年尤雨溪受到 Angular 启发开发了轻量级前端框架<code>Seed</code>，后更名为<code>Vue</code></td>\n</tr>\n<tr>\n<td align=\"left\">2014 年</td>\n<td align=\"left\">W3C 发布了<code>HTML5</code>标准</td>\n</tr>\n<tr>\n<td align=\"left\">2015 年</td>\n<td align=\"left\"><code>ECMAScript6</code>正式发布，后更名为<code>ECMAScript2015</code>，之截至目前 2022 年，每年都发布了对应的新版本</td>\n</tr>\n<tr>\n<td align=\"left\">2016 年</td>\n<td align=\"left\"><code>ECMAScript2016</code>正式发布</td>\n</tr>\n<tr>\n<td align=\"left\">2017 年</td>\n<td align=\"left\"><code>ECMAScript2017</code>正式发布</td>\n</tr>\n</tbody></table>\n<!-- YCTODO -->\n<h2 id=\"一些技术发展过程的梳理\"><a href=\"#一些技术发展过程的梳理\" class=\"headerlink\" title=\"一些技术发展过程的梳理\"></a>一些技术发展过程的梳理</h2><p>可以把前端发展的历程分为</p>\n<h2 id=\"展望未来\"><a href=\"#展望未来\" class=\"headerlink\" title=\"展望未来\"></a>展望未来</h2><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>百度百科</li>\n<li><a class=\"link\"   href=\"http://www.javashuo.com/article/p-hvrlfhxo-gc.html\" >前端的历史发展节点 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/196637639\" >Web 开发的历史发展技术演变 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/qq_44273429/article/details/127462439\" >Web 1.0、Web 2.0 和 Web 3.0 之间的比较 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n"},{"title":"【方法论】JS 模块化梳理","date":"2022-03-09T03:39:39.000Z","_content":"\n## 前言\n\n模块化是编程中绕不过去的一环，可以说在我们的开发流程中，每时每刻都在使用着模块化，这无疑是一个非常重要的知识点。本文只讨论 JS 模块化，旨在加强对 JS 模块化的认识。主要涉及以下几点：\n-   JS 模块化的前世今生（为什么要模块化）\n-   JS 模块化的本质（如何实现模块化）\n\n## 一、JS 模块化的前世今生\n\n### 无模块化\n大家都知道模块化是复杂项目中必不可少的一环，良好的模块化能让项目结构更加清晰，提高代码复用性，逻辑与功能分离，加强可维护性。但在一开始，Javascript 中是不存在模块化的，它只是一门玩具语言，为网页添加一点特效而已。功能简单，用法单一。\n\n此时的 js 代码的书写方式是，从上到下，简单明了，直到`ajax`出现。\n\n### 模块化萌芽\nGoogle 将 ajax 概念发扬光大，在 Gmail 和 Google 地球等网页应用中大量使用了 ajax 技术，此时人们才惊觉利用 javascript 能够在网页中做到什么。于是越来越多的大型 web 项目开始出现，随之而来的是越来越复杂的业务逻辑与项目结构。问题不可避免的出现了。\n\n1. `全局变量污染`\n因为大家写的代码都在同一个全局作用域中，一不小心就可能声明一个已经存在的全局变量，往往就会发生难以预测的错误，这里举一个例子：\n```html\n<!-- 这是我写的 -->\n<script src=\"a.js\"></script>\n<script src=\"b.js\"></script>\n<!-- 这是同事写的 -->\n<script src=\"c.js\"></script>\n```\n\n```javascript\n// a.js\nvar name = '这里请不要改'\n\n// c.js\nfunction name(){\n\t...\n}\n```\n上面有 3 个脚本，a.js、b.js 是我写的，c.js 是同事写的，我定义了一个全局变量 name，同事不知道，他定义了一个全局方法 name()，于是我俩都得懵逼。\n\n*解决方案*\n\n解决方法之一是使用自执行函数包裹：\n```javascript\nmyModule = function(){\n\tvar id = 'user_id'\n\t...\n}()\n```\n这种方式解决了全局变量污染的问题，但仍暴露了一个全局函数在全局，仍可能存在命名冲突，并且有时需定义许多个这种类型的函数，不够优雅。\n\n2. `函数命名冲突`\n我们经常将一些功能性的函数抽离出来，放在同一个功能文件中，例如 utils.js 文件下放了一个 format 方法，这时同事需要一个不同的 format 方法，他就只能新建一个 format2 或者其他名字的方法，类似的事情很多。\n\n*解决方案*\n\n解决方法之一是使用命名空间，构造类似 java 的方式，于是代码变成了这样：\n```javascript\nobj.MyNameSpace.Utils.format()\n```\n这种类型的代码确实有用，但大大增加了书写的负担，你只想调用一个方法，却不得不写一长串的前缀。\n\n3. `文件依赖混乱`\n文件的依赖往往是无法避免的，例如实现一个 dialog 组件，它调用了一些 utils.js 文件里的方法，那么在引入`<script src=\"dialog\">`之前，需要先引入`<script src=\"utils\">`，当类似的情况越来越多时，依赖就难免混杂，从而增加维护难度。\n\n*解决方案*\n\n这是 Yahoo! 的 YUI3 框架解决方案，通过 requires 一个依赖数组来指定依赖：\n```javascript\nYUI.add('my-module', function (Y) {\n  // ...\n}, '0.0.1', {\n    requires: ['node', 'event']\n});\n```\n这种类型的代码确实解决了依赖混乱的问题，但当一个文件依赖增多时，这种配置型的代码就会变得复杂而且难看。\n\n在这个时期，不同的 web 团队为了解决项目中遇到的这类难题提出了自己的解决方案，但没有哪种解决方案可以解决所有的问题。\n\n### 几种模块化规范\n\n从以上的例子中可以观察到一些模块化所面临的难题：\n1. 如何安全的包装一个模块（不污染模块外的代码）\n2. 如何定义模块的唯一标识（解决命名冲突）\n3. 如何优雅的暴露模块（不增加复杂依赖）\n4. 模块间互相引用的循环依赖问题\n\n在 nodeJS 出现后，Javascript 可以用来编写服务端程序，这时 Javascript 没有模块化的缺点变得更加令人难以忍受，nodeJS 社区开始制定 JS 模块化规范。[Modules/1.0 规范]([Modules/1.0 - CommonJS Spec Wiki](https://wiki.commonjs.org/wiki/Modules/1.0))，首次定义了一个模块应该如何编写：\n>1. 模块的标识应遵循的规则（书写规范）\n> 2. 定义全局函数 require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API\n> 3. 如果被 require 函数引入的模块中也包含依赖，那么依次加载这些依赖\n> 4. 如果引入模块失败，那么 require 函数应该报一个异常\n> 5. 模块通过变量 exports 来向往暴漏 API，exports 只能是一个对象，暴漏的 API 须作为此对象的属性。\n\n一开始实现 Modules/1.0 规范的是 ServerJS（CommonJS 改名之前的叫法），它的写法如下：\n```javascript\n// math.js\nexports.add = function(){\n\tvar sum = 0,i = 0, args = arguments;\n\twhile(i < 1){\n\t\tsum += args[i++];\n\t}\n\treturn sum;\n};\n\n// increment.js\nvar add = require('math').add;\nexports.increment = function(val){\n\treturn add(val,1);\n}\n\n// program.js\nvar inc = require('increment').increment;\nvar a = 1;\ninc(a); //2\n```\n相比于之前的阶段，此时的代码更加简洁明了，但它只能在服务端运行而难以向浏览器端推广，原因如下：\n1. 外层没有 function 包裹，变量直接暴露在全局（如上 increment.js 中的 add 方法）\n2. 资源加载方式不同，在服务端，require 一个模块可以直接从内存中读取，消耗时间很小，但在浏览器端，require 一个模块需要向服务器发起一个 http 请求，下载完成后才能运行模块中的代码，也就是说 require 之后的代码必须等到 require 完成后才能执行。\n因为这些问题，社区中的主张分裂为 3 种，分别是\n- Modules/1.x 派\n- Modules/Async 派\n- Modules/2.0 派\n\n`Modules/1.x,CommonJS,browserify`\n这一派人认为既然 ServerJS 能够在服务端运行良好，只需要在现有基础上进行改进就能适应浏览器端的需求，浏览器端需要 function 包裹（为了保护变量）、需要异步加载，那么就使用一种工具将现有模块转化为适合浏览器端的代码，基于这种想法有基于这个主张，制定了 [Modules/Transport 规范](https://wiki.commonjs.org/wiki/Modules/Transport)，`browserify`是这种规范的一种实现，它是一种浏览器端的打包工具，能够将 nodeJS 模块转化为浏览器端可用的模块。\n\n`Modules/Async,AMD,RequireJS`\n这一派人认为浏览器端与服务端差别巨大，不能沿用原有模块标准。既然浏览器端需要异步加载代码，就通过回调的形式设计规范。其原理是：在模块定义时就指明并加载依赖，当依赖加载完毕后再执行回调中的本模块。因为这种异步的特性设计的规范名为 [AMD（Asynchronous Module Definition）](https://github.com/amdjs/amdjs-api/wiki/AMD-（中文版）)，根据 AMD 规范出现了`RequireJS`的实现，它的写法如下：\n```javascript\ndefine(id?, dependencies?, factory);\n\ndefine('increment',['math','other'],function(math){\n\t// 此时 math 和 other 模块内的代码已经执行完毕\n\tfunction increment(val){\n\t\treturn math.add(val,1)\n\t}\n\t// 即使 other 没有被使用到，other 还是被提前执行了\n\tif(false){\n\t\tother.doSomething();\n\t}\n})\n```\n\n`Modules/2.0 CMD Sea.js`\n这一派人有点类似中间派，既不想丢弃旧的规范，也不像 AMD 那样推倒重来，最终他们制定了 [Modules/Wrappings 规范]([http://wiki.commonjs.org/wiki/Modules/Wrappings](http://wiki.commonjs.org/wiki/Modules/Wrappings)),`SeaJS`是它的一个实现。写法如下：\n```javascript\ndefine(factory);\n\ndefine(function(require,exports,module){\n\t// 就近原则，哪里使用哪里声明\n\tvar math = require('math');\n\treturn{\n\t\tincrement:function(val){\n\t\t\treturn math.add(val,1);\n\t\t}\n\t}\n}\n```\n可以看到，它的写法和 RequireJS 很像，那么不同之处在哪里呢？RequireJS 会在依赖加载的第一时间加载并执行依赖内的代码，然后再执行回调内的模块代码；而 SeaJS 会在声明依赖之后才会执行依赖内的代码。总的来说就是：`AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。`\n\n`ES6 Module`\n从 ES6 开始，Javascript 开始有了标准层面的模块化，旨在成为浏览器端和服务器端的通用模块化方案。它的写法很简单，具体如下：\n```javascript\n// math.js\nfunction add(){\n...\n}\nexport {add};\n\n//increment.js\nimport {add} from './math';\nfunction increment(val){\n\treturn add(val,1);\n}\n```\n那么它和上面提到的几种模块化方案有哪些不同呢？\n1. 动态只读引用\n> ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此\n2. 编译时输出\n> ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。\n\n### 总结\n1.  AMD/CMD/CommonJs 是 js 模块化开发的规范，对应的实现是 require.js/sea.js/Node.js，ES Module 是 ES6 在语言规范上的模块化实现。\n2. CommonJS 主要针对服务端，AMD/CMD/ES Module 主要针对浏览器端，容易混淆的是 AMD/CMD。针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行，因为这部分很快。而浏览器端采用异步加载，因为需要发送 http 请求，这就需要一个预处理，提前将所需要的模块文件并行加载好。\n3. AMD/CMD 的区别：虽然都是并行加载 js 文件，但还是有所区别，AMD 是预加载，在并行加载 js 文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而 CMD 是懒加载，虽然会一开始就并行加载 js 文件，但是不会执行，而是在需要的时候才执行。\n4. AMD/CMD 的优缺点：JS 引擎是单线程的，单位时间内只能执行单个任务，所以在加载多个大文件时，会阻塞脚本执行。AMD 会在文件全部加载完毕后才执行代码，CMD 则会遇见依赖再加载代码，在此种情况 CMD 会更快，其他情形则相差不多。\n5. \n## 二、模块化的本质\n\n> 模块化的本质在于外部只能访问模块暴露出来的属性和方法，可以通过闭包的特性实现。\n\n```javascript\n// 原生模块模式\nfunction moduleA() {\n    var something = \"something\";\n    var another = \"another\";\n    function doSomething() {\n        console.log(something);\n    }\n\n    \n    function doAnother() {\n        console.log(another);\n    }\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother\n    };\n}\n// 调用模块内方法\nvar foo = moduleA();\nfoo.doSomething(); // something\nfoo.another; // undefined\n\n// jQuery 类型的模块\n// var $ = window.jQuery()\n```\n在这里通过调用 moduleA() 这个函数来创建模块实例 foo，通过这个模块实例可以调用模块内暴露的变量和方法，但仍存在问题，在于 moduleA 是一个全局函数，可能会造成函数名污染。也可以使用 IIFE 的方式创建：\n```javascript\n// IIFE\nvar foo = (function(){\n\tvar something = \"something\";\n\tvar another = \"another\";\n\tfunction doSomething(){...}\n\tfunction doAnother(){...}\n\treturn {\n\t\tdoSomething: doSomething,\n\t\tdoAnother: doAnother\n\t};\n})()\n```\n这种形式避免了函数名冲突，并且实现了单例模式。\n\n大多数模块加载器本质上就是将这种模块定义封装进一个 API，下面给出进一步实现：\n```javascript\nvar moduleCreater = (function Manager(){\n\tvar modules = {};\n\t// 通过 define 方法定义模块\n\tfunction define(id,deps,impl){\n\t\tfor(let i = 0;i < deps.length;i++){\n\t\t\t// 在这里解包依赖数组\n\t\t\tdeps[i] = modules[deps[i]];\n\t\t}\n\t\tmodules[id] = impl.apply(imply,deps);\n\t}\n\tfunction get(id){\n\t\treturn modules[id];\n\t}\n\treturn {\n\t\tdefine: define,\n\t\tget: get\n\t}\n})()\n```\n## 参考资料\n\t\n- 《你不知道的 Javascript》（上卷）\n- [js 模块化历程](https://www.cnblogs.com/lvdabao/p/js-modules-develop.html)\n- [js 模块化编程之彻底弄懂 CommonJS 和 AMD/CMD！](https://www.cnblogs.com/moxiaowohuwei/p/8692359.html)\n- [前端模块化开发那点历史 · Issue #588 · seajs/seajs (github.com)](https://github.com/seajs/seajs/issues/588)\n- [从 CommonJS 到 Sea.js · Issue #269 · seajs/seajs (github.com)](https://github.com/seajs/seajs/issues/269)","source":"_posts/MethodologyFrontendJSModularity .md","raw":"---\ntitle: 【方法论】JS 模块化梳理\ndate: 2022-03-09 11:39:39\ntags: [JS]\ncategories: [方法论]\n---\n\n## 前言\n\n模块化是编程中绕不过去的一环，可以说在我们的开发流程中，每时每刻都在使用着模块化，这无疑是一个非常重要的知识点。本文只讨论 JS 模块化，旨在加强对 JS 模块化的认识。主要涉及以下几点：\n-   JS 模块化的前世今生（为什么要模块化）\n-   JS 模块化的本质（如何实现模块化）\n\n## 一、JS 模块化的前世今生\n\n### 无模块化\n大家都知道模块化是复杂项目中必不可少的一环，良好的模块化能让项目结构更加清晰，提高代码复用性，逻辑与功能分离，加强可维护性。但在一开始，Javascript 中是不存在模块化的，它只是一门玩具语言，为网页添加一点特效而已。功能简单，用法单一。\n\n此时的 js 代码的书写方式是，从上到下，简单明了，直到`ajax`出现。\n\n### 模块化萌芽\nGoogle 将 ajax 概念发扬光大，在 Gmail 和 Google 地球等网页应用中大量使用了 ajax 技术，此时人们才惊觉利用 javascript 能够在网页中做到什么。于是越来越多的大型 web 项目开始出现，随之而来的是越来越复杂的业务逻辑与项目结构。问题不可避免的出现了。\n\n1. `全局变量污染`\n因为大家写的代码都在同一个全局作用域中，一不小心就可能声明一个已经存在的全局变量，往往就会发生难以预测的错误，这里举一个例子：\n```html\n<!-- 这是我写的 -->\n<script src=\"a.js\"></script>\n<script src=\"b.js\"></script>\n<!-- 这是同事写的 -->\n<script src=\"c.js\"></script>\n```\n\n```javascript\n// a.js\nvar name = '这里请不要改'\n\n// c.js\nfunction name(){\n\t...\n}\n```\n上面有 3 个脚本，a.js、b.js 是我写的，c.js 是同事写的，我定义了一个全局变量 name，同事不知道，他定义了一个全局方法 name()，于是我俩都得懵逼。\n\n*解决方案*\n\n解决方法之一是使用自执行函数包裹：\n```javascript\nmyModule = function(){\n\tvar id = 'user_id'\n\t...\n}()\n```\n这种方式解决了全局变量污染的问题，但仍暴露了一个全局函数在全局，仍可能存在命名冲突，并且有时需定义许多个这种类型的函数，不够优雅。\n\n2. `函数命名冲突`\n我们经常将一些功能性的函数抽离出来，放在同一个功能文件中，例如 utils.js 文件下放了一个 format 方法，这时同事需要一个不同的 format 方法，他就只能新建一个 format2 或者其他名字的方法，类似的事情很多。\n\n*解决方案*\n\n解决方法之一是使用命名空间，构造类似 java 的方式，于是代码变成了这样：\n```javascript\nobj.MyNameSpace.Utils.format()\n```\n这种类型的代码确实有用，但大大增加了书写的负担，你只想调用一个方法，却不得不写一长串的前缀。\n\n3. `文件依赖混乱`\n文件的依赖往往是无法避免的，例如实现一个 dialog 组件，它调用了一些 utils.js 文件里的方法，那么在引入`<script src=\"dialog\">`之前，需要先引入`<script src=\"utils\">`，当类似的情况越来越多时，依赖就难免混杂，从而增加维护难度。\n\n*解决方案*\n\n这是 Yahoo! 的 YUI3 框架解决方案，通过 requires 一个依赖数组来指定依赖：\n```javascript\nYUI.add('my-module', function (Y) {\n  // ...\n}, '0.0.1', {\n    requires: ['node', 'event']\n});\n```\n这种类型的代码确实解决了依赖混乱的问题，但当一个文件依赖增多时，这种配置型的代码就会变得复杂而且难看。\n\n在这个时期，不同的 web 团队为了解决项目中遇到的这类难题提出了自己的解决方案，但没有哪种解决方案可以解决所有的问题。\n\n### 几种模块化规范\n\n从以上的例子中可以观察到一些模块化所面临的难题：\n1. 如何安全的包装一个模块（不污染模块外的代码）\n2. 如何定义模块的唯一标识（解决命名冲突）\n3. 如何优雅的暴露模块（不增加复杂依赖）\n4. 模块间互相引用的循环依赖问题\n\n在 nodeJS 出现后，Javascript 可以用来编写服务端程序，这时 Javascript 没有模块化的缺点变得更加令人难以忍受，nodeJS 社区开始制定 JS 模块化规范。[Modules/1.0 规范]([Modules/1.0 - CommonJS Spec Wiki](https://wiki.commonjs.org/wiki/Modules/1.0))，首次定义了一个模块应该如何编写：\n>1. 模块的标识应遵循的规则（书写规范）\n> 2. 定义全局函数 require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API\n> 3. 如果被 require 函数引入的模块中也包含依赖，那么依次加载这些依赖\n> 4. 如果引入模块失败，那么 require 函数应该报一个异常\n> 5. 模块通过变量 exports 来向往暴漏 API，exports 只能是一个对象，暴漏的 API 须作为此对象的属性。\n\n一开始实现 Modules/1.0 规范的是 ServerJS（CommonJS 改名之前的叫法），它的写法如下：\n```javascript\n// math.js\nexports.add = function(){\n\tvar sum = 0,i = 0, args = arguments;\n\twhile(i < 1){\n\t\tsum += args[i++];\n\t}\n\treturn sum;\n};\n\n// increment.js\nvar add = require('math').add;\nexports.increment = function(val){\n\treturn add(val,1);\n}\n\n// program.js\nvar inc = require('increment').increment;\nvar a = 1;\ninc(a); //2\n```\n相比于之前的阶段，此时的代码更加简洁明了，但它只能在服务端运行而难以向浏览器端推广，原因如下：\n1. 外层没有 function 包裹，变量直接暴露在全局（如上 increment.js 中的 add 方法）\n2. 资源加载方式不同，在服务端，require 一个模块可以直接从内存中读取，消耗时间很小，但在浏览器端，require 一个模块需要向服务器发起一个 http 请求，下载完成后才能运行模块中的代码，也就是说 require 之后的代码必须等到 require 完成后才能执行。\n因为这些问题，社区中的主张分裂为 3 种，分别是\n- Modules/1.x 派\n- Modules/Async 派\n- Modules/2.0 派\n\n`Modules/1.x,CommonJS,browserify`\n这一派人认为既然 ServerJS 能够在服务端运行良好，只需要在现有基础上进行改进就能适应浏览器端的需求，浏览器端需要 function 包裹（为了保护变量）、需要异步加载，那么就使用一种工具将现有模块转化为适合浏览器端的代码，基于这种想法有基于这个主张，制定了 [Modules/Transport 规范](https://wiki.commonjs.org/wiki/Modules/Transport)，`browserify`是这种规范的一种实现，它是一种浏览器端的打包工具，能够将 nodeJS 模块转化为浏览器端可用的模块。\n\n`Modules/Async,AMD,RequireJS`\n这一派人认为浏览器端与服务端差别巨大，不能沿用原有模块标准。既然浏览器端需要异步加载代码，就通过回调的形式设计规范。其原理是：在模块定义时就指明并加载依赖，当依赖加载完毕后再执行回调中的本模块。因为这种异步的特性设计的规范名为 [AMD（Asynchronous Module Definition）](https://github.com/amdjs/amdjs-api/wiki/AMD-（中文版）)，根据 AMD 规范出现了`RequireJS`的实现，它的写法如下：\n```javascript\ndefine(id?, dependencies?, factory);\n\ndefine('increment',['math','other'],function(math){\n\t// 此时 math 和 other 模块内的代码已经执行完毕\n\tfunction increment(val){\n\t\treturn math.add(val,1)\n\t}\n\t// 即使 other 没有被使用到，other 还是被提前执行了\n\tif(false){\n\t\tother.doSomething();\n\t}\n})\n```\n\n`Modules/2.0 CMD Sea.js`\n这一派人有点类似中间派，既不想丢弃旧的规范，也不像 AMD 那样推倒重来，最终他们制定了 [Modules/Wrappings 规范]([http://wiki.commonjs.org/wiki/Modules/Wrappings](http://wiki.commonjs.org/wiki/Modules/Wrappings)),`SeaJS`是它的一个实现。写法如下：\n```javascript\ndefine(factory);\n\ndefine(function(require,exports,module){\n\t// 就近原则，哪里使用哪里声明\n\tvar math = require('math');\n\treturn{\n\t\tincrement:function(val){\n\t\t\treturn math.add(val,1);\n\t\t}\n\t}\n}\n```\n可以看到，它的写法和 RequireJS 很像，那么不同之处在哪里呢？RequireJS 会在依赖加载的第一时间加载并执行依赖内的代码，然后再执行回调内的模块代码；而 SeaJS 会在声明依赖之后才会执行依赖内的代码。总的来说就是：`AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。`\n\n`ES6 Module`\n从 ES6 开始，Javascript 开始有了标准层面的模块化，旨在成为浏览器端和服务器端的通用模块化方案。它的写法很简单，具体如下：\n```javascript\n// math.js\nfunction add(){\n...\n}\nexport {add};\n\n//increment.js\nimport {add} from './math';\nfunction increment(val){\n\treturn add(val,1);\n}\n```\n那么它和上面提到的几种模块化方案有哪些不同呢？\n1. 动态只读引用\n> ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此\n2. 编译时输出\n> ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。\n\n### 总结\n1.  AMD/CMD/CommonJs 是 js 模块化开发的规范，对应的实现是 require.js/sea.js/Node.js，ES Module 是 ES6 在语言规范上的模块化实现。\n2. CommonJS 主要针对服务端，AMD/CMD/ES Module 主要针对浏览器端，容易混淆的是 AMD/CMD。针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行，因为这部分很快。而浏览器端采用异步加载，因为需要发送 http 请求，这就需要一个预处理，提前将所需要的模块文件并行加载好。\n3. AMD/CMD 的区别：虽然都是并行加载 js 文件，但还是有所区别，AMD 是预加载，在并行加载 js 文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而 CMD 是懒加载，虽然会一开始就并行加载 js 文件，但是不会执行，而是在需要的时候才执行。\n4. AMD/CMD 的优缺点：JS 引擎是单线程的，单位时间内只能执行单个任务，所以在加载多个大文件时，会阻塞脚本执行。AMD 会在文件全部加载完毕后才执行代码，CMD 则会遇见依赖再加载代码，在此种情况 CMD 会更快，其他情形则相差不多。\n5. \n## 二、模块化的本质\n\n> 模块化的本质在于外部只能访问模块暴露出来的属性和方法，可以通过闭包的特性实现。\n\n```javascript\n// 原生模块模式\nfunction moduleA() {\n    var something = \"something\";\n    var another = \"another\";\n    function doSomething() {\n        console.log(something);\n    }\n\n    \n    function doAnother() {\n        console.log(another);\n    }\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother\n    };\n}\n// 调用模块内方法\nvar foo = moduleA();\nfoo.doSomething(); // something\nfoo.another; // undefined\n\n// jQuery 类型的模块\n// var $ = window.jQuery()\n```\n在这里通过调用 moduleA() 这个函数来创建模块实例 foo，通过这个模块实例可以调用模块内暴露的变量和方法，但仍存在问题，在于 moduleA 是一个全局函数，可能会造成函数名污染。也可以使用 IIFE 的方式创建：\n```javascript\n// IIFE\nvar foo = (function(){\n\tvar something = \"something\";\n\tvar another = \"another\";\n\tfunction doSomething(){...}\n\tfunction doAnother(){...}\n\treturn {\n\t\tdoSomething: doSomething,\n\t\tdoAnother: doAnother\n\t};\n})()\n```\n这种形式避免了函数名冲突，并且实现了单例模式。\n\n大多数模块加载器本质上就是将这种模块定义封装进一个 API，下面给出进一步实现：\n```javascript\nvar moduleCreater = (function Manager(){\n\tvar modules = {};\n\t// 通过 define 方法定义模块\n\tfunction define(id,deps,impl){\n\t\tfor(let i = 0;i < deps.length;i++){\n\t\t\t// 在这里解包依赖数组\n\t\t\tdeps[i] = modules[deps[i]];\n\t\t}\n\t\tmodules[id] = impl.apply(imply,deps);\n\t}\n\tfunction get(id){\n\t\treturn modules[id];\n\t}\n\treturn {\n\t\tdefine: define,\n\t\tget: get\n\t}\n})()\n```\n## 参考资料\n\t\n- 《你不知道的 Javascript》（上卷）\n- [js 模块化历程](https://www.cnblogs.com/lvdabao/p/js-modules-develop.html)\n- [js 模块化编程之彻底弄懂 CommonJS 和 AMD/CMD！](https://www.cnblogs.com/moxiaowohuwei/p/8692359.html)\n- [前端模块化开发那点历史 · Issue #588 · seajs/seajs (github.com)](https://github.com/seajs/seajs/issues/588)\n- [从 CommonJS 到 Sea.js · Issue #269 · seajs/seajs (github.com)](https://github.com/seajs/seajs/issues/269)","slug":"MethodologyFrontendJSModularity ","published":1,"updated":"2023-11-22T14:42:03.268Z","_id":"clf92ycgu00077gh8cq9b7url","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>模块化是编程中绕不过去的一环，可以说在我们的开发流程中，每时每刻都在使用着模块化，这无疑是一个非常重要的知识点。本文只讨论 JS 模块化，旨在加强对 JS 模块化的认识。主要涉及以下几点：</p>\n<ul>\n<li>JS 模块化的前世今生（为什么要模块化）</li>\n<li>JS 模块化的本质（如何实现模块化）</li>\n</ul>\n<h2 id=\"一、JS-模块化的前世今生\"><a href=\"#一、JS-模块化的前世今生\" class=\"headerlink\" title=\"一、JS 模块化的前世今生\"></a>一、JS 模块化的前世今生</h2><h3 id=\"无模块化\"><a href=\"#无模块化\" class=\"headerlink\" title=\"无模块化\"></a>无模块化</h3><p>大家都知道模块化是复杂项目中必不可少的一环，良好的模块化能让项目结构更加清晰，提高代码复用性，逻辑与功能分离，加强可维护性。但在一开始，Javascript 中是不存在模块化的，它只是一门玩具语言，为网页添加一点特效而已。功能简单，用法单一。</p>\n<p>此时的 js 代码的书写方式是，从上到下，简单明了，直到<code>ajax</code>出现。</p>\n<h3 id=\"模块化萌芽\"><a href=\"#模块化萌芽\" class=\"headerlink\" title=\"模块化萌芽\"></a>模块化萌芽</h3><p>Google 将 ajax 概念发扬光大，在 Gmail 和 Google 地球等网页应用中大量使用了 ajax 技术，此时人们才惊觉利用 javascript 能够在网页中做到什么。于是越来越多的大型 web 项目开始出现，随之而来的是越来越复杂的业务逻辑与项目结构。问题不可避免的出现了。</p>\n<ol>\n<li><code>全局变量污染</code><br>因为大家写的代码都在同一个全局作用域中，一不小心就可能声明一个已经存在的全局变量，往往就会发生难以预测的错误，这里举一个例子：<div class=\"highlight-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 这是我写的 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;a.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;b.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 这是同事写的 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;c.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>\n</ol>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;这里请不要改&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// c.js</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">name</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>上面有 3 个脚本，a.js、b.js 是我写的，c.js 是同事写的，我定义了一个全局变量 name，同事不知道，他定义了一个全局方法 name()，于是我俩都得懵逼。</p>\n<p><em>解决方案</em></p>\n<p>解决方法之一是使用自执行函数包裹：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myModule = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> id = <span class=\"string\">&#x27;user_id&#x27;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure></div>\n<p>这种方式解决了全局变量污染的问题，但仍暴露了一个全局函数在全局，仍可能存在命名冲突，并且有时需定义许多个这种类型的函数，不够优雅。</p>\n<ol start=\"2\">\n<li><code>函数命名冲突</code><br>我们经常将一些功能性的函数抽离出来，放在同一个功能文件中，例如 utils.js 文件下放了一个 format 方法，这时同事需要一个不同的 format 方法，他就只能新建一个 format2 或者其他名字的方法，类似的事情很多。</li>\n</ol>\n<p><em>解决方案</em></p>\n<p>解决方法之一是使用命名空间，构造类似 java 的方式，于是代码变成了这样：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.<span class=\"property\">MyNameSpace</span>.<span class=\"property\">Utils</span>.<span class=\"title function_\">format</span>()</span><br></pre></td></tr></table></figure></div>\n<p>这种类型的代码确实有用，但大大增加了书写的负担，你只想调用一个方法，却不得不写一长串的前缀。</p>\n<ol start=\"3\">\n<li><code>文件依赖混乱</code><br>文件的依赖往往是无法避免的，例如实现一个 dialog 组件，它调用了一些 utils.js 文件里的方法，那么在引入<code>&lt;script src=&quot;dialog&quot;&gt;</code>之前，需要先引入<code>&lt;script src=&quot;utils&quot;&gt;</code>，当类似的情况越来越多时，依赖就难免混杂，从而增加维护难度。</li>\n</ol>\n<p><em>解决方案</em></p>\n<p>这是 Yahoo! 的 YUI3 框架解决方案，通过 requires 一个依赖数组来指定依赖：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">YUI</span>.<span class=\"title function_\">add</span>(<span class=\"string\">&#x27;my-module&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;0.0.1&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">requires</span>: [<span class=\"string\">&#x27;node&#x27;</span>, <span class=\"string\">&#x27;event&#x27;</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n<p>这种类型的代码确实解决了依赖混乱的问题，但当一个文件依赖增多时，这种配置型的代码就会变得复杂而且难看。</p>\n<p>在这个时期，不同的 web 团队为了解决项目中遇到的这类难题提出了自己的解决方案，但没有哪种解决方案可以解决所有的问题。</p>\n<h3 id=\"几种模块化规范\"><a href=\"#几种模块化规范\" class=\"headerlink\" title=\"几种模块化规范\"></a>几种模块化规范</h3><p>从以上的例子中可以观察到一些模块化所面临的难题：</p>\n<ol>\n<li>如何安全的包装一个模块（不污染模块外的代码）</li>\n<li>如何定义模块的唯一标识（解决命名冲突）</li>\n<li>如何优雅的暴露模块（不增加复杂依赖）</li>\n<li>模块间互相引用的循环依赖问题</li>\n</ol>\n<p>在 nodeJS 出现后，Javascript 可以用来编写服务端程序，这时 Javascript 没有模块化的缺点变得更加令人难以忍受，nodeJS 社区开始制定 JS 模块化规范。[Modules&#x2F;1.0 规范](<a class=\"link\"   href=\"https://wiki.commonjs.org/wiki/Modules/1.0\" >Modules&#x2F;1.0 - CommonJS Spec Wiki <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>)，首次定义了一个模块应该如何编写：</p>\n<blockquote>\n<ol>\n<li>模块的标识应遵循的规则（书写规范）</li>\n<li>定义全局函数 require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API</li>\n<li>如果被 require 函数引入的模块中也包含依赖，那么依次加载这些依赖</li>\n<li>如果引入模块失败，那么 require 函数应该报一个异常</li>\n<li>模块通过变量 exports 来向往暴漏 API，exports 只能是一个对象，暴漏的 API 须作为此对象的属性。</li>\n</ol>\n</blockquote>\n<p>一开始实现 Modules&#x2F;1.0 规范的是 ServerJS（CommonJS 改名之前的叫法），它的写法如下：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">add</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>,i = <span class=\"number\">0</span>, args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tsum += args[i++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// increment.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;math&#x27;</span>).<span class=\"property\">add</span>;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">increment</span> = <span class=\"keyword\">function</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// program.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;increment&#x27;</span>).<span class=\"property\">increment</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"title function_\">inc</span>(a); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure></div>\n<p>相比于之前的阶段，此时的代码更加简洁明了，但它只能在服务端运行而难以向浏览器端推广，原因如下：</p>\n<ol>\n<li>外层没有 function 包裹，变量直接暴露在全局（如上 increment.js 中的 add 方法）</li>\n<li>资源加载方式不同，在服务端，require 一个模块可以直接从内存中读取，消耗时间很小，但在浏览器端，require 一个模块需要向服务器发起一个 http 请求，下载完成后才能运行模块中的代码，也就是说 require 之后的代码必须等到 require 完成后才能执行。<br>因为这些问题，社区中的主张分裂为 3 种，分别是</li>\n</ol>\n<ul>\n<li>Modules&#x2F;1.x 派</li>\n<li>Modules&#x2F;Async 派</li>\n<li>Modules&#x2F;2.0 派</li>\n</ul>\n<p><code>Modules/1.x,CommonJS,browserify</code><br>这一派人认为既然 ServerJS 能够在服务端运行良好，只需要在现有基础上进行改进就能适应浏览器端的需求，浏览器端需要 function 包裹（为了保护变量）、需要异步加载，那么就使用一种工具将现有模块转化为适合浏览器端的代码，基于这种想法有基于这个主张，制定了 <a class=\"link\"   href=\"https://wiki.commonjs.org/wiki/Modules/Transport\" >Modules&#x2F;Transport 规范 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>，<code>browserify</code>是这种规范的一种实现，它是一种浏览器端的打包工具，能够将 nodeJS 模块转化为浏览器端可用的模块。</p>\n<p><code>Modules/Async,AMD,RequireJS</code><br>这一派人认为浏览器端与服务端差别巨大，不能沿用原有模块标准。既然浏览器端需要异步加载代码，就通过回调的形式设计规范。其原理是：在模块定义时就指明并加载依赖，当依赖加载完毕后再执行回调中的本模块。因为这种异步的特性设计的规范名为 <a class=\"link\"   href=\"https://github.com/amdjs/amdjs-api/wiki/AMD-%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89\" >AMD（Asynchronous Module Definition） <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>，根据 AMD 规范出现了<code>RequireJS</code>的实现，它的写法如下：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>(id?, dependencies?, factory);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">define</span>(<span class=\"string\">&#x27;increment&#x27;</span>,[<span class=\"string\">&#x27;math&#x27;</span>,<span class=\"string\">&#x27;other&#x27;</span>],<span class=\"keyword\">function</span>(<span class=\"params\">math</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 此时 math 和 other 模块内的代码已经执行完毕</span></span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">increment</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> math.<span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 即使 other 没有被使用到，other 还是被提前执行了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">\t\tother.<span class=\"title function_\">doSomething</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<p><code>Modules/2.0 CMD Sea.js</code><br>这一派人有点类似中间派，既不想丢弃旧的规范，也不像 AMD 那样推倒重来，最终他们制定了 <a href=\"%5Bhttp://wiki.commonjs.org/wiki/Modules/Wrappings%5D(http://wiki.commonjs.org/wiki/Modules/Wrappings)\">Modules&#x2F;Wrappings 规范</a>,<code>SeaJS</code>是它的一个实现。写法如下：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>(factory);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">define</span>(<span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span>,<span class=\"built_in\">exports</span>,<span class=\"variable language_\">module</span></span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 就近原则，哪里使用哪里声明</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;math&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">increment</span>:<span class=\"keyword\">function</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> math.<span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>可以看到，它的写法和 RequireJS 很像，那么不同之处在哪里呢？RequireJS 会在依赖加载的第一时间加载并执行依赖内的代码，然后再执行回调内的模块代码；而 SeaJS 会在声明依赖之后才会执行依赖内的代码。总的来说就是：<code>AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。</code></p>\n<p><code>ES6 Module</code><br>从 ES6 开始，Javascript 开始有了标准层面的模块化，旨在成为浏览器端和服务器端的通用模块化方案。它的写法很简单，具体如下：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;add&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//increment.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./math&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">increment</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>那么它和上面提到的几种模块化方案有哪些不同呢？</p>\n<ol>\n<li>动态只读引用<blockquote>\n<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此</p>\n</blockquote>\n</li>\n<li>编译时输出<blockquote>\n<p>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>AMD&#x2F;CMD&#x2F;CommonJs 是 js 模块化开发的规范，对应的实现是 require.js&#x2F;sea.js&#x2F;Node.js，ES Module 是 ES6 在语言规范上的模块化实现。</li>\n<li>CommonJS 主要针对服务端，AMD&#x2F;CMD&#x2F;ES Module 主要针对浏览器端，容易混淆的是 AMD&#x2F;CMD。针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行，因为这部分很快。而浏览器端采用异步加载，因为需要发送 http 请求，这就需要一个预处理，提前将所需要的模块文件并行加载好。</li>\n<li>AMD&#x2F;CMD 的区别：虽然都是并行加载 js 文件，但还是有所区别，AMD 是预加载，在并行加载 js 文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而 CMD 是懒加载，虽然会一开始就并行加载 js 文件，但是不会执行，而是在需要的时候才执行。</li>\n<li>AMD&#x2F;CMD 的优缺点：JS 引擎是单线程的，单位时间内只能执行单个任务，所以在加载多个大文件时，会阻塞脚本执行。AMD 会在文件全部加载完毕后才执行代码，CMD 则会遇见依赖再加载代码，在此种情况 CMD 会更快，其他情形则相差不多。</li>\n<li></li>\n</ol>\n<h2 id=\"二、模块化的本质\"><a href=\"#二、模块化的本质\" class=\"headerlink\" title=\"二、模块化的本质\"></a>二、模块化的本质</h2><blockquote>\n<p>模块化的本质在于外部只能访问模块暴露出来的属性和方法，可以通过闭包的特性实现。</p>\n</blockquote>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生模块模式</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">moduleA</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> something = <span class=\"string\">&quot;something&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = <span class=\"string\">&quot;another&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(something);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSomething</span>: doSomething,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用模块内方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"title function_\">moduleA</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doSomething</span>(); <span class=\"comment\">// something</span></span><br><span class=\"line\">foo.<span class=\"property\">another</span>; <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jQuery 类型的模块</span></span><br><span class=\"line\"><span class=\"comment\">// var $ = window.jQuery()</span></span><br></pre></td></tr></table></figure></div>\n<p>在这里通过调用 moduleA() 这个函数来创建模块实例 foo，通过这个模块实例可以调用模块内暴露的变量和方法，但仍存在问题，在于 moduleA 是一个全局函数，可能会造成函数名污染。也可以使用 IIFE 的方式创建：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IIFE</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> something = <span class=\"string\">&quot;something&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> another = <span class=\"string\">&quot;another&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>)&#123;...&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>)&#123;...&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">doSomething</span>: doSomething,</span><br><span class=\"line\">\t\t<span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></div>\n<p>这种形式避免了函数名冲突，并且实现了单例模式。</p>\n<p>大多数模块加载器本质上就是将这种模块定义封装进一个 API，下面给出进一步实现：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> moduleCreater = (<span class=\"keyword\">function</span> <span class=\"title function_\">Manager</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> modules = &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 通过 define 方法定义模块</span></span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">define</span>(<span class=\"params\">id,deps,impl</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; deps.<span class=\"property\">length</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 在这里解包依赖数组</span></span><br><span class=\"line\">\t\t\tdeps[i] = modules[deps[i]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmodules[id] = impl.<span class=\"title function_\">apply</span>(imply,deps);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">get</span>(<span class=\"params\">id</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> modules[id];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">define</span>: define,</span><br><span class=\"line\">\t\t<span class=\"attr\">get</span>: get</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>《你不知道的 Javascript》（上卷）</li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/lvdabao/p/js-modules-develop.html\" >js 模块化历程 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/moxiaowohuwei/p/8692359.html\" >js 模块化编程之彻底弄懂 CommonJS 和 AMD&#x2F;CMD！ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/seajs/seajs/issues/588\" >前端模块化开发那点历史 · Issue #588 · seajs&#x2F;seajs (github.com) <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/seajs/seajs/issues/269\" >从 CommonJS 到 Sea.js · Issue #269 · seajs&#x2F;seajs (github.com) <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>模块化是编程中绕不过去的一环，可以说在我们的开发流程中，每时每刻都在使用着模块化，这无疑是一个非常重要的知识点。本文只讨论 JS 模块化，旨在加强对 JS 模块化的认识。主要涉及以下几点：</p>\n<ul>\n<li>JS 模块化的前世今生（为什么要模块化）</li>\n<li>JS 模块化的本质（如何实现模块化）</li>\n</ul>\n<h2 id=\"一、JS-模块化的前世今生\"><a href=\"#一、JS-模块化的前世今生\" class=\"headerlink\" title=\"一、JS 模块化的前世今生\"></a>一、JS 模块化的前世今生</h2><h3 id=\"无模块化\"><a href=\"#无模块化\" class=\"headerlink\" title=\"无模块化\"></a>无模块化</h3><p>大家都知道模块化是复杂项目中必不可少的一环，良好的模块化能让项目结构更加清晰，提高代码复用性，逻辑与功能分离，加强可维护性。但在一开始，Javascript 中是不存在模块化的，它只是一门玩具语言，为网页添加一点特效而已。功能简单，用法单一。</p>\n<p>此时的 js 代码的书写方式是，从上到下，简单明了，直到<code>ajax</code>出现。</p>\n<h3 id=\"模块化萌芽\"><a href=\"#模块化萌芽\" class=\"headerlink\" title=\"模块化萌芽\"></a>模块化萌芽</h3><p>Google 将 ajax 概念发扬光大，在 Gmail 和 Google 地球等网页应用中大量使用了 ajax 技术，此时人们才惊觉利用 javascript 能够在网页中做到什么。于是越来越多的大型 web 项目开始出现，随之而来的是越来越复杂的业务逻辑与项目结构。问题不可避免的出现了。</p>\n<ol>\n<li><code>全局变量污染</code><br>因为大家写的代码都在同一个全局作用域中，一不小心就可能声明一个已经存在的全局变量，往往就会发生难以预测的错误，这里举一个例子：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 这是我写的 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;a.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;b.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 这是同事写的 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;c.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&#x27;这里请不要改&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// c.js</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">name</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面有 3 个脚本，a.js、b.js 是我写的，c.js 是同事写的，我定义了一个全局变量 name，同事不知道，他定义了一个全局方法 name()，于是我俩都得懵逼。</p>\n<p><em>解决方案</em></p>\n<p>解决方法之一是使用自执行函数包裹：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myModule = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> id = <span class=\"string\">&#x27;user_id&#x27;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure>\n<p>这种方式解决了全局变量污染的问题，但仍暴露了一个全局函数在全局，仍可能存在命名冲突，并且有时需定义许多个这种类型的函数，不够优雅。</p>\n<ol start=\"2\">\n<li><code>函数命名冲突</code><br>我们经常将一些功能性的函数抽离出来，放在同一个功能文件中，例如 utils.js 文件下放了一个 format 方法，这时同事需要一个不同的 format 方法，他就只能新建一个 format2 或者其他名字的方法，类似的事情很多。</li>\n</ol>\n<p><em>解决方案</em></p>\n<p>解决方法之一是使用命名空间，构造类似 java 的方式，于是代码变成了这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.<span class=\"property\">MyNameSpace</span>.<span class=\"property\">Utils</span>.<span class=\"title function_\">format</span>()</span><br></pre></td></tr></table></figure>\n<p>这种类型的代码确实有用，但大大增加了书写的负担，你只想调用一个方法，却不得不写一长串的前缀。</p>\n<ol start=\"3\">\n<li><code>文件依赖混乱</code><br>文件的依赖往往是无法避免的，例如实现一个 dialog 组件，它调用了一些 utils.js 文件里的方法，那么在引入<code>&lt;script src=&quot;dialog&quot;&gt;</code>之前，需要先引入<code>&lt;script src=&quot;utils&quot;&gt;</code>，当类似的情况越来越多时，依赖就难免混杂，从而增加维护难度。</li>\n</ol>\n<p><em>解决方案</em></p>\n<p>这是 Yahoo! 的 YUI3 框架解决方案，通过 requires 一个依赖数组来指定依赖：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">YUI</span>.<span class=\"title function_\">add</span>(<span class=\"string\">&#x27;my-module&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">Y</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;0.0.1&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">requires</span>: [<span class=\"string\">&#x27;node&#x27;</span>, <span class=\"string\">&#x27;event&#x27;</span>]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这种类型的代码确实解决了依赖混乱的问题，但当一个文件依赖增多时，这种配置型的代码就会变得复杂而且难看。</p>\n<p>在这个时期，不同的 web 团队为了解决项目中遇到的这类难题提出了自己的解决方案，但没有哪种解决方案可以解决所有的问题。</p>\n<h3 id=\"几种模块化规范\"><a href=\"#几种模块化规范\" class=\"headerlink\" title=\"几种模块化规范\"></a>几种模块化规范</h3><p>从以上的例子中可以观察到一些模块化所面临的难题：</p>\n<ol>\n<li>如何安全的包装一个模块（不污染模块外的代码）</li>\n<li>如何定义模块的唯一标识（解决命名冲突）</li>\n<li>如何优雅的暴露模块（不增加复杂依赖）</li>\n<li>模块间互相引用的循环依赖问题</li>\n</ol>\n<p>在 nodeJS 出现后，Javascript 可以用来编写服务端程序，这时 Javascript 没有模块化的缺点变得更加令人难以忍受，nodeJS 社区开始制定 JS 模块化规范。[Modules&#x2F;1.0 规范](<a class=\"link\"   href=\"https://wiki.commonjs.org/wiki/Modules/1.0\" >Modules&#x2F;1.0 - CommonJS Spec Wiki <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>)，首次定义了一个模块应该如何编写：</p>\n<blockquote>\n<ol>\n<li>模块的标识应遵循的规则（书写规范）</li>\n<li>定义全局函数 require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API</li>\n<li>如果被 require 函数引入的模块中也包含依赖，那么依次加载这些依赖</li>\n<li>如果引入模块失败，那么 require 函数应该报一个异常</li>\n<li>模块通过变量 exports 来向往暴漏 API，exports 只能是一个对象，暴漏的 API 须作为此对象的属性。</li>\n</ol>\n</blockquote>\n<p>一开始实现 Modules&#x2F;1.0 规范的是 ServerJS（CommonJS 改名之前的叫法），它的写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">add</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>,i = <span class=\"number\">0</span>, args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tsum += args[i++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// increment.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;math&#x27;</span>).<span class=\"property\">add</span>;</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.<span class=\"property\">increment</span> = <span class=\"keyword\">function</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// program.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;increment&#x27;</span>).<span class=\"property\">increment</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"title function_\">inc</span>(a); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>相比于之前的阶段，此时的代码更加简洁明了，但它只能在服务端运行而难以向浏览器端推广，原因如下：</p>\n<ol>\n<li>外层没有 function 包裹，变量直接暴露在全局（如上 increment.js 中的 add 方法）</li>\n<li>资源加载方式不同，在服务端，require 一个模块可以直接从内存中读取，消耗时间很小，但在浏览器端，require 一个模块需要向服务器发起一个 http 请求，下载完成后才能运行模块中的代码，也就是说 require 之后的代码必须等到 require 完成后才能执行。<br>因为这些问题，社区中的主张分裂为 3 种，分别是</li>\n</ol>\n<ul>\n<li>Modules&#x2F;1.x 派</li>\n<li>Modules&#x2F;Async 派</li>\n<li>Modules&#x2F;2.0 派</li>\n</ul>\n<p><code>Modules/1.x,CommonJS,browserify</code><br>这一派人认为既然 ServerJS 能够在服务端运行良好，只需要在现有基础上进行改进就能适应浏览器端的需求，浏览器端需要 function 包裹（为了保护变量）、需要异步加载，那么就使用一种工具将现有模块转化为适合浏览器端的代码，基于这种想法有基于这个主张，制定了 <a class=\"link\"   href=\"https://wiki.commonjs.org/wiki/Modules/Transport\" >Modules&#x2F;Transport 规范 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>，<code>browserify</code>是这种规范的一种实现，它是一种浏览器端的打包工具，能够将 nodeJS 模块转化为浏览器端可用的模块。</p>\n<p><code>Modules/Async,AMD,RequireJS</code><br>这一派人认为浏览器端与服务端差别巨大，不能沿用原有模块标准。既然浏览器端需要异步加载代码，就通过回调的形式设计规范。其原理是：在模块定义时就指明并加载依赖，当依赖加载完毕后再执行回调中的本模块。因为这种异步的特性设计的规范名为 <a class=\"link\"   href=\"https://github.com/amdjs/amdjs-api/wiki/AMD-%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89\" >AMD（Asynchronous Module Definition） <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>，根据 AMD 规范出现了<code>RequireJS</code>的实现，它的写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>(id?, dependencies?, factory);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">define</span>(<span class=\"string\">&#x27;increment&#x27;</span>,[<span class=\"string\">&#x27;math&#x27;</span>,<span class=\"string\">&#x27;other&#x27;</span>],<span class=\"keyword\">function</span>(<span class=\"params\">math</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 此时 math 和 other 模块内的代码已经执行完毕</span></span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">increment</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> math.<span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 即使 other 没有被使用到，other 还是被提前执行了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">\t\tother.<span class=\"title function_\">doSomething</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>Modules/2.0 CMD Sea.js</code><br>这一派人有点类似中间派，既不想丢弃旧的规范，也不像 AMD 那样推倒重来，最终他们制定了 <a href=\"%5Bhttp://wiki.commonjs.org/wiki/Modules/Wrappings%5D(http://wiki.commonjs.org/wiki/Modules/Wrappings)\">Modules&#x2F;Wrappings 规范</a>,<code>SeaJS</code>是它的一个实现。写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">define</span>(factory);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">define</span>(<span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"built_in\">require</span>,<span class=\"built_in\">exports</span>,<span class=\"variable language_\">module</span></span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 就近原则，哪里使用哪里声明</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> math = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;math&#x27;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">increment</span>:<span class=\"keyword\">function</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> math.<span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，它的写法和 RequireJS 很像，那么不同之处在哪里呢？RequireJS 会在依赖加载的第一时间加载并执行依赖内的代码，然后再执行回调内的模块代码；而 SeaJS 会在声明依赖之后才会执行依赖内的代码。总的来说就是：<code>AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。</code></p>\n<p><code>ES6 Module</code><br>从 ES6 开始，Javascript 开始有了标准层面的模块化，旨在成为浏览器端和服务器端的通用模块化方案。它的写法很简单，具体如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// math.js</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;add&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//increment.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;add&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./math&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">increment</span>(<span class=\"params\">val</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">add</span>(val,<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么它和上面提到的几种模块化方案有哪些不同呢？</p>\n<ol>\n<li>动态只读引用<blockquote>\n<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此</p>\n</blockquote>\n</li>\n<li>编译时输出<blockquote>\n<p>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。模块内部引用的变化，会反应在外部。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>AMD&#x2F;CMD&#x2F;CommonJs 是 js 模块化开发的规范，对应的实现是 require.js&#x2F;sea.js&#x2F;Node.js，ES Module 是 ES6 在语言规范上的模块化实现。</li>\n<li>CommonJS 主要针对服务端，AMD&#x2F;CMD&#x2F;ES Module 主要针对浏览器端，容易混淆的是 AMD&#x2F;CMD。针对服务器端和针对浏览器端有什么本质的区别呢？服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行，因为这部分很快。而浏览器端采用异步加载，因为需要发送 http 请求，这就需要一个预处理，提前将所需要的模块文件并行加载好。</li>\n<li>AMD&#x2F;CMD 的区别：虽然都是并行加载 js 文件，但还是有所区别，AMD 是预加载，在并行加载 js 文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而 CMD 是懒加载，虽然会一开始就并行加载 js 文件，但是不会执行，而是在需要的时候才执行。</li>\n<li>AMD&#x2F;CMD 的优缺点：JS 引擎是单线程的，单位时间内只能执行单个任务，所以在加载多个大文件时，会阻塞脚本执行。AMD 会在文件全部加载完毕后才执行代码，CMD 则会遇见依赖再加载代码，在此种情况 CMD 会更快，其他情形则相差不多。</li>\n<li></li>\n</ol>\n<h2 id=\"二、模块化的本质\"><a href=\"#二、模块化的本质\" class=\"headerlink\" title=\"二、模块化的本质\"></a>二、模块化的本质</h2><blockquote>\n<p>模块化的本质在于外部只能访问模块暴露出来的属性和方法，可以通过闭包的特性实现。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生模块模式</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">moduleA</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> something = <span class=\"string\">&quot;something&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = <span class=\"string\">&quot;another&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(something);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSomething</span>: doSomething,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用模块内方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"title function_\">moduleA</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doSomething</span>(); <span class=\"comment\">// something</span></span><br><span class=\"line\">foo.<span class=\"property\">another</span>; <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jQuery 类型的模块</span></span><br><span class=\"line\"><span class=\"comment\">// var $ = window.jQuery()</span></span><br></pre></td></tr></table></figure>\n<p>在这里通过调用 moduleA() 这个函数来创建模块实例 foo，通过这个模块实例可以调用模块内暴露的变量和方法，但仍存在问题，在于 moduleA 是一个全局函数，可能会造成函数名污染。也可以使用 IIFE 的方式创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IIFE</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> something = <span class=\"string\">&quot;something&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> another = <span class=\"string\">&quot;another&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">doSomething</span>(<span class=\"params\"></span>)&#123;...&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>)&#123;...&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">doSomething</span>: doSomething,</span><br><span class=\"line\">\t\t<span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>这种形式避免了函数名冲突，并且实现了单例模式。</p>\n<p>大多数模块加载器本质上就是将这种模块定义封装进一个 API，下面给出进一步实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> moduleCreater = (<span class=\"keyword\">function</span> <span class=\"title function_\">Manager</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> modules = &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 通过 define 方法定义模块</span></span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">define</span>(<span class=\"params\">id,deps,impl</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;i &lt; deps.<span class=\"property\">length</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 在这里解包依赖数组</span></span><br><span class=\"line\">\t\t\tdeps[i] = modules[deps[i]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmodules[id] = impl.<span class=\"title function_\">apply</span>(imply,deps);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">get</span>(<span class=\"params\">id</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> modules[id];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">define</span>: define,</span><br><span class=\"line\">\t\t<span class=\"attr\">get</span>: get</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>《你不知道的 Javascript》（上卷）</li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/lvdabao/p/js-modules-develop.html\" >js 模块化历程 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/moxiaowohuwei/p/8692359.html\" >js 模块化编程之彻底弄懂 CommonJS 和 AMD&#x2F;CMD！ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/seajs/seajs/issues/588\" >前端模块化开发那点历史 · Issue #588 · seajs&#x2F;seajs (github.com) <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/seajs/seajs/issues/269\" >从 CommonJS 到 Sea.js · Issue #269 · seajs&#x2F;seajs (github.com) <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n"},{"title":"【方法论】前端工程化的一些理解","date":"2022-07-27T18:30:57.000Z","_content":"\n![s0](MethodologyFrontendEngineering/s0.png)\n\n## 前言\n在项目开发中常常听到前端工程化，那么什么是前端工程化，其要义在于何处，我想是值得了解的问题。\n\n它有哪些目的，解决了哪些问题，又以何种方式实现，这些都是值得探究、值得思考的。\n## 什么是前端工程化？\n关于什么是前端工程化，这里先给出我的理解：\n- 狭义上的理解：将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署\n- 广义上理解：前端工程化应该包含从编码开始到发布，运行和维护阶段\n\n简而言之，在前端规模越来越大，业务逻辑越来越复杂的今天，一切可以`提高效率、降低成本、质量保证`的手段都可以称得上是前端工程化。如果说软件工程是面向问题的（将软件开发流程中的共性抽离出来），把软件工程的思想带入到前端开发中，就是前端工程化。\n\n一个前端项目的开发流程可以概括为：\n\n> 需求分析-->`设计阶段`-->`开发阶段`(-->测试阶段-->部署阶段）-->项目维护\n\n也可以说，前端工程化主要发生在设计阶段和开发阶段，解决的是`开发阶段到项目维护阶段`的生产效率问题。\n\n## 前端工程化要解决哪些问题？\n在项目过程中，一些问题是共通的，在设计阶段，需要考虑：\n1. 怎样提高开发效率，降低开发成本？\n2. 怎样提高代码健壮性、降低维护难度？\n\n在开发阶段，需要考虑的问题有：\n1. 代码审查\n2. 压缩打包\n3. 单元测试\n4. 增量更新\n\n## 如何实现前端工程化？\n\n### 设计阶段\n根据前文，能够知道在设计阶段面临的一些问题，那么怎么解决呢？\n\n我们需要知道前端项目在设计阶段要做的一些事情：技术选型、确立规范、排期、分工。\n\n而技术选型和确立规范就是其中的重中之重。\n\n`技术选型`\n\n![s1](MethodologyFrontendEngineering/s1.png)\n无论是技术框架、编程语言、工具库、UI 库，都属于技术选型的范畴。\n\n一般要遵循的原则有 4 点：\n1. 可控性\n2. 稳定性\n3. 适用性\n4. 易用性\n\n一般来说，前端项目选择的框架是 Vue、React、Angular 的一种，根据项目规模和团队技术栈选择其他的工具库、UI 库。\n\n关于技术选型，可以看看这篇文章 [技术选型](https://zhuanlan.zhihu.com/p/346410244)\n\n`统一规范`\n\n![s2](MethodologyFrontendEngineering/s2.png)\n\n根据项目规模的不同，统一规范的重要性也不可一概而论，但总的来说，统一规范的重要性是随着项目复杂度的提升而提升的。\n\n有哪些地方需要统一规范呢？\n\n- 代码格式化：eslint、tslint\n- 代码提交规范：可以使用 git 的钩子函数自定义\n- 设计规范：由需求设计人员提供\n- 文档规范：注明公共 API、全局变量等\n- 一些约定：\n  - 目录结构约定：在什么地方做什么事\n  - 命名约定：变量、函数、css 类\n  - 版本管理\n  - 开发流程\n\n## 开发阶段\n### `开发`\n![s3](MethodologyFrontendEngineering/s3.png)\n\n在开发过程中，工程化主要在自建库、选择第三方库、搭建脚手架时发挥作用。\n\n自建库抽离公共函数，避免重复造轮子，应约定尽量使用自建库的方法。\n\n当自建库不能满足需求时，可以选择第三方库来弥补，第三方库应该关注安全性、稳定性、采取最小限度原则（即只使用必要的部分）。\n\n自定义工程脚手架也是非常重要的一部分，可以大大降低重复工作量，脚手架实践了`能够交给机器的事情就交给机器去做`这一思想。\n\n### `测试`\n![s4](MethodologyFrontendEngineering/s4.png)\n\n无论是什么项目，只要它仍在开发迭代，测试就是必要的一环。\n\n一个完整的项目开发流程图如下：\n![s4-1](MethodologyFrontendEngineering/s4-1.png)\n\n常用的测试分类有`单元测试`和`集成测试`，在开发过程中使用的是单元测试，那么什么是单元测试？\n> 单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。\n\n常见的单元测试工具有：Jest、Mocha 等。\n\n一些框架内也集成了单元测试工具，可以根据具体情况选择。\n\n### `部署`\n![s5](MethodologyFrontendEngineering/s5.png)\n\n在项目的部署阶段，我们聚焦于构建和部署。\n\n在构建时需要关注性能优化、自定义配置等，常用构建工具有 webpack、rollup、vite 等，他们各有特点，这里不加赘述。\n\n在部署时需要关注自动化、易用性等，常用的部署工具有 Jenkins。\n\n其他还有灰度和 CDN 等概念，灰度可以理解为青春使用版，即新版本发布时控制流量，易于回退。CDN 技术则是优化网络访问速度。\n\n## 总结\n\n前端工程化的要义在于：把能够交给机器的事情尽量交给机器去做。\n\n其重点在于`统一`，统一的代码规范、统一的命名约定、统一的技术栈、第三方库等等。\n\n而在实际项目开发过程中，前端工程化的实践既依赖设计师、架构师对于项目的先期构建，更强调开发团队间的意见交流。了解工程化概念，明晰其目的，才能避免重复造轮子，代码结构混杂不清等疏漏，提高代码复用性和健壮性。\n\n## 参考资料\n- [带你入门前端工程](https://woai3c.gitee.io/introduction-to-front-end-engineering/#%E7%AE%80%E4%BB%8B)\n- [浅谈什么是前端工程化\t](https://www.cnblogs.com/fsyz/p/8274727.html)\n- [大型项目前端架构浅谈](https://juejin.cn/post/6844903853859536903)","source":"_posts/MethodologyFrontendEngineering.md","raw":"---\ntitle: 【方法论】前端工程化的一些理解\ndate: 2022-07-28 02:30:57\ntags: [JS]\ncategories: [方法论]\n---\n\n![s0](MethodologyFrontendEngineering/s0.png)\n\n## 前言\n在项目开发中常常听到前端工程化，那么什么是前端工程化，其要义在于何处，我想是值得了解的问题。\n\n它有哪些目的，解决了哪些问题，又以何种方式实现，这些都是值得探究、值得思考的。\n## 什么是前端工程化？\n关于什么是前端工程化，这里先给出我的理解：\n- 狭义上的理解：将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署\n- 广义上理解：前端工程化应该包含从编码开始到发布，运行和维护阶段\n\n简而言之，在前端规模越来越大，业务逻辑越来越复杂的今天，一切可以`提高效率、降低成本、质量保证`的手段都可以称得上是前端工程化。如果说软件工程是面向问题的（将软件开发流程中的共性抽离出来），把软件工程的思想带入到前端开发中，就是前端工程化。\n\n一个前端项目的开发流程可以概括为：\n\n> 需求分析-->`设计阶段`-->`开发阶段`(-->测试阶段-->部署阶段）-->项目维护\n\n也可以说，前端工程化主要发生在设计阶段和开发阶段，解决的是`开发阶段到项目维护阶段`的生产效率问题。\n\n## 前端工程化要解决哪些问题？\n在项目过程中，一些问题是共通的，在设计阶段，需要考虑：\n1. 怎样提高开发效率，降低开发成本？\n2. 怎样提高代码健壮性、降低维护难度？\n\n在开发阶段，需要考虑的问题有：\n1. 代码审查\n2. 压缩打包\n3. 单元测试\n4. 增量更新\n\n## 如何实现前端工程化？\n\n### 设计阶段\n根据前文，能够知道在设计阶段面临的一些问题，那么怎么解决呢？\n\n我们需要知道前端项目在设计阶段要做的一些事情：技术选型、确立规范、排期、分工。\n\n而技术选型和确立规范就是其中的重中之重。\n\n`技术选型`\n\n![s1](MethodologyFrontendEngineering/s1.png)\n无论是技术框架、编程语言、工具库、UI 库，都属于技术选型的范畴。\n\n一般要遵循的原则有 4 点：\n1. 可控性\n2. 稳定性\n3. 适用性\n4. 易用性\n\n一般来说，前端项目选择的框架是 Vue、React、Angular 的一种，根据项目规模和团队技术栈选择其他的工具库、UI 库。\n\n关于技术选型，可以看看这篇文章 [技术选型](https://zhuanlan.zhihu.com/p/346410244)\n\n`统一规范`\n\n![s2](MethodologyFrontendEngineering/s2.png)\n\n根据项目规模的不同，统一规范的重要性也不可一概而论，但总的来说，统一规范的重要性是随着项目复杂度的提升而提升的。\n\n有哪些地方需要统一规范呢？\n\n- 代码格式化：eslint、tslint\n- 代码提交规范：可以使用 git 的钩子函数自定义\n- 设计规范：由需求设计人员提供\n- 文档规范：注明公共 API、全局变量等\n- 一些约定：\n  - 目录结构约定：在什么地方做什么事\n  - 命名约定：变量、函数、css 类\n  - 版本管理\n  - 开发流程\n\n## 开发阶段\n### `开发`\n![s3](MethodologyFrontendEngineering/s3.png)\n\n在开发过程中，工程化主要在自建库、选择第三方库、搭建脚手架时发挥作用。\n\n自建库抽离公共函数，避免重复造轮子，应约定尽量使用自建库的方法。\n\n当自建库不能满足需求时，可以选择第三方库来弥补，第三方库应该关注安全性、稳定性、采取最小限度原则（即只使用必要的部分）。\n\n自定义工程脚手架也是非常重要的一部分，可以大大降低重复工作量，脚手架实践了`能够交给机器的事情就交给机器去做`这一思想。\n\n### `测试`\n![s4](MethodologyFrontendEngineering/s4.png)\n\n无论是什么项目，只要它仍在开发迭代，测试就是必要的一环。\n\n一个完整的项目开发流程图如下：\n![s4-1](MethodologyFrontendEngineering/s4-1.png)\n\n常用的测试分类有`单元测试`和`集成测试`，在开发过程中使用的是单元测试，那么什么是单元测试？\n> 单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。\n\n常见的单元测试工具有：Jest、Mocha 等。\n\n一些框架内也集成了单元测试工具，可以根据具体情况选择。\n\n### `部署`\n![s5](MethodologyFrontendEngineering/s5.png)\n\n在项目的部署阶段，我们聚焦于构建和部署。\n\n在构建时需要关注性能优化、自定义配置等，常用构建工具有 webpack、rollup、vite 等，他们各有特点，这里不加赘述。\n\n在部署时需要关注自动化、易用性等，常用的部署工具有 Jenkins。\n\n其他还有灰度和 CDN 等概念，灰度可以理解为青春使用版，即新版本发布时控制流量，易于回退。CDN 技术则是优化网络访问速度。\n\n## 总结\n\n前端工程化的要义在于：把能够交给机器的事情尽量交给机器去做。\n\n其重点在于`统一`，统一的代码规范、统一的命名约定、统一的技术栈、第三方库等等。\n\n而在实际项目开发过程中，前端工程化的实践既依赖设计师、架构师对于项目的先期构建，更强调开发团队间的意见交流。了解工程化概念，明晰其目的，才能避免重复造轮子，代码结构混杂不清等疏漏，提高代码复用性和健壮性。\n\n## 参考资料\n- [带你入门前端工程](https://woai3c.gitee.io/introduction-to-front-end-engineering/#%E7%AE%80%E4%BB%8B)\n- [浅谈什么是前端工程化\t](https://www.cnblogs.com/fsyz/p/8274727.html)\n- [大型项目前端架构浅谈](https://juejin.cn/post/6844903853859536903)","slug":"MethodologyFrontendEngineering","published":1,"updated":"2023-03-15T03:22:16.553Z","_id":"clf92ycgw00097gh81wl09fyl","comments":1,"layout":"post","photos":[],"link":"","content":"<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s0.png\"\n                      class=\"\" title=\"s0\"\n                >\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目开发中常常听到前端工程化，那么什么是前端工程化，其要义在于何处，我想是值得了解的问题。</p>\n<p>它有哪些目的，解决了哪些问题，又以何种方式实现，这些都是值得探究、值得思考的。</p>\n<h2 id=\"什么是前端工程化？\"><a href=\"#什么是前端工程化？\" class=\"headerlink\" title=\"什么是前端工程化？\"></a>什么是前端工程化？</h2><p>关于什么是前端工程化，这里先给出我的理解：</p>\n<ul>\n<li>狭义上的理解：将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署</li>\n<li>广义上理解：前端工程化应该包含从编码开始到发布，运行和维护阶段</li>\n</ul>\n<p>简而言之，在前端规模越来越大，业务逻辑越来越复杂的今天，一切可以<code>提高效率、降低成本、质量保证</code>的手段都可以称得上是前端工程化。如果说软件工程是面向问题的（将软件开发流程中的共性抽离出来），把软件工程的思想带入到前端开发中，就是前端工程化。</p>\n<p>一个前端项目的开发流程可以概括为：</p>\n<blockquote>\n<p>需求分析–&gt;<code>设计阶段</code>–&gt;<code>开发阶段</code>(–&gt;测试阶段–&gt;部署阶段）–&gt;项目维护</p>\n</blockquote>\n<p>也可以说，前端工程化主要发生在设计阶段和开发阶段，解决的是<code>开发阶段到项目维护阶段</code>的生产效率问题。</p>\n<h2 id=\"前端工程化要解决哪些问题？\"><a href=\"#前端工程化要解决哪些问题？\" class=\"headerlink\" title=\"前端工程化要解决哪些问题？\"></a>前端工程化要解决哪些问题？</h2><p>在项目过程中，一些问题是共通的，在设计阶段，需要考虑：</p>\n<ol>\n<li>怎样提高开发效率，降低开发成本？</li>\n<li>怎样提高代码健壮性、降低维护难度？</li>\n</ol>\n<p>在开发阶段，需要考虑的问题有：</p>\n<ol>\n<li>代码审查</li>\n<li>压缩打包</li>\n<li>单元测试</li>\n<li>增量更新</li>\n</ol>\n<h2 id=\"如何实现前端工程化？\"><a href=\"#如何实现前端工程化？\" class=\"headerlink\" title=\"如何实现前端工程化？\"></a>如何实现前端工程化？</h2><h3 id=\"设计阶段\"><a href=\"#设计阶段\" class=\"headerlink\" title=\"设计阶段\"></a>设计阶段</h3><p>根据前文，能够知道在设计阶段面临的一些问题，那么怎么解决呢？</p>\n<p>我们需要知道前端项目在设计阶段要做的一些事情：技术选型、确立规范、排期、分工。</p>\n<p>而技术选型和确立规范就是其中的重中之重。</p>\n<p><code>技术选型</code></p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s1.png\"\n                      class=\"\" title=\"s1\"\n                >\n<p>无论是技术框架、编程语言、工具库、UI 库，都属于技术选型的范畴。</p>\n<p>一般要遵循的原则有 4 点：</p>\n<ol>\n<li>可控性</li>\n<li>稳定性</li>\n<li>适用性</li>\n<li>易用性</li>\n</ol>\n<p>一般来说，前端项目选择的框架是 Vue、React、Angular 的一种，根据项目规模和团队技术栈选择其他的工具库、UI 库。</p>\n<p>关于技术选型，可以看看这篇文章 <a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/346410244\" >技术选型 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><code>统一规范</code></p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s2.png\"\n                      class=\"\" title=\"s2\"\n                >\n\n<p>根据项目规模的不同，统一规范的重要性也不可一概而论，但总的来说，统一规范的重要性是随着项目复杂度的提升而提升的。</p>\n<p>有哪些地方需要统一规范呢？</p>\n<ul>\n<li>代码格式化：eslint、tslint</li>\n<li>代码提交规范：可以使用 git 的钩子函数自定义</li>\n<li>设计规范：由需求设计人员提供</li>\n<li>文档规范：注明公共 API、全局变量等</li>\n<li>一些约定：<ul>\n<li>目录结构约定：在什么地方做什么事</li>\n<li>命名约定：变量、函数、css 类</li>\n<li>版本管理</li>\n<li>开发流程</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开发阶段\"><a href=\"#开发阶段\" class=\"headerlink\" title=\"开发阶段\"></a>开发阶段</h2><h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a><code>开发</code></h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s3.png\"\n                      class=\"\" title=\"s3\"\n                >\n\n<p>在开发过程中，工程化主要在自建库、选择第三方库、搭建脚手架时发挥作用。</p>\n<p>自建库抽离公共函数，避免重复造轮子，应约定尽量使用自建库的方法。</p>\n<p>当自建库不能满足需求时，可以选择第三方库来弥补，第三方库应该关注安全性、稳定性、采取最小限度原则（即只使用必要的部分）。</p>\n<p>自定义工程脚手架也是非常重要的一部分，可以大大降低重复工作量，脚手架实践了<code>能够交给机器的事情就交给机器去做</code>这一思想。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><code>测试</code></h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s4.png\"\n                      class=\"\" title=\"s4\"\n                >\n\n<p>无论是什么项目，只要它仍在开发迭代，测试就是必要的一环。</p>\n<p>一个完整的项目开发流程图如下：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s4-1.png\"\n                      class=\"\" title=\"s4-1\"\n                >\n\n<p>常用的测试分类有<code>单元测试</code>和<code>集成测试</code>，在开发过程中使用的是单元测试，那么什么是单元测试？</p>\n<blockquote>\n<p>单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p>\n</blockquote>\n<p>常见的单元测试工具有：Jest、Mocha 等。</p>\n<p>一些框架内也集成了单元测试工具，可以根据具体情况选择。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a><code>部署</code></h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s5.png\"\n                      class=\"\" title=\"s5\"\n                >\n\n<p>在项目的部署阶段，我们聚焦于构建和部署。</p>\n<p>在构建时需要关注性能优化、自定义配置等，常用构建工具有 webpack、rollup、vite 等，他们各有特点，这里不加赘述。</p>\n<p>在部署时需要关注自动化、易用性等，常用的部署工具有 Jenkins。</p>\n<p>其他还有灰度和 CDN 等概念，灰度可以理解为青春使用版，即新版本发布时控制流量，易于回退。CDN 技术则是优化网络访问速度。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>前端工程化的要义在于：把能够交给机器的事情尽量交给机器去做。</p>\n<p>其重点在于<code>统一</code>，统一的代码规范、统一的命名约定、统一的技术栈、第三方库等等。</p>\n<p>而在实际项目开发过程中，前端工程化的实践既依赖设计师、架构师对于项目的先期构建，更强调开发团队间的意见交流。了解工程化概念，明晰其目的，才能避免重复造轮子，代码结构混杂不清等疏漏，提高代码复用性和健壮性。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a class=\"link\"   href=\"https://woai3c.gitee.io/introduction-to-front-end-engineering/#%E7%AE%80%E4%BB%8B\" >带你入门前端工程 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/fsyz/p/8274727.html\" >浅谈什么是前端工程化\t <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://juejin.cn/post/6844903853859536903\" >大型项目前端架构浅谈 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s0.png\"\n                      class=\"\" title=\"s0\"\n                >\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在项目开发中常常听到前端工程化，那么什么是前端工程化，其要义在于何处，我想是值得了解的问题。</p>\n<p>它有哪些目的，解决了哪些问题，又以何种方式实现，这些都是值得探究、值得思考的。</p>\n<h2 id=\"什么是前端工程化？\"><a href=\"#什么是前端工程化？\" class=\"headerlink\" title=\"什么是前端工程化？\"></a>什么是前端工程化？</h2><p>关于什么是前端工程化，这里先给出我的理解：</p>\n<ul>\n<li>狭义上的理解：将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署</li>\n<li>广义上理解：前端工程化应该包含从编码开始到发布，运行和维护阶段</li>\n</ul>\n<p>简而言之，在前端规模越来越大，业务逻辑越来越复杂的今天，一切可以<code>提高效率、降低成本、质量保证</code>的手段都可以称得上是前端工程化。如果说软件工程是面向问题的（将软件开发流程中的共性抽离出来），把软件工程的思想带入到前端开发中，就是前端工程化。</p>\n<p>一个前端项目的开发流程可以概括为：</p>\n<blockquote>\n<p>需求分析–&gt;<code>设计阶段</code>–&gt;<code>开发阶段</code>(–&gt;测试阶段–&gt;部署阶段）–&gt;项目维护</p>\n</blockquote>\n<p>也可以说，前端工程化主要发生在设计阶段和开发阶段，解决的是<code>开发阶段到项目维护阶段</code>的生产效率问题。</p>\n<h2 id=\"前端工程化要解决哪些问题？\"><a href=\"#前端工程化要解决哪些问题？\" class=\"headerlink\" title=\"前端工程化要解决哪些问题？\"></a>前端工程化要解决哪些问题？</h2><p>在项目过程中，一些问题是共通的，在设计阶段，需要考虑：</p>\n<ol>\n<li>怎样提高开发效率，降低开发成本？</li>\n<li>怎样提高代码健壮性、降低维护难度？</li>\n</ol>\n<p>在开发阶段，需要考虑的问题有：</p>\n<ol>\n<li>代码审查</li>\n<li>压缩打包</li>\n<li>单元测试</li>\n<li>增量更新</li>\n</ol>\n<h2 id=\"如何实现前端工程化？\"><a href=\"#如何实现前端工程化？\" class=\"headerlink\" title=\"如何实现前端工程化？\"></a>如何实现前端工程化？</h2><h3 id=\"设计阶段\"><a href=\"#设计阶段\" class=\"headerlink\" title=\"设计阶段\"></a>设计阶段</h3><p>根据前文，能够知道在设计阶段面临的一些问题，那么怎么解决呢？</p>\n<p>我们需要知道前端项目在设计阶段要做的一些事情：技术选型、确立规范、排期、分工。</p>\n<p>而技术选型和确立规范就是其中的重中之重。</p>\n<p><code>技术选型</code></p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s1.png\"\n                      class=\"\" title=\"s1\"\n                >\n<p>无论是技术框架、编程语言、工具库、UI 库，都属于技术选型的范畴。</p>\n<p>一般要遵循的原则有 4 点：</p>\n<ol>\n<li>可控性</li>\n<li>稳定性</li>\n<li>适用性</li>\n<li>易用性</li>\n</ol>\n<p>一般来说，前端项目选择的框架是 Vue、React、Angular 的一种，根据项目规模和团队技术栈选择其他的工具库、UI 库。</p>\n<p>关于技术选型，可以看看这篇文章 <a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/346410244\" >技术选型 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><code>统一规范</code></p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s2.png\"\n                      class=\"\" title=\"s2\"\n                >\n\n<p>根据项目规模的不同，统一规范的重要性也不可一概而论，但总的来说，统一规范的重要性是随着项目复杂度的提升而提升的。</p>\n<p>有哪些地方需要统一规范呢？</p>\n<ul>\n<li>代码格式化：eslint、tslint</li>\n<li>代码提交规范：可以使用 git 的钩子函数自定义</li>\n<li>设计规范：由需求设计人员提供</li>\n<li>文档规范：注明公共 API、全局变量等</li>\n<li>一些约定：<ul>\n<li>目录结构约定：在什么地方做什么事</li>\n<li>命名约定：变量、函数、css 类</li>\n<li>版本管理</li>\n<li>开发流程</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开发阶段\"><a href=\"#开发阶段\" class=\"headerlink\" title=\"开发阶段\"></a>开发阶段</h2><h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a><code>开发</code></h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s3.png\"\n                      class=\"\" title=\"s3\"\n                >\n\n<p>在开发过程中，工程化主要在自建库、选择第三方库、搭建脚手架时发挥作用。</p>\n<p>自建库抽离公共函数，避免重复造轮子，应约定尽量使用自建库的方法。</p>\n<p>当自建库不能满足需求时，可以选择第三方库来弥补，第三方库应该关注安全性、稳定性、采取最小限度原则（即只使用必要的部分）。</p>\n<p>自定义工程脚手架也是非常重要的一部分，可以大大降低重复工作量，脚手架实践了<code>能够交给机器的事情就交给机器去做</code>这一思想。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><code>测试</code></h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s4.png\"\n                      class=\"\" title=\"s4\"\n                >\n\n<p>无论是什么项目，只要它仍在开发迭代，测试就是必要的一环。</p>\n<p>一个完整的项目开发流程图如下：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s4-1.png\"\n                      class=\"\" title=\"s4-1\"\n                >\n\n<p>常用的测试分类有<code>单元测试</code>和<code>集成测试</code>，在开发过程中使用的是单元测试，那么什么是单元测试？</p>\n<blockquote>\n<p>单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p>\n</blockquote>\n<p>常见的单元测试工具有：Jest、Mocha 等。</p>\n<p>一些框架内也集成了单元测试工具，可以根据具体情况选择。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a><code>部署</code></h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/07/28/MethodologyFrontendEngineering/s5.png\"\n                      class=\"\" title=\"s5\"\n                >\n\n<p>在项目的部署阶段，我们聚焦于构建和部署。</p>\n<p>在构建时需要关注性能优化、自定义配置等，常用构建工具有 webpack、rollup、vite 等，他们各有特点，这里不加赘述。</p>\n<p>在部署时需要关注自动化、易用性等，常用的部署工具有 Jenkins。</p>\n<p>其他还有灰度和 CDN 等概念，灰度可以理解为青春使用版，即新版本发布时控制流量，易于回退。CDN 技术则是优化网络访问速度。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>前端工程化的要义在于：把能够交给机器的事情尽量交给机器去做。</p>\n<p>其重点在于<code>统一</code>，统一的代码规范、统一的命名约定、统一的技术栈、第三方库等等。</p>\n<p>而在实际项目开发过程中，前端工程化的实践既依赖设计师、架构师对于项目的先期构建，更强调开发团队间的意见交流。了解工程化概念，明晰其目的，才能避免重复造轮子，代码结构混杂不清等疏漏，提高代码复用性和健壮性。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a class=\"link\"   href=\"https://woai3c.gitee.io/introduction-to-front-end-engineering/#%E7%AE%80%E4%BB%8B\" >带你入门前端工程 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/fsyz/p/8274727.html\" >浅谈什么是前端工程化\t <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://juejin.cn/post/6844903853859536903\" >大型项目前端架构浅谈 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n"},{"title":"【方法论】代码重构的一点心得","date":"2023-02-10T18:30:57.000Z","_content":"# 重构（Refactoring）\n\n## 前言\n\n最近一直在做前端重构的工作，多少有些感想，特此记录。\n\n首先，项目的历史太悠久了，AngularJS 的项目，\n\n## 一、什么是重构？为什么要重构？重构要达成什么目标？\n\n**什么是重构**\n\n在`不改变代码外在行为`的前提下，对代码进行修改，以`改进程序的内部结构`。\n\n**为什么要重构**\n\n在软件工程中，开发迭代的过程实际上是一个熵增的过程，软件系统会随着生命周期的进行变得越来越臃肿、混乱、冗余，从而增加维护与进一步迭代的成本。而重构可以`偿还技术债务、改进软件结构、减小维护和迭代的成本、增加产品可信`。\n\n**重构要达成什么目标？**\n\n1. 系统结构重新梳理：旧系统在设计上可能有许多疏漏，由于经验的欠缺或者考虑不周到，这是难以避免的。新系统应该见贤思齐、查漏补缺，例如重新设计基类、文件结构和继承关系，争取让系统更加完善。\n2. 公共资源重新梳理：\n3. 业务需求重新梳理：\n\n## 二、重构有哪些分类？什么时候重构？重构有哪些原则？\n**重构有哪些分类？**\n\n- 小粒度重构（函数级、小模块）\n- 大粒度重构（架构级、大模块）\n\n**什么时候重构？**\n\n- 新增需求时（小粒度）\n- 修改 BUG 时（小粒度）\n- 复审代码时（大粒度）\n- 代码逻辑混乱、依赖混杂（大粒度）\n\n**重构有哪些原则？**\n\n- 先评审，再重构，不要反复推翻重来\n- 确保模块的功能完整，否则不重构该模块\n- 新增需求时，不要改动既有代码（小粒度）\n- 重构既有代码时，不要新增功能（小粒度）\n\n## 三、重构工作流程\n1. 前期准备，搭架子\n   - 构建对应技术栈的文件结构、代码关系\n   - 整理公共资源、公共能力\n   - 整理业务需求，确保没有遗漏的需求\n2. 前期准备，分需求、培训（主要涉及文件结构和公共资源）\n3. 开始重构 \n \n","source":"_posts/MethodologyRefactoring.md","raw":"---\ntitle: 【方法论】代码重构的一点心得\ndate: 2023-02-11 02:30:57\ntags: [JS]\ncategories: [方法论]\n---\n# 重构（Refactoring）\n\n## 前言\n\n最近一直在做前端重构的工作，多少有些感想，特此记录。\n\n首先，项目的历史太悠久了，AngularJS 的项目，\n\n## 一、什么是重构？为什么要重构？重构要达成什么目标？\n\n**什么是重构**\n\n在`不改变代码外在行为`的前提下，对代码进行修改，以`改进程序的内部结构`。\n\n**为什么要重构**\n\n在软件工程中，开发迭代的过程实际上是一个熵增的过程，软件系统会随着生命周期的进行变得越来越臃肿、混乱、冗余，从而增加维护与进一步迭代的成本。而重构可以`偿还技术债务、改进软件结构、减小维护和迭代的成本、增加产品可信`。\n\n**重构要达成什么目标？**\n\n1. 系统结构重新梳理：旧系统在设计上可能有许多疏漏，由于经验的欠缺或者考虑不周到，这是难以避免的。新系统应该见贤思齐、查漏补缺，例如重新设计基类、文件结构和继承关系，争取让系统更加完善。\n2. 公共资源重新梳理：\n3. 业务需求重新梳理：\n\n## 二、重构有哪些分类？什么时候重构？重构有哪些原则？\n**重构有哪些分类？**\n\n- 小粒度重构（函数级、小模块）\n- 大粒度重构（架构级、大模块）\n\n**什么时候重构？**\n\n- 新增需求时（小粒度）\n- 修改 BUG 时（小粒度）\n- 复审代码时（大粒度）\n- 代码逻辑混乱、依赖混杂（大粒度）\n\n**重构有哪些原则？**\n\n- 先评审，再重构，不要反复推翻重来\n- 确保模块的功能完整，否则不重构该模块\n- 新增需求时，不要改动既有代码（小粒度）\n- 重构既有代码时，不要新增功能（小粒度）\n\n## 三、重构工作流程\n1. 前期准备，搭架子\n   - 构建对应技术栈的文件结构、代码关系\n   - 整理公共资源、公共能力\n   - 整理业务需求，确保没有遗漏的需求\n2. 前期准备，分需求、培训（主要涉及文件结构和公共资源）\n3. 开始重构 \n \n","slug":"MethodologyRefactoring","published":1,"updated":"2023-03-02T13:23:27.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ycgx000b7gh8f98z68jh","content":"<h1 id=\"重构（Refactoring）\"><a href=\"#重构（Refactoring）\" class=\"headerlink\" title=\"重构（Refactoring）\"></a>重构（Refactoring）</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近一直在做前端重构的工作，多少有些感想，特此记录。</p>\n<p>首先，项目的历史太悠久了，AngularJS 的项目，</p>\n<h2 id=\"一、什么是重构？为什么要重构？重构要达成什么目标？\"><a href=\"#一、什么是重构？为什么要重构？重构要达成什么目标？\" class=\"headerlink\" title=\"一、什么是重构？为什么要重构？重构要达成什么目标？\"></a>一、什么是重构？为什么要重构？重构要达成什么目标？</h2><p><strong>什么是重构</strong></p>\n<p>在<code>不改变代码外在行为</code>的前提下，对代码进行修改，以<code>改进程序的内部结构</code>。</p>\n<p><strong>为什么要重构</strong></p>\n<p>在软件工程中，开发迭代的过程实际上是一个熵增的过程，软件系统会随着生命周期的进行变得越来越臃肿、混乱、冗余，从而增加维护与进一步迭代的成本。而重构可以<code>偿还技术债务、改进软件结构、减小维护和迭代的成本、增加产品可信</code>。</p>\n<p><strong>重构要达成什么目标？</strong></p>\n<ol>\n<li>系统结构重新梳理：旧系统在设计上可能有许多疏漏，由于经验的欠缺或者考虑不周到，这是难以避免的。新系统应该见贤思齐、查漏补缺，例如重新设计基类、文件结构和继承关系，争取让系统更加完善。</li>\n<li>公共资源重新梳理：</li>\n<li>业务需求重新梳理：</li>\n</ol>\n<h2 id=\"二、重构有哪些分类？什么时候重构？重构有哪些原则？\"><a href=\"#二、重构有哪些分类？什么时候重构？重构有哪些原则？\" class=\"headerlink\" title=\"二、重构有哪些分类？什么时候重构？重构有哪些原则？\"></a>二、重构有哪些分类？什么时候重构？重构有哪些原则？</h2><p><strong>重构有哪些分类？</strong></p>\n<ul>\n<li>小粒度重构（函数级、小模块）</li>\n<li>大粒度重构（架构级、大模块）</li>\n</ul>\n<p><strong>什么时候重构？</strong></p>\n<ul>\n<li>新增需求时（小粒度）</li>\n<li>修改 BUG 时（小粒度）</li>\n<li>复审代码时（大粒度）</li>\n<li>代码逻辑混乱、依赖混杂（大粒度）</li>\n</ul>\n<p><strong>重构有哪些原则？</strong></p>\n<ul>\n<li>先评审，再重构，不要反复推翻重来</li>\n<li>确保模块的功能完整，否则不重构该模块</li>\n<li>新增需求时，不要改动既有代码（小粒度）</li>\n<li>重构既有代码时，不要新增功能（小粒度）</li>\n</ul>\n<h2 id=\"三、重构工作流程\"><a href=\"#三、重构工作流程\" class=\"headerlink\" title=\"三、重构工作流程\"></a>三、重构工作流程</h2><ol>\n<li>前期准备，搭架子<ul>\n<li>构建对应技术栈的文件结构、代码关系</li>\n<li>整理公共资源、公共能力</li>\n<li>整理业务需求，确保没有遗漏的需求</li>\n</ul>\n</li>\n<li>前期准备，分需求、培训（主要涉及文件结构和公共资源）</li>\n<li>开始重构</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"重构（Refactoring）\"><a href=\"#重构（Refactoring）\" class=\"headerlink\" title=\"重构（Refactoring）\"></a>重构（Refactoring）</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近一直在做前端重构的工作，多少有些感想，特此记录。</p>\n<p>首先，项目的历史太悠久了，AngularJS 的项目，</p>\n<h2 id=\"一、什么是重构？为什么要重构？重构要达成什么目标？\"><a href=\"#一、什么是重构？为什么要重构？重构要达成什么目标？\" class=\"headerlink\" title=\"一、什么是重构？为什么要重构？重构要达成什么目标？\"></a>一、什么是重构？为什么要重构？重构要达成什么目标？</h2><p><strong>什么是重构</strong></p>\n<p>在<code>不改变代码外在行为</code>的前提下，对代码进行修改，以<code>改进程序的内部结构</code>。</p>\n<p><strong>为什么要重构</strong></p>\n<p>在软件工程中，开发迭代的过程实际上是一个熵增的过程，软件系统会随着生命周期的进行变得越来越臃肿、混乱、冗余，从而增加维护与进一步迭代的成本。而重构可以<code>偿还技术债务、改进软件结构、减小维护和迭代的成本、增加产品可信</code>。</p>\n<p><strong>重构要达成什么目标？</strong></p>\n<ol>\n<li>系统结构重新梳理：旧系统在设计上可能有许多疏漏，由于经验的欠缺或者考虑不周到，这是难以避免的。新系统应该见贤思齐、查漏补缺，例如重新设计基类、文件结构和继承关系，争取让系统更加完善。</li>\n<li>公共资源重新梳理：</li>\n<li>业务需求重新梳理：</li>\n</ol>\n<h2 id=\"二、重构有哪些分类？什么时候重构？重构有哪些原则？\"><a href=\"#二、重构有哪些分类？什么时候重构？重构有哪些原则？\" class=\"headerlink\" title=\"二、重构有哪些分类？什么时候重构？重构有哪些原则？\"></a>二、重构有哪些分类？什么时候重构？重构有哪些原则？</h2><p><strong>重构有哪些分类？</strong></p>\n<ul>\n<li>小粒度重构（函数级、小模块）</li>\n<li>大粒度重构（架构级、大模块）</li>\n</ul>\n<p><strong>什么时候重构？</strong></p>\n<ul>\n<li>新增需求时（小粒度）</li>\n<li>修改 BUG 时（小粒度）</li>\n<li>复审代码时（大粒度）</li>\n<li>代码逻辑混乱、依赖混杂（大粒度）</li>\n</ul>\n<p><strong>重构有哪些原则？</strong></p>\n<ul>\n<li>先评审，再重构，不要反复推翻重来</li>\n<li>确保模块的功能完整，否则不重构该模块</li>\n<li>新增需求时，不要改动既有代码（小粒度）</li>\n<li>重构既有代码时，不要新增功能（小粒度）</li>\n</ul>\n<h2 id=\"三、重构工作流程\"><a href=\"#三、重构工作流程\" class=\"headerlink\" title=\"三、重构工作流程\"></a>三、重构工作流程</h2><ol>\n<li>前期准备，搭架子<ul>\n<li>构建对应技术栈的文件结构、代码关系</li>\n<li>整理公共资源、公共能力</li>\n<li>整理业务需求，确保没有遗漏的需求</li>\n</ul>\n</li>\n<li>前期准备，分需求、培训（主要涉及文件结构和公共资源）</li>\n<li>开始重构</li>\n</ol>\n"},{"title":"【方法论】JS 执行流程","date":"2023-02-20T16:56:48.000Z","_content":"\n## `前言`\n\n本文主要解释 JS 引擎在遇见 script 代码块时，从编译到执行具体经历了些什么？\n\n一些关于作用域与闭包还有`this`关键字的问题可能被解答：\n\n- 为什么会产生变量提升？\n- 闭包的产生原理是什么？\n- 多个 script 代码块间是以什么顺序来执行的？\n- 为什么定义在不同代码块间的方法可以共通？通过本文都可以得到解答。\n\n## `基础概念`\n\n- JavaScript 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。\n  `解释型`：JS 引擎在运行 JS 代码时，是利用解释器一边编译一边执行的。\n  \n  如此便避免不了一种情况：某些代码多次重复的运行，例如 for 循环，在编译型语言中，for 循环块中的代码将以机器码执行多次；而在解释型语言中，for 循环块中的代码将被解释多次并执行，如此便有了很大的耗损。\n  \n  `即时编译型`：于是 JS 引擎就加入了`JIT`（Just-in-time）进行编译优化，例如对重复语句和类型判断进行优化。\n\n- 引擎、编译器与作用域\n    引擎：从头到尾负责整个 javascript 程序的编译及执行过程。浏览器不同，其引擎也不同，比如 Chrome 采用的是 v8，Safari 采用的是 SquirrelFish Extreme。\n    \n    编译器：编译过程主要分为”词法分析”、“语法分析”及“代码生成“。\n    >\n    作用域（Scope）：根据名称查找变量的一套规则，用于管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。\n\n- 执行上下文（Excution Context EC）&& 执行上下文栈（Excution Context Stack ECS）\n    存在三种 EC：全局执行上下文  GlobalEC ，函数执行上下文  Function EC，Eval。\n    \n    ECS：引擎记录 EC 的容器，栈底是 GlobalEC ，只有在关闭页面时出栈；栈顶是当前正在执行的 EC ，函数执行完毕后出栈，并将执行权交给下一个 EC 。\n\n- 变量对象（Variable Object）&& 活动对象（Activation Object）\n    VO：EC 中用来存储变量声明（必须是 var 关键字声明而不是 let 与 const）与函数声明（必须是显式声明而不是表达式）的容器。由引擎实现，不能访问到。\n    \n    AO：可以理解为 VO 的实例化，函数调用时在 EC 中被激活，成员属性能被访问。\n\n- LHS（Left Hand Side） && RHS（Right Hand Side）\n    LHS：赋值操作的目标。例如：a=2; 是对 a 进行 LHS 查询。\n    \n    RHS：赋值操作的源头。例如：console.log(a); 是对 a 进行 RHS 查询。\n    >\n    非严格模式下，LHS 查询不到变量会在顶层作用域创建具有该名称的变量，RHS 查询不到变量会报 ReferenceError 的异常；严格模式下禁止自动创建全局变量，两种查询方式失败均报 ReferenceError 的异常。\n\n## `JS 代码执行流程`\n\n1. -->进入 script 标签\n2. -->【预编译】JS 引擎创建全局 EC，全局 EC 入栈\n3. -->【编译】JS 解释器开始对代码`逐行`进行分词、语法分析、代码生成\n4. -->有错则抛出，终止执行；无错继续向下逐行执行\n5. -->【预编译】调用函数前，创建函数 EC，EC 入栈\n6. -->【编译】\n7. -->有错则抛出，终止执行；无错继续向下执行\n8. -->函数执行完毕，EC 出栈\n9. -->继续以上步骤\n10. -->页面销毁，全局 EC 出栈\n11. -->结束\n\n`创建当前环境 EC 流程如下：`\n\n1、初始化作用域 [[Scope]]，（拷贝传入的父执行上下文的 Scope），数据结构应该是数组或者链表。\n \n例如：[[Scope]] : AO1（当前）-->VO（全局）\n\n2、创建活动对象，创建完成之后，将活动对象推入作用域链的最前端：\n\n例如：[[Scope]] : AO2（当前）-->AO1（父级）-->VO（全局）\n\n2.1、创建 arguments 对象，检查上下文，初始化参数名称和值并创建引用的复制。（函数中存在）\n\n2.2、创建形参，通过实参赋值。（函数中存在）\n\n2.3、扫描上下文的函数声明（而非函数表达式）：\n\n为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。如果函数的名字已经存在，引用指针将被重写。函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值\n\n2.4、扫描上下文的变量声明：\n\n为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为 undefined，如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。\n\n3、求出上下文内部 this 的值。\n\n> 从以上流程中可以观察到`作用域、变量提升和 this`，接下来结合代码具体分析。\n\n## `代码分析`\n\n1、EC 创建流程与变量提升\n```javascript\nvar a = \"outer\";\n\nfunction foo(i) {\n    console.log(a+'--a--start');\n    console.log(b+'--b--start');\n    console.log(c+'--c--start');\n    var a = 'hello';\n    var b = function () {};\n\n    function c() {};\n    console.log(`------------`);\n    console.log(a+'--a--end');\n    console.log(b+'--b--end');\n    console.log(c+'--c--end');\n\n    console.log(this);\n}\n\nfoo(22);// 对形参 i 的 LHS 查询\n\n//结果：\nundefined--a--start// 变量 a 声明时提升赋值为 undefined\nundefined--b--start// 变量 b 声明时提升赋值为 undefined\nƒ c() {}--c--start// 函数 c 声明时提升指向 c 的引用\n------------\nhello--a--end// 此时赋值语句执行完毕，a 的值为 hello\nƒ() {}--b--end// 此时赋值语句执行完毕，b 指向 b 的引用\nƒ c() {}--c--end// 无变化\n\n// 分析\n// 代码载入前，创建全局 EC 的伪代码\nGlobalEC : {\n    [[Scope]] : [{VO}],\n    VO : {\n        foo : fnFoo,// 函数声明优先，指向函数 Foo 的引用\n        a :  undefined// 变量声明\n    },\n    this// 指向全局\n}\n// 调用函数 foo(22) 时，创建当前 EC 的伪代码\nCurrentEC : {\n    [[Scope]] : [{AO}, {VO}],\n    AO : {\n        // 顺序：arguments 对象 形参 函数声明 变量声明\n        arguments : {\n            0 : 22,\n            length : 1\n        },\n        i : 22,// 形参，接受实参赋值\n        c : fnC,//指向函数 c 的引用\n        a : undefined,\n        b : undefined\n    },\n    this// 指向函数的调用者，这里指向全局\n}\n```\n\n2、多个 script 块间的执行过程\n```html\n\n <script>\n     console.log('script1 start');\n\n     console.log('a',a);\n     var b=2;\n\n     console.log('script1 end');\n </script>\n\n <script>\n     console.log('script2 start');\n\n     var a=1;\n     console.log('b',b);\n\n     console.log('script2 end');\n </script>\n\n <!-- \n     script1 start\n     Uncaught ReferenceError: a is not defined\n     script2 start\n     b undefined\n     script2 end\n  -->\n\n<!--\n 1、从代码运行结果可以看出，JS 执行流在进入第一个 script 块时，首先会创建全局 EC ，将 b 的声明加入 AO 并推入作用域中（所以第二个 script 块中的代码才能访问到 b），全局 EC 压入 ECS。\n 2、逐行的进行分词、语法检查、代码生成，然后执行。\n     2.1、在 console.log('script1 start'); 这行代码中，不存在语法错误，执行，输出 start。\n     2.2、在 console.log('a',a); 这行代码中，对变量 a 进行 RHS 查询，在作用域链中找不到 a ，报 ReferenceError，script 块中断执行。\n 3、JS 执行流进入第二个 script 块，仍然在全局 EC（JS 引擎只会存在一个全局 EC），将 a 的声明加入 AO（与第一个代码块相同，每个 EC 绑定唯一的 VO|AO） 并推入作用域。\n 4、逐行的进行分词、语法检查、代码生成，然后执行。\n     4.1、在 console.log('b',b); 这行代码中，对变量 b 进行 RHS 查询，在作用域的 AO 中找到对应的值 undefined，输出 b undefined。\n \n 结束\n-->\n ```\n\n3、闭包的产生\n```javascript\n\n// 首先明确什么是闭包？可以使用如下定义：\n// 函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。\n\n// 例子\nfunction fn(){\n    var a = 'JavaScript';\n    function func(){\n        console.log(a);\n    }\n    return func;\n}\n\nvar func = fn();\nfunc(); // JavaScript\n\n// func 函数执行的位置和定义的位置是不相同的，func 是在函数 fn 中定义的，但执行却是在全局环境中，虽然是在全局函数中执行的，但函数仍然可以访问当定义时的词法作用域。\n\n// 当函数执行结束后其活动变量就会被销毁，但是在上面的例子中却不是这个样子。但函数 fn 执行结束之后，fn 对象的活动变量并没有被销毁，这是因为 fn 返回的函数 func 的作用域链还保持着 fn 的活动变量，因此 JavaScript 的垃圾回收机制不会回收 fn 活动变量。虽然返回的函数 func 是在全局环境下执行的，但是其作用域链的存储的活动（变量）对象的顺序分别是：func 的活动对象、fn 的活动对象、全局变量对象。因此在 func 函数执行时，会顺着作用域链查找标识符，也就能访问到 fn 所定义的词法作用域（即 fn 函数的活动变量）也就不足为奇了。\n```\n\n## `总结`\n\n问：多个 script 块间的执行顺序\n\n> 答：多个 script 代码块从上到下按序载入，语法分析阶段报错的话，结束本代码块的执行，执行流进入下一个代码块。多个代码块共享全局执行上下文，可以访问到其他代码块定义的变量和方法。\n\n问：为什么会产生变量提升与函数提升？\n> 答：在代码执行之前的预编译阶段，创建当前 EC 时，会在活动对象上创建一个与函数声明与变量声明对应的属性，然后将活动对象推入作用域链。在查询变量时，是通过作用域链进行 RHS 查询。所以会查询到作用域链上已经定义的函数与变量。\n\n问：闭包的产生\n> 答：简单来说，闭包中的函数所对应的作用域链上仍然保留了父级活动对象，所以可以对父级活动对象的属性进行查询。\n\n## `参考资料`\n\n- 《你不知道的 Javascript》（上卷），第一部分，作用域和闭包\n- [JS 引擎的执行过程](https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/)\n- [彻底明白作用域、执行上下文](https://segmentfault.com/a/1190000013915935)\n- [深入理解 JavaScript 的执行流程，执行上下文 EC、变量对象 VO、活动对象 AO、作用域 Scope](https://blog.csdn.net/yangxinxiang84/article/details/113051811?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328641.10297.16155372256670345&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)\n- [浅谈 JS 的 VO|AO](https://blog.csdn.net/Ancecis/article/details/104382441)\n- [JS 运行机制之执行顺序](https://blog.csdn.net/chen_zw/article/details/18502937?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control)\n- [我所认识的作用域链与原型链](https://github.com/MrErHu/blog/issues/16)\n","source":"_posts/MethodologyJSExcutionProcess.md","raw":"---\ntitle: 【方法论】JS 执行流程\ndate: 2023-02-21 00:56:48\ntags: [JS, 前端工程化]\ncategories: [方法论]\n---\n\n## `前言`\n\n本文主要解释 JS 引擎在遇见 script 代码块时，从编译到执行具体经历了些什么？\n\n一些关于作用域与闭包还有`this`关键字的问题可能被解答：\n\n- 为什么会产生变量提升？\n- 闭包的产生原理是什么？\n- 多个 script 代码块间是以什么顺序来执行的？\n- 为什么定义在不同代码块间的方法可以共通？通过本文都可以得到解答。\n\n## `基础概念`\n\n- JavaScript 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。\n  `解释型`：JS 引擎在运行 JS 代码时，是利用解释器一边编译一边执行的。\n  \n  如此便避免不了一种情况：某些代码多次重复的运行，例如 for 循环，在编译型语言中，for 循环块中的代码将以机器码执行多次；而在解释型语言中，for 循环块中的代码将被解释多次并执行，如此便有了很大的耗损。\n  \n  `即时编译型`：于是 JS 引擎就加入了`JIT`（Just-in-time）进行编译优化，例如对重复语句和类型判断进行优化。\n\n- 引擎、编译器与作用域\n    引擎：从头到尾负责整个 javascript 程序的编译及执行过程。浏览器不同，其引擎也不同，比如 Chrome 采用的是 v8，Safari 采用的是 SquirrelFish Extreme。\n    \n    编译器：编译过程主要分为”词法分析”、“语法分析”及“代码生成“。\n    >\n    作用域（Scope）：根据名称查找变量的一套规则，用于管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。\n\n- 执行上下文（Excution Context EC）&& 执行上下文栈（Excution Context Stack ECS）\n    存在三种 EC：全局执行上下文  GlobalEC ，函数执行上下文  Function EC，Eval。\n    \n    ECS：引擎记录 EC 的容器，栈底是 GlobalEC ，只有在关闭页面时出栈；栈顶是当前正在执行的 EC ，函数执行完毕后出栈，并将执行权交给下一个 EC 。\n\n- 变量对象（Variable Object）&& 活动对象（Activation Object）\n    VO：EC 中用来存储变量声明（必须是 var 关键字声明而不是 let 与 const）与函数声明（必须是显式声明而不是表达式）的容器。由引擎实现，不能访问到。\n    \n    AO：可以理解为 VO 的实例化，函数调用时在 EC 中被激活，成员属性能被访问。\n\n- LHS（Left Hand Side） && RHS（Right Hand Side）\n    LHS：赋值操作的目标。例如：a=2; 是对 a 进行 LHS 查询。\n    \n    RHS：赋值操作的源头。例如：console.log(a); 是对 a 进行 RHS 查询。\n    >\n    非严格模式下，LHS 查询不到变量会在顶层作用域创建具有该名称的变量，RHS 查询不到变量会报 ReferenceError 的异常；严格模式下禁止自动创建全局变量，两种查询方式失败均报 ReferenceError 的异常。\n\n## `JS 代码执行流程`\n\n1. -->进入 script 标签\n2. -->【预编译】JS 引擎创建全局 EC，全局 EC 入栈\n3. -->【编译】JS 解释器开始对代码`逐行`进行分词、语法分析、代码生成\n4. -->有错则抛出，终止执行；无错继续向下逐行执行\n5. -->【预编译】调用函数前，创建函数 EC，EC 入栈\n6. -->【编译】\n7. -->有错则抛出，终止执行；无错继续向下执行\n8. -->函数执行完毕，EC 出栈\n9. -->继续以上步骤\n10. -->页面销毁，全局 EC 出栈\n11. -->结束\n\n`创建当前环境 EC 流程如下：`\n\n1、初始化作用域 [[Scope]]，（拷贝传入的父执行上下文的 Scope），数据结构应该是数组或者链表。\n \n例如：[[Scope]] : AO1（当前）-->VO（全局）\n\n2、创建活动对象，创建完成之后，将活动对象推入作用域链的最前端：\n\n例如：[[Scope]] : AO2（当前）-->AO1（父级）-->VO（全局）\n\n2.1、创建 arguments 对象，检查上下文，初始化参数名称和值并创建引用的复制。（函数中存在）\n\n2.2、创建形参，通过实参赋值。（函数中存在）\n\n2.3、扫描上下文的函数声明（而非函数表达式）：\n\n为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。如果函数的名字已经存在，引用指针将被重写。函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值\n\n2.4、扫描上下文的变量声明：\n\n为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为 undefined，如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。\n\n3、求出上下文内部 this 的值。\n\n> 从以上流程中可以观察到`作用域、变量提升和 this`，接下来结合代码具体分析。\n\n## `代码分析`\n\n1、EC 创建流程与变量提升\n```javascript\nvar a = \"outer\";\n\nfunction foo(i) {\n    console.log(a+'--a--start');\n    console.log(b+'--b--start');\n    console.log(c+'--c--start');\n    var a = 'hello';\n    var b = function () {};\n\n    function c() {};\n    console.log(`------------`);\n    console.log(a+'--a--end');\n    console.log(b+'--b--end');\n    console.log(c+'--c--end');\n\n    console.log(this);\n}\n\nfoo(22);// 对形参 i 的 LHS 查询\n\n//结果：\nundefined--a--start// 变量 a 声明时提升赋值为 undefined\nundefined--b--start// 变量 b 声明时提升赋值为 undefined\nƒ c() {}--c--start// 函数 c 声明时提升指向 c 的引用\n------------\nhello--a--end// 此时赋值语句执行完毕，a 的值为 hello\nƒ() {}--b--end// 此时赋值语句执行完毕，b 指向 b 的引用\nƒ c() {}--c--end// 无变化\n\n// 分析\n// 代码载入前，创建全局 EC 的伪代码\nGlobalEC : {\n    [[Scope]] : [{VO}],\n    VO : {\n        foo : fnFoo,// 函数声明优先，指向函数 Foo 的引用\n        a :  undefined// 变量声明\n    },\n    this// 指向全局\n}\n// 调用函数 foo(22) 时，创建当前 EC 的伪代码\nCurrentEC : {\n    [[Scope]] : [{AO}, {VO}],\n    AO : {\n        // 顺序：arguments 对象 形参 函数声明 变量声明\n        arguments : {\n            0 : 22,\n            length : 1\n        },\n        i : 22,// 形参，接受实参赋值\n        c : fnC,//指向函数 c 的引用\n        a : undefined,\n        b : undefined\n    },\n    this// 指向函数的调用者，这里指向全局\n}\n```\n\n2、多个 script 块间的执行过程\n```html\n\n <script>\n     console.log('script1 start');\n\n     console.log('a',a);\n     var b=2;\n\n     console.log('script1 end');\n </script>\n\n <script>\n     console.log('script2 start');\n\n     var a=1;\n     console.log('b',b);\n\n     console.log('script2 end');\n </script>\n\n <!-- \n     script1 start\n     Uncaught ReferenceError: a is not defined\n     script2 start\n     b undefined\n     script2 end\n  -->\n\n<!--\n 1、从代码运行结果可以看出，JS 执行流在进入第一个 script 块时，首先会创建全局 EC ，将 b 的声明加入 AO 并推入作用域中（所以第二个 script 块中的代码才能访问到 b），全局 EC 压入 ECS。\n 2、逐行的进行分词、语法检查、代码生成，然后执行。\n     2.1、在 console.log('script1 start'); 这行代码中，不存在语法错误，执行，输出 start。\n     2.2、在 console.log('a',a); 这行代码中，对变量 a 进行 RHS 查询，在作用域链中找不到 a ，报 ReferenceError，script 块中断执行。\n 3、JS 执行流进入第二个 script 块，仍然在全局 EC（JS 引擎只会存在一个全局 EC），将 a 的声明加入 AO（与第一个代码块相同，每个 EC 绑定唯一的 VO|AO） 并推入作用域。\n 4、逐行的进行分词、语法检查、代码生成，然后执行。\n     4.1、在 console.log('b',b); 这行代码中，对变量 b 进行 RHS 查询，在作用域的 AO 中找到对应的值 undefined，输出 b undefined。\n \n 结束\n-->\n ```\n\n3、闭包的产生\n```javascript\n\n// 首先明确什么是闭包？可以使用如下定义：\n// 函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。\n\n// 例子\nfunction fn(){\n    var a = 'JavaScript';\n    function func(){\n        console.log(a);\n    }\n    return func;\n}\n\nvar func = fn();\nfunc(); // JavaScript\n\n// func 函数执行的位置和定义的位置是不相同的，func 是在函数 fn 中定义的，但执行却是在全局环境中，虽然是在全局函数中执行的，但函数仍然可以访问当定义时的词法作用域。\n\n// 当函数执行结束后其活动变量就会被销毁，但是在上面的例子中却不是这个样子。但函数 fn 执行结束之后，fn 对象的活动变量并没有被销毁，这是因为 fn 返回的函数 func 的作用域链还保持着 fn 的活动变量，因此 JavaScript 的垃圾回收机制不会回收 fn 活动变量。虽然返回的函数 func 是在全局环境下执行的，但是其作用域链的存储的活动（变量）对象的顺序分别是：func 的活动对象、fn 的活动对象、全局变量对象。因此在 func 函数执行时，会顺着作用域链查找标识符，也就能访问到 fn 所定义的词法作用域（即 fn 函数的活动变量）也就不足为奇了。\n```\n\n## `总结`\n\n问：多个 script 块间的执行顺序\n\n> 答：多个 script 代码块从上到下按序载入，语法分析阶段报错的话，结束本代码块的执行，执行流进入下一个代码块。多个代码块共享全局执行上下文，可以访问到其他代码块定义的变量和方法。\n\n问：为什么会产生变量提升与函数提升？\n> 答：在代码执行之前的预编译阶段，创建当前 EC 时，会在活动对象上创建一个与函数声明与变量声明对应的属性，然后将活动对象推入作用域链。在查询变量时，是通过作用域链进行 RHS 查询。所以会查询到作用域链上已经定义的函数与变量。\n\n问：闭包的产生\n> 答：简单来说，闭包中的函数所对应的作用域链上仍然保留了父级活动对象，所以可以对父级活动对象的属性进行查询。\n\n## `参考资料`\n\n- 《你不知道的 Javascript》（上卷），第一部分，作用域和闭包\n- [JS 引擎的执行过程](https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/)\n- [彻底明白作用域、执行上下文](https://segmentfault.com/a/1190000013915935)\n- [深入理解 JavaScript 的执行流程，执行上下文 EC、变量对象 VO、活动对象 AO、作用域 Scope](https://blog.csdn.net/yangxinxiang84/article/details/113051811?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328641.10297.16155372256670345&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)\n- [浅谈 JS 的 VO|AO](https://blog.csdn.net/Ancecis/article/details/104382441)\n- [JS 运行机制之执行顺序](https://blog.csdn.net/chen_zw/article/details/18502937?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control)\n- [我所认识的作用域链与原型链](https://github.com/MrErHu/blog/issues/16)\n","slug":"MethodologyJSExcutionProcess","published":1,"updated":"2023-03-02T13:23:26.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ycgz000f7gh809yehfz3","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><code>前言</code></h2><p>本文主要解释 JS 引擎在遇见 script 代码块时，从编译到执行具体经历了些什么？</p>\n<p>一些关于作用域与闭包还有<code>this</code>关键字的问题可能被解答：</p>\n<ul>\n<li>为什么会产生变量提升？</li>\n<li>闭包的产生原理是什么？</li>\n<li>多个 script 代码块间是以什么顺序来执行的？</li>\n<li>为什么定义在不同代码块间的方法可以共通？通过本文都可以得到解答。</li>\n</ul>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a><code>基础概念</code></h2><ul>\n<li><p>JavaScript 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。<br><code>解释型</code>：JS 引擎在运行 JS 代码时，是利用解释器一边编译一边执行的。</p>\n<p>如此便避免不了一种情况：某些代码多次重复的运行，例如 for 循环，在编译型语言中，for 循环块中的代码将以机器码执行多次；而在解释型语言中，for 循环块中的代码将被解释多次并执行，如此便有了很大的耗损。</p>\n<p><code>即时编译型</code>：于是 JS 引擎就加入了<code>JIT</code>（Just-in-time）进行编译优化，例如对重复语句和类型判断进行优化。</p>\n</li>\n<li><p>引擎、编译器与作用域<br>  引擎：从头到尾负责整个 javascript 程序的编译及执行过程。浏览器不同，其引擎也不同，比如 Chrome 采用的是 v8，Safari 采用的是 SquirrelFish Extreme。</p>\n<p>  编译器：编译过程主要分为”词法分析”、“语法分析”及“代码生成“。</p>\n<blockquote>\n</blockquote>\n<p>  作用域（Scope）：根据名称查找变量的一套规则，用于管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p>\n</li>\n<li><p>执行上下文（Excution Context EC）&amp;&amp; 执行上下文栈（Excution Context Stack ECS）<br>  存在三种 EC：全局执行上下文  GlobalEC ，函数执行上下文  Function EC，Eval。</p>\n<p>  ECS：引擎记录 EC 的容器，栈底是 GlobalEC ，只有在关闭页面时出栈；栈顶是当前正在执行的 EC ，函数执行完毕后出栈，并将执行权交给下一个 EC 。</p>\n</li>\n<li><p>变量对象（Variable Object）&amp;&amp; 活动对象（Activation Object）<br>  VO：EC 中用来存储变量声明（必须是 var 关键字声明而不是 let 与 const）与函数声明（必须是显式声明而不是表达式）的容器。由引擎实现，不能访问到。</p>\n<p>  AO：可以理解为 VO 的实例化，函数调用时在 EC 中被激活，成员属性能被访问。</p>\n</li>\n<li><p>LHS（Left Hand Side） &amp;&amp; RHS（Right Hand Side）<br>  LHS：赋值操作的目标。例如：a&#x3D;2; 是对 a 进行 LHS 查询。</p>\n<p>  RHS：赋值操作的源头。例如：console.log(a); 是对 a 进行 RHS 查询。</p>\n<blockquote>\n</blockquote>\n<p>  非严格模式下，LHS 查询不到变量会在顶层作用域创建具有该名称的变量，RHS 查询不到变量会报 ReferenceError 的异常；严格模式下禁止自动创建全局变量，两种查询方式失败均报 ReferenceError 的异常。</p>\n</li>\n</ul>\n<h2 id=\"JS-代码执行流程\"><a href=\"#JS-代码执行流程\" class=\"headerlink\" title=\"JS 代码执行流程\"></a><code>JS 代码执行流程</code></h2><ol>\n<li>–&gt;进入 script 标签</li>\n<li>–&gt;【预编译】JS 引擎创建全局 EC，全局 EC 入栈</li>\n<li>–&gt;【编译】JS 解释器开始对代码<code>逐行</code>进行分词、语法分析、代码生成</li>\n<li>–&gt;有错则抛出，终止执行；无错继续向下逐行执行</li>\n<li>–&gt;【预编译】调用函数前，创建函数 EC，EC 入栈</li>\n<li>–&gt;【编译】</li>\n<li>–&gt;有错则抛出，终止执行；无错继续向下执行</li>\n<li>–&gt;函数执行完毕，EC 出栈</li>\n<li>–&gt;继续以上步骤</li>\n<li>–&gt;页面销毁，全局 EC 出栈</li>\n<li>–&gt;结束</li>\n</ol>\n<p><code>创建当前环境 EC 流程如下：</code></p>\n<p>1、初始化作用域 [[Scope]]，（拷贝传入的父执行上下文的 Scope），数据结构应该是数组或者链表。</p>\n<p>例如：[[Scope]] : AO1（当前）–&gt;VO（全局）</p>\n<p>2、创建活动对象，创建完成之后，将活动对象推入作用域链的最前端：</p>\n<p>例如：[[Scope]] : AO2（当前）–&gt;AO1（父级）–&gt;VO（全局）</p>\n<p>2.1、创建 arguments 对象，检查上下文，初始化参数名称和值并创建引用的复制。（函数中存在）</p>\n<p>2.2、创建形参，通过实参赋值。（函数中存在）</p>\n<p>2.3、扫描上下文的函数声明（而非函数表达式）：</p>\n<p>为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。如果函数的名字已经存在，引用指针将被重写。函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值</p>\n<p>2.4、扫描上下文的变量声明：</p>\n<p>为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为 undefined，如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。</p>\n<p>3、求出上下文内部 this 的值。</p>\n<blockquote>\n<p>从以上流程中可以观察到<code>作用域、变量提升和 this</code>，接下来结合代码具体分析。</p>\n</blockquote>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a><code>代码分析</code></h2><p>1、EC 创建流程与变量提升</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;outer&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a+<span class=\"string\">&#x27;--a--start&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b+<span class=\"string\">&#x27;--b--start&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c+<span class=\"string\">&#x27;--c--start&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`------------`</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a+<span class=\"string\">&#x27;--a--end&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b+<span class=\"string\">&#x27;--b--end&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c+<span class=\"string\">&#x27;--c--end&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">22</span>);<span class=\"comment\">// 对形参 i 的 LHS 查询</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span>--a--start<span class=\"comment\">// 变量 a 声明时提升赋值为 undefined</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span>--b--start<span class=\"comment\">// 变量 b 声明时提升赋值为 undefined</span></span><br><span class=\"line\">ƒ <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;&#125;--c--start<span class=\"comment\">// 函数 c 声明时提升指向 c 的引用</span></span><br><span class=\"line\">------------</span><br><span class=\"line\">hello--a--end<span class=\"comment\">// 此时赋值语句执行完毕，a 的值为 hello</span></span><br><span class=\"line\">ƒ() &#123;&#125;--b--end<span class=\"comment\">// 此时赋值语句执行完毕，b 指向 b 的引用</span></span><br><span class=\"line\">ƒ <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;&#125;--c--end<span class=\"comment\">// 无变化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分析</span></span><br><span class=\"line\"><span class=\"comment\">// 代码载入前，创建全局 EC 的伪代码</span></span><br><span class=\"line\"><span class=\"title class_\">GlobalEC</span> : &#123;</span><br><span class=\"line\">    [[<span class=\"title class_\">Scope</span>]] : [&#123;<span class=\"variable constant_\">VO</span>&#125;],</span><br><span class=\"line\">    <span class=\"variable constant_\">VO</span> : &#123;</span><br><span class=\"line\">        foo : fnFoo,<span class=\"comment\">// 函数声明优先，指向函数 Foo 的引用</span></span><br><span class=\"line\">        a :  <span class=\"literal\">undefined</span><span class=\"comment\">// 变量声明</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"variable language_\">this</span><span class=\"comment\">// 指向全局</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用函数 foo(22) 时，创建当前 EC 的伪代码</span></span><br><span class=\"line\"><span class=\"title class_\">CurrentEC</span> : &#123;</span><br><span class=\"line\">    [[<span class=\"title class_\">Scope</span>]] : [&#123;<span class=\"variable constant_\">AO</span>&#125;, &#123;<span class=\"variable constant_\">VO</span>&#125;],</span><br><span class=\"line\">    <span class=\"variable constant_\">AO</span> : &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 顺序：arguments 对象 形参 函数声明 变量声明</span></span><br><span class=\"line\">        <span class=\"variable language_\">arguments</span> : &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> : <span class=\"number\">22</span>,</span><br><span class=\"line\">            length : <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        i : <span class=\"number\">22</span>,<span class=\"comment\">// 形参，接受实参赋值</span></span><br><span class=\"line\">        c : fnC,<span class=\"comment\">//指向函数 c 的引用</span></span><br><span class=\"line\">        a : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">        b : <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"variable language_\">this</span><span class=\"comment\">// 指向函数的调用者，这里指向全局</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>2、多个 script 块间的执行过程</p>\n<div class=\"highlight-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script1 start&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;a&#x27;</span>,a);</span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"keyword\">var</span> b=<span class=\"number\">2</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script1 end&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script2 start&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b&#x27;</span>,b);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script2 end&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">     script1 start</span></span><br><span class=\"line\"><span class=\"comment\">     Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"comment\">     script2 start</span></span><br><span class=\"line\"><span class=\"comment\">     b undefined</span></span><br><span class=\"line\"><span class=\"comment\">     script2 end</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\"> 1、从代码运行结果可以看出，JS 执行流在进入第一个 script 块时，首先会创建全局 EC ，将 b 的声明加入 AO 并推入作用域中（所以第二个 script 块中的代码才能访问到 b），全局 EC 压入 ECS。</span></span><br><span class=\"line\"><span class=\"comment\"> 2、逐行的进行分词、语法检查、代码生成，然后执行。</span></span><br><span class=\"line\"><span class=\"comment\">     2.1、在 console.log(&#x27;script1 start&#x27;); 这行代码中，不存在语法错误，执行，输出 start。</span></span><br><span class=\"line\"><span class=\"comment\">     2.2、在 console.log(&#x27;a&#x27;,a); 这行代码中，对变量 a 进行 RHS 查询，在作用域链中找不到 a ，报 ReferenceError，script 块中断执行。</span></span><br><span class=\"line\"><span class=\"comment\"> 3、JS 执行流进入第二个 script 块，仍然在全局 EC（JS 引擎只会存在一个全局 EC），将 a 的声明加入 AO（与第一个代码块相同，每个 EC 绑定唯一的 VO|AO） 并推入作用域。</span></span><br><span class=\"line\"><span class=\"comment\"> 4、逐行的进行分词、语法检查、代码生成，然后执行。</span></span><br><span class=\"line\"><span class=\"comment\">     4.1、在 console.log(&#x27;b&#x27;,b); 这行代码中，对变量 b 进行 RHS 查询，在作用域的 AO 中找到对应的值 undefined，输出 b undefined。</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> 结束</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<p>3、闭包的产生</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首先明确什么是闭包？可以使用如下定义：</span></span><br><span class=\"line\"><span class=\"comment\">// 函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;JavaScript&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"title function_\">fn</span>();</span><br><span class=\"line\"><span class=\"title function_\">func</span>(); <span class=\"comment\">// JavaScript</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// func 函数执行的位置和定义的位置是不相同的，func 是在函数 fn 中定义的，但执行却是在全局环境中，虽然是在全局函数中执行的，但函数仍然可以访问当定义时的词法作用域。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当函数执行结束后其活动变量就会被销毁，但是在上面的例子中却不是这个样子。但函数 fn 执行结束之后，fn 对象的活动变量并没有被销毁，这是因为 fn 返回的函数 func 的作用域链还保持着 fn 的活动变量，因此 JavaScript 的垃圾回收机制不会回收 fn 活动变量。虽然返回的函数 func 是在全局环境下执行的，但是其作用域链的存储的活动（变量）对象的顺序分别是：func 的活动对象、fn 的活动对象、全局变量对象。因此在 func 函数执行时，会顺着作用域链查找标识符，也就能访问到 fn 所定义的词法作用域（即 fn 函数的活动变量）也就不足为奇了。</span></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><code>总结</code></h2><p>问：多个 script 块间的执行顺序</p>\n<blockquote>\n<p>答：多个 script 代码块从上到下按序载入，语法分析阶段报错的话，结束本代码块的执行，执行流进入下一个代码块。多个代码块共享全局执行上下文，可以访问到其他代码块定义的变量和方法。</p>\n</blockquote>\n<p>问：为什么会产生变量提升与函数提升？</p>\n<blockquote>\n<p>答：在代码执行之前的预编译阶段，创建当前 EC 时，会在活动对象上创建一个与函数声明与变量声明对应的属性，然后将活动对象推入作用域链。在查询变量时，是通过作用域链进行 RHS 查询。所以会查询到作用域链上已经定义的函数与变量。</p>\n</blockquote>\n<p>问：闭包的产生</p>\n<blockquote>\n<p>答：简单来说，闭包中的函数所对应的作用域链上仍然保留了父级活动对象，所以可以对父级活动对象的属性进行查询。</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2><ul>\n<li>《你不知道的 Javascript》（上卷），第一部分，作用域和闭包</li>\n<li><a class=\"link\"   href=\"https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/\" >JS 引擎的执行过程 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://segmentfault.com/a/1190000013915935\" >彻底明白作用域、执行上下文 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/yangxinxiang84/article/details/113051811?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328641.10297.16155372256670345&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\" >深入理解 JavaScript 的执行流程，执行上下文 EC、变量对象 VO、活动对象 AO、作用域 Scope <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/Ancecis/article/details/104382441\" >浅谈 JS 的 VO|AO <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/chen_zw/article/details/18502937?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control\" >JS 运行机制之执行顺序 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/MrErHu/blog/issues/16\" >我所认识的作用域链与原型链 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a><code>前言</code></h2><p>本文主要解释 JS 引擎在遇见 script 代码块时，从编译到执行具体经历了些什么？</p>\n<p>一些关于作用域与闭包还有<code>this</code>关键字的问题可能被解答：</p>\n<ul>\n<li>为什么会产生变量提升？</li>\n<li>闭包的产生原理是什么？</li>\n<li>多个 script 代码块间是以什么顺序来执行的？</li>\n<li>为什么定义在不同代码块间的方法可以共通？通过本文都可以得到解答。</li>\n</ul>\n<h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a><code>基础概念</code></h2><ul>\n<li><p>JavaScript 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。<br><code>解释型</code>：JS 引擎在运行 JS 代码时，是利用解释器一边编译一边执行的。</p>\n<p>如此便避免不了一种情况：某些代码多次重复的运行，例如 for 循环，在编译型语言中，for 循环块中的代码将以机器码执行多次；而在解释型语言中，for 循环块中的代码将被解释多次并执行，如此便有了很大的耗损。</p>\n<p><code>即时编译型</code>：于是 JS 引擎就加入了<code>JIT</code>（Just-in-time）进行编译优化，例如对重复语句和类型判断进行优化。</p>\n</li>\n<li><p>引擎、编译器与作用域<br>  引擎：从头到尾负责整个 javascript 程序的编译及执行过程。浏览器不同，其引擎也不同，比如 Chrome 采用的是 v8，Safari 采用的是 SquirrelFish Extreme。</p>\n<p>  编译器：编译过程主要分为”词法分析”、“语法分析”及“代码生成“。</p>\n<blockquote>\n</blockquote>\n<p>  作用域（Scope）：根据名称查找变量的一套规则，用于管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p>\n</li>\n<li><p>执行上下文（Excution Context EC）&amp;&amp; 执行上下文栈（Excution Context Stack ECS）<br>  存在三种 EC：全局执行上下文  GlobalEC ，函数执行上下文  Function EC，Eval。</p>\n<p>  ECS：引擎记录 EC 的容器，栈底是 GlobalEC ，只有在关闭页面时出栈；栈顶是当前正在执行的 EC ，函数执行完毕后出栈，并将执行权交给下一个 EC 。</p>\n</li>\n<li><p>变量对象（Variable Object）&amp;&amp; 活动对象（Activation Object）<br>  VO：EC 中用来存储变量声明（必须是 var 关键字声明而不是 let 与 const）与函数声明（必须是显式声明而不是表达式）的容器。由引擎实现，不能访问到。</p>\n<p>  AO：可以理解为 VO 的实例化，函数调用时在 EC 中被激活，成员属性能被访问。</p>\n</li>\n<li><p>LHS（Left Hand Side） &amp;&amp; RHS（Right Hand Side）<br>  LHS：赋值操作的目标。例如：a&#x3D;2; 是对 a 进行 LHS 查询。</p>\n<p>  RHS：赋值操作的源头。例如：console.log(a); 是对 a 进行 RHS 查询。</p>\n<blockquote>\n</blockquote>\n<p>  非严格模式下，LHS 查询不到变量会在顶层作用域创建具有该名称的变量，RHS 查询不到变量会报 ReferenceError 的异常；严格模式下禁止自动创建全局变量，两种查询方式失败均报 ReferenceError 的异常。</p>\n</li>\n</ul>\n<h2 id=\"JS-代码执行流程\"><a href=\"#JS-代码执行流程\" class=\"headerlink\" title=\"JS 代码执行流程\"></a><code>JS 代码执行流程</code></h2><ol>\n<li>–&gt;进入 script 标签</li>\n<li>–&gt;【预编译】JS 引擎创建全局 EC，全局 EC 入栈</li>\n<li>–&gt;【编译】JS 解释器开始对代码<code>逐行</code>进行分词、语法分析、代码生成</li>\n<li>–&gt;有错则抛出，终止执行；无错继续向下逐行执行</li>\n<li>–&gt;【预编译】调用函数前，创建函数 EC，EC 入栈</li>\n<li>–&gt;【编译】</li>\n<li>–&gt;有错则抛出，终止执行；无错继续向下执行</li>\n<li>–&gt;函数执行完毕，EC 出栈</li>\n<li>–&gt;继续以上步骤</li>\n<li>–&gt;页面销毁，全局 EC 出栈</li>\n<li>–&gt;结束</li>\n</ol>\n<p><code>创建当前环境 EC 流程如下：</code></p>\n<p>1、初始化作用域 [[Scope]]，（拷贝传入的父执行上下文的 Scope），数据结构应该是数组或者链表。</p>\n<p>例如：[[Scope]] : AO1（当前）–&gt;VO（全局）</p>\n<p>2、创建活动对象，创建完成之后，将活动对象推入作用域链的最前端：</p>\n<p>例如：[[Scope]] : AO2（当前）–&gt;AO1（父级）–&gt;VO（全局）</p>\n<p>2.1、创建 arguments 对象，检查上下文，初始化参数名称和值并创建引用的复制。（函数中存在）</p>\n<p>2.2、创建形参，通过实参赋值。（函数中存在）</p>\n<p>2.3、扫描上下文的函数声明（而非函数表达式）：</p>\n<p>为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。如果函数的名字已经存在，引用指针将被重写。函数声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值</p>\n<p>2.4、扫描上下文的变量声明：</p>\n<p>为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为 undefined，如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。</p>\n<p>3、求出上下文内部 this 的值。</p>\n<blockquote>\n<p>从以上流程中可以观察到<code>作用域、变量提升和 this</code>，接下来结合代码具体分析。</p>\n</blockquote>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a><code>代码分析</code></h2><p>1、EC 创建流程与变量提升</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;outer&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a+<span class=\"string\">&#x27;--a--start&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b+<span class=\"string\">&#x27;--b--start&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c+<span class=\"string\">&#x27;--c--start&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`------------`</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a+<span class=\"string\">&#x27;--a--end&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b+<span class=\"string\">&#x27;--b--end&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c+<span class=\"string\">&#x27;--c--end&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">22</span>);<span class=\"comment\">// 对形参 i 的 LHS 查询</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结果：</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span>--a--start<span class=\"comment\">// 变量 a 声明时提升赋值为 undefined</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span>--b--start<span class=\"comment\">// 变量 b 声明时提升赋值为 undefined</span></span><br><span class=\"line\">ƒ <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;&#125;--c--start<span class=\"comment\">// 函数 c 声明时提升指向 c 的引用</span></span><br><span class=\"line\">------------</span><br><span class=\"line\">hello--a--end<span class=\"comment\">// 此时赋值语句执行完毕，a 的值为 hello</span></span><br><span class=\"line\">ƒ() &#123;&#125;--b--end<span class=\"comment\">// 此时赋值语句执行完毕，b 指向 b 的引用</span></span><br><span class=\"line\">ƒ <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;&#125;--c--end<span class=\"comment\">// 无变化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分析</span></span><br><span class=\"line\"><span class=\"comment\">// 代码载入前，创建全局 EC 的伪代码</span></span><br><span class=\"line\"><span class=\"title class_\">GlobalEC</span> : &#123;</span><br><span class=\"line\">    [[<span class=\"title class_\">Scope</span>]] : [&#123;<span class=\"variable constant_\">VO</span>&#125;],</span><br><span class=\"line\">    <span class=\"variable constant_\">VO</span> : &#123;</span><br><span class=\"line\">        foo : fnFoo,<span class=\"comment\">// 函数声明优先，指向函数 Foo 的引用</span></span><br><span class=\"line\">        a :  <span class=\"literal\">undefined</span><span class=\"comment\">// 变量声明</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"variable language_\">this</span><span class=\"comment\">// 指向全局</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用函数 foo(22) 时，创建当前 EC 的伪代码</span></span><br><span class=\"line\"><span class=\"title class_\">CurrentEC</span> : &#123;</span><br><span class=\"line\">    [[<span class=\"title class_\">Scope</span>]] : [&#123;<span class=\"variable constant_\">AO</span>&#125;, &#123;<span class=\"variable constant_\">VO</span>&#125;],</span><br><span class=\"line\">    <span class=\"variable constant_\">AO</span> : &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 顺序：arguments 对象 形参 函数声明 变量声明</span></span><br><span class=\"line\">        <span class=\"variable language_\">arguments</span> : &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span> : <span class=\"number\">22</span>,</span><br><span class=\"line\">            length : <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        i : <span class=\"number\">22</span>,<span class=\"comment\">// 形参，接受实参赋值</span></span><br><span class=\"line\">        c : fnC,<span class=\"comment\">//指向函数 c 的引用</span></span><br><span class=\"line\">        a : <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">        b : <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"variable language_\">this</span><span class=\"comment\">// 指向函数的调用者，这里指向全局</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、多个 script 块间的执行过程</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script1 start&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;a&#x27;</span>,a);</span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"keyword\">var</span> b=<span class=\"number\">2</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script1 end&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script2 start&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b&#x27;</span>,b);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;script2 end&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"> </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- </span></span><br><span class=\"line\"><span class=\"comment\">     script1 start</span></span><br><span class=\"line\"><span class=\"comment\">     Uncaught ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"comment\">     script2 start</span></span><br><span class=\"line\"><span class=\"comment\">     b undefined</span></span><br><span class=\"line\"><span class=\"comment\">     script2 end</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\"> 1、从代码运行结果可以看出，JS 执行流在进入第一个 script 块时，首先会创建全局 EC ，将 b 的声明加入 AO 并推入作用域中（所以第二个 script 块中的代码才能访问到 b），全局 EC 压入 ECS。</span></span><br><span class=\"line\"><span class=\"comment\"> 2、逐行的进行分词、语法检查、代码生成，然后执行。</span></span><br><span class=\"line\"><span class=\"comment\">     2.1、在 console.log(&#x27;script1 start&#x27;); 这行代码中，不存在语法错误，执行，输出 start。</span></span><br><span class=\"line\"><span class=\"comment\">     2.2、在 console.log(&#x27;a&#x27;,a); 这行代码中，对变量 a 进行 RHS 查询，在作用域链中找不到 a ，报 ReferenceError，script 块中断执行。</span></span><br><span class=\"line\"><span class=\"comment\"> 3、JS 执行流进入第二个 script 块，仍然在全局 EC（JS 引擎只会存在一个全局 EC），将 a 的声明加入 AO（与第一个代码块相同，每个 EC 绑定唯一的 VO|AO） 并推入作用域。</span></span><br><span class=\"line\"><span class=\"comment\"> 4、逐行的进行分词、语法检查、代码生成，然后执行。</span></span><br><span class=\"line\"><span class=\"comment\">     4.1、在 console.log(&#x27;b&#x27;,b); 这行代码中，对变量 b 进行 RHS 查询，在作用域的 AO 中找到对应的值 undefined，输出 b undefined。</span></span><br><span class=\"line\"><span class=\"comment\"> </span></span><br><span class=\"line\"><span class=\"comment\"> 结束</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>3、闭包的产生</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首先明确什么是闭包？可以使用如下定义：</span></span><br><span class=\"line\"><span class=\"comment\">// 函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例子</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;JavaScript&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"title function_\">fn</span>();</span><br><span class=\"line\"><span class=\"title function_\">func</span>(); <span class=\"comment\">// JavaScript</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// func 函数执行的位置和定义的位置是不相同的，func 是在函数 fn 中定义的，但执行却是在全局环境中，虽然是在全局函数中执行的，但函数仍然可以访问当定义时的词法作用域。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当函数执行结束后其活动变量就会被销毁，但是在上面的例子中却不是这个样子。但函数 fn 执行结束之后，fn 对象的活动变量并没有被销毁，这是因为 fn 返回的函数 func 的作用域链还保持着 fn 的活动变量，因此 JavaScript 的垃圾回收机制不会回收 fn 活动变量。虽然返回的函数 func 是在全局环境下执行的，但是其作用域链的存储的活动（变量）对象的顺序分别是：func 的活动对象、fn 的活动对象、全局变量对象。因此在 func 函数执行时，会顺着作用域链查找标识符，也就能访问到 fn 所定义的词法作用域（即 fn 函数的活动变量）也就不足为奇了。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><code>总结</code></h2><p>问：多个 script 块间的执行顺序</p>\n<blockquote>\n<p>答：多个 script 代码块从上到下按序载入，语法分析阶段报错的话，结束本代码块的执行，执行流进入下一个代码块。多个代码块共享全局执行上下文，可以访问到其他代码块定义的变量和方法。</p>\n</blockquote>\n<p>问：为什么会产生变量提升与函数提升？</p>\n<blockquote>\n<p>答：在代码执行之前的预编译阶段，创建当前 EC 时，会在活动对象上创建一个与函数声明与变量声明对应的属性，然后将活动对象推入作用域链。在查询变量时，是通过作用域链进行 RHS 查询。所以会查询到作用域链上已经定义的函数与变量。</p>\n</blockquote>\n<p>问：闭包的产生</p>\n<blockquote>\n<p>答：简单来说，闭包中的函数所对应的作用域链上仍然保留了父级活动对象，所以可以对父级活动对象的属性进行查询。</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2><ul>\n<li>《你不知道的 Javascript》（上卷），第一部分，作用域和闭包</li>\n<li><a class=\"link\"   href=\"https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/\" >JS 引擎的执行过程 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://segmentfault.com/a/1190000013915935\" >彻底明白作用域、执行上下文 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/yangxinxiang84/article/details/113051811?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328641.10297.16155372256670345&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control\" >深入理解 JavaScript 的执行流程，执行上下文 EC、变量对象 VO、活动对象 AO、作用域 Scope <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/Ancecis/article/details/104382441\" >浅谈 JS 的 VO|AO <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.csdn.net/chen_zw/article/details/18502937?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control\" >JS 运行机制之执行顺序 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/MrErHu/blog/issues/16\" >我所认识的作用域链与原型链 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n"},{"title":"【实践】手写 call、apply、bind","date":"2021-10-15T07:30:57.000Z","_content":"\n<!-- YCTODO -->","source":"_posts/PracticeCallApply.md","raw":"---\ntitle: 【实践】手写 call、apply、bind\ndate: 2021-10-15 15:30:57\ntags: [JS]\ncategories: [实践]\n---\n\n<!-- YCTODO -->","slug":"PracticeCallApply","published":1,"updated":"2023-03-15T02:42:55.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychb000x7gh8duge7j9f","content":"<!-- YCTODO -->","site":{"data":{}},"excerpt":"","more":"<!-- YCTODO -->"},{"title":"【方法论】前端状态管理的一些理解","date":"2022-06-15T07:30:57.000Z","_content":"# 前端状态管理的一些理解\n\n## 前言\n\n在工作中，我们常常会使用状态管理工具，例如：vue2 的 vuex，vue3 的 pinia，angular 的 NgRx，react 的 redux。有时难免会有一些疑问，为什么要使用状态管理工具，\n\n一个有趣的比方：假设有一个图书馆，当这个图书馆很小时，读者要找到一本书是非常简单的，就像一个小的前端项目，直接使用组件对数据进行存储更改是更加快捷方便的方式。但如果这个图书馆很大，人流量也很多，读者找一本书或者归还一本书就会很吃力。而状态管理器就像这个图书馆的电脑，当你要找一本书时，如果这是一本教科书，就会去教科书的栏目内检索，就像写的`action = 'schoolbook';`\n\n## 总结\n\n## 参考资料","source":"_posts/MethodologyStateManagement.md","raw":"---\ntitle: 【方法论】前端状态管理的一些理解\ndate: 2022-06-15 15:30:57\ntags: [JS]\ncategories: [方法论]\n---\n# 前端状态管理的一些理解\n\n## 前言\n\n在工作中，我们常常会使用状态管理工具，例如：vue2 的 vuex，vue3 的 pinia，angular 的 NgRx，react 的 redux。有时难免会有一些疑问，为什么要使用状态管理工具，\n\n一个有趣的比方：假设有一个图书馆，当这个图书馆很小时，读者要找到一本书是非常简单的，就像一个小的前端项目，直接使用组件对数据进行存储更改是更加快捷方便的方式。但如果这个图书馆很大，人流量也很多，读者找一本书或者归还一本书就会很吃力。而状态管理器就像这个图书馆的电脑，当你要找一本书时，如果这是一本教科书，就会去教科书的栏目内检索，就像写的`action = 'schoolbook';`\n\n## 总结\n\n## 参考资料","slug":"MethodologyStateManagement","published":1,"updated":"2023-03-02T13:08:39.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychb000y7gh8e0w7dhm3","content":"<h1 id=\"前端状态管理的一些理解\"><a href=\"#前端状态管理的一些理解\" class=\"headerlink\" title=\"前端状态管理的一些理解\"></a>前端状态管理的一些理解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在工作中，我们常常会使用状态管理工具，例如：vue2 的 vuex，vue3 的 pinia，angular 的 NgRx，react 的 redux。有时难免会有一些疑问，为什么要使用状态管理工具，</p>\n<p>一个有趣的比方：假设有一个图书馆，当这个图书馆很小时，读者要找到一本书是非常简单的，就像一个小的前端项目，直接使用组件对数据进行存储更改是更加快捷方便的方式。但如果这个图书馆很大，人流量也很多，读者找一本书或者归还一本书就会很吃力。而状态管理器就像这个图书馆的电脑，当你要找一本书时，如果这是一本教科书，就会去教科书的栏目内检索，就像写的<code>action = &#39;schoolbook&#39;;</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端状态管理的一些理解\"><a href=\"#前端状态管理的一些理解\" class=\"headerlink\" title=\"前端状态管理的一些理解\"></a>前端状态管理的一些理解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在工作中，我们常常会使用状态管理工具，例如：vue2 的 vuex，vue3 的 pinia，angular 的 NgRx，react 的 redux。有时难免会有一些疑问，为什么要使用状态管理工具，</p>\n<p>一个有趣的比方：假设有一个图书馆，当这个图书馆很小时，读者要找到一本书是非常简单的，就像一个小的前端项目，直接使用组件对数据进行存储更改是更加快捷方便的方式。但如果这个图书馆很大，人流量也很多，读者找一本书或者归还一本书就会很吃力。而状态管理器就像这个图书馆的电脑，当你要找一本书时，如果这是一本教科书，就会去教科书的栏目内检索，就像写的<code>action = &#39;schoolbook&#39;;</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2>"},{"title":"【实践】手写 Promise","date":"2021-09-08T07:30:57.000Z","_content":"## 前言\n\n- [Promise/A+规范](https://github.com/promises-aplus/promises-spec)\n- [Promise/A+测试](https://github.com/promises-aplus/promises-tests)\n\n## 标识符\n- promise：是一个拥有 then 方法的对象或函数，其行为符合本规范\n- thenable：是一个定义了 then 方法的对象或函数。这个主要是用来兼容一些老的 Promise 实现，只要一个 Promise 实现是 thenable，也就是拥有 then 方法的，就可以跟 Promises/A+兼容。\n- value：指 reslove 出来的值，可以是任何合法的 JS 值（包括 undefined , thenable 和 promise 等）\n- reason：拒绝原因，是 reject 里面传的参数，表示 reject 的原因\n- exception：异常，在 Promise 里面用 throw 抛出来的值\n## 基本逻辑\n- Promise 具有 3 种状态：pending、fulfilled、rejected;\n- pending 可以转换诚 fulfiiled 或者 rejected;\n- fulfilled 不可转变状态，且必须有一个不变的值 (value);\n  - 即`new Promise((resolve, reject)=>{resolve(value)})` resolve 为成功，接收参数 value，状态改变为 fulfilled，不可再次改变。\n- reject 不可转变状态，且必须有一个不变的原因 (reason);\n  - 即`new Promise((resolve, reject)=>{reject(reason)}) `reject 为失败，接收参数 reason，状态改变为 rejected，不可再次改变。\n- 若是 executor 函数报错 直接执行 reject();\n\n## thenable\n语法：\n```typescript\npromise.then(onFulliled, onRejected)\n```\n\n```typescript\nclass Promise{\n  constructor(executor){\n    this.state='pending';\n    this.value=undefined;\n    this.reason=undefined;\n    let resolve=value=>{\n      if(this.state=='pending'){\n        this.state='fulfilled';\n        this.value=value;\n      }\n    }\n    let reject=reason=>{\n      if(this.state=='pending'){\n        this.state='rejected';\n        this.reason=reason;\n      }\n    }\n    // executor 执行报错，执行 reject\n    try{\n      executor(resolve,reject)\n    }catch(err){\n      reject(err)\n    }\n  }\n}\n```\n\n## 参考资料\n[手写一个 Promise/A+, 完美通过官方 872 个测试用例](https://segmentfault.com/a/1190000023157856)","source":"_posts/PracticePromise.md","raw":"---\ntitle: 【实践】手写 Promise\ndate: 2021-09-08 15:30:57\ntags: [JS]\ncategories: [实践]\n---\n## 前言\n\n- [Promise/A+规范](https://github.com/promises-aplus/promises-spec)\n- [Promise/A+测试](https://github.com/promises-aplus/promises-tests)\n\n## 标识符\n- promise：是一个拥有 then 方法的对象或函数，其行为符合本规范\n- thenable：是一个定义了 then 方法的对象或函数。这个主要是用来兼容一些老的 Promise 实现，只要一个 Promise 实现是 thenable，也就是拥有 then 方法的，就可以跟 Promises/A+兼容。\n- value：指 reslove 出来的值，可以是任何合法的 JS 值（包括 undefined , thenable 和 promise 等）\n- reason：拒绝原因，是 reject 里面传的参数，表示 reject 的原因\n- exception：异常，在 Promise 里面用 throw 抛出来的值\n## 基本逻辑\n- Promise 具有 3 种状态：pending、fulfilled、rejected;\n- pending 可以转换诚 fulfiiled 或者 rejected;\n- fulfilled 不可转变状态，且必须有一个不变的值 (value);\n  - 即`new Promise((resolve, reject)=>{resolve(value)})` resolve 为成功，接收参数 value，状态改变为 fulfilled，不可再次改变。\n- reject 不可转变状态，且必须有一个不变的原因 (reason);\n  - 即`new Promise((resolve, reject)=>{reject(reason)}) `reject 为失败，接收参数 reason，状态改变为 rejected，不可再次改变。\n- 若是 executor 函数报错 直接执行 reject();\n\n## thenable\n语法：\n```typescript\npromise.then(onFulliled, onRejected)\n```\n\n```typescript\nclass Promise{\n  constructor(executor){\n    this.state='pending';\n    this.value=undefined;\n    this.reason=undefined;\n    let resolve=value=>{\n      if(this.state=='pending'){\n        this.state='fulfilled';\n        this.value=value;\n      }\n    }\n    let reject=reason=>{\n      if(this.state=='pending'){\n        this.state='rejected';\n        this.reason=reason;\n      }\n    }\n    // executor 执行报错，执行 reject\n    try{\n      executor(resolve,reject)\n    }catch(err){\n      reject(err)\n    }\n  }\n}\n```\n\n## 参考资料\n[手写一个 Promise/A+, 完美通过官方 872 个测试用例](https://segmentfault.com/a/1190000023157856)","slug":"PracticePromise","published":1,"updated":"2023-03-15T02:42:49.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychc00117gh8fssk060g","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><a class=\"link\"   href=\"https://github.com/promises-aplus/promises-spec\" >Promise&#x2F;A+规范 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/promises-aplus/promises-tests\" >Promise&#x2F;A+测试 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><ul>\n<li>promise：是一个拥有 then 方法的对象或函数，其行为符合本规范</li>\n<li>thenable：是一个定义了 then 方法的对象或函数。这个主要是用来兼容一些老的 Promise 实现，只要一个 Promise 实现是 thenable，也就是拥有 then 方法的，就可以跟 Promises&#x2F;A+兼容。</li>\n<li>value：指 reslove 出来的值，可以是任何合法的 JS 值（包括 undefined , thenable 和 promise 等）</li>\n<li>reason：拒绝原因，是 reject 里面传的参数，表示 reject 的原因</li>\n<li>exception：异常，在 Promise 里面用 throw 抛出来的值</li>\n</ul>\n<h2 id=\"基本逻辑\"><a href=\"#基本逻辑\" class=\"headerlink\" title=\"基本逻辑\"></a>基本逻辑</h2><ul>\n<li>Promise 具有 3 种状态：pending、fulfilled、rejected;</li>\n<li>pending 可以转换诚 fulfiiled 或者 rejected;</li>\n<li>fulfilled 不可转变状态，且必须有一个不变的值 (value);<ul>\n<li>即<code>new Promise((resolve, reject)=&gt;&#123;resolve(value)&#125;)</code> resolve 为成功，接收参数 value，状态改变为 fulfilled，不可再次改变。</li>\n</ul>\n</li>\n<li>reject 不可转变状态，且必须有一个不变的原因 (reason);<ul>\n<li>即<code>new Promise((resolve, reject)=&gt;&#123;reject(reason)&#125;) </code>reject 为失败，接收参数 reason，状态改变为 rejected，不可再次改变。</li>\n</ul>\n</li>\n<li>若是 executor 函数报错 直接执行 reject();</li>\n</ul>\n<h2 id=\"thenable\"><a href=\"#thenable\" class=\"headerlink\" title=\"thenable\"></a>thenable</h2><p>语法：</p>\n<div class=\"highlight-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.<span class=\"title function_\">then</span>(onFulliled, onRejected)</span><br></pre></td></tr></table></figure></div>\n\n<div class=\"highlight-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Promise</span>&#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">executor</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=<span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span>=<span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">reason</span>=<span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">resolve</span>=value=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>==<span class=\"string\">&#x27;pending&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=<span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span>=value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">reject</span>=reason=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>==<span class=\"string\">&#x27;pending&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=<span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">reason</span>=reason;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// executor 执行报错，执行 reject</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      <span class=\"title function_\">executor</span>(resolve,reject)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a class=\"link\"   href=\"https://segmentfault.com/a/1190000023157856\" >手写一个 Promise&#x2F;A+, 完美通过官方 872 个测试用例 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li><a class=\"link\"   href=\"https://github.com/promises-aplus/promises-spec\" >Promise&#x2F;A+规范 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/promises-aplus/promises-tests\" >Promise&#x2F;A+测试 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><ul>\n<li>promise：是一个拥有 then 方法的对象或函数，其行为符合本规范</li>\n<li>thenable：是一个定义了 then 方法的对象或函数。这个主要是用来兼容一些老的 Promise 实现，只要一个 Promise 实现是 thenable，也就是拥有 then 方法的，就可以跟 Promises&#x2F;A+兼容。</li>\n<li>value：指 reslove 出来的值，可以是任何合法的 JS 值（包括 undefined , thenable 和 promise 等）</li>\n<li>reason：拒绝原因，是 reject 里面传的参数，表示 reject 的原因</li>\n<li>exception：异常，在 Promise 里面用 throw 抛出来的值</li>\n</ul>\n<h2 id=\"基本逻辑\"><a href=\"#基本逻辑\" class=\"headerlink\" title=\"基本逻辑\"></a>基本逻辑</h2><ul>\n<li>Promise 具有 3 种状态：pending、fulfilled、rejected;</li>\n<li>pending 可以转换诚 fulfiiled 或者 rejected;</li>\n<li>fulfilled 不可转变状态，且必须有一个不变的值 (value);<ul>\n<li>即<code>new Promise((resolve, reject)=&gt;&#123;resolve(value)&#125;)</code> resolve 为成功，接收参数 value，状态改变为 fulfilled，不可再次改变。</li>\n</ul>\n</li>\n<li>reject 不可转变状态，且必须有一个不变的原因 (reason);<ul>\n<li>即<code>new Promise((resolve, reject)=&gt;&#123;reject(reason)&#125;) </code>reject 为失败，接收参数 reason，状态改变为 rejected，不可再次改变。</li>\n</ul>\n</li>\n<li>若是 executor 函数报错 直接执行 reject();</li>\n</ul>\n<h2 id=\"thenable\"><a href=\"#thenable\" class=\"headerlink\" title=\"thenable\"></a>thenable</h2><p>语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.<span class=\"title function_\">then</span>(onFulliled, onRejected)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Promise</span>&#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">executor</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=<span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">value</span>=<span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">reason</span>=<span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">resolve</span>=value=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>==<span class=\"string\">&#x27;pending&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=<span class=\"string\">&#x27;fulfilled&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">value</span>=value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title function_\">reject</span>=reason=&gt;&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>==<span class=\"string\">&#x27;pending&#x27;</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span>=<span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">reason</span>=reason;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// executor 执行报错，执行 reject</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      <span class=\"title function_\">executor</span>(resolve,reject)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a class=\"link\"   href=\"https://segmentfault.com/a/1190000023157856\" >手写一个 Promise&#x2F;A+, 完美通过官方 872 个测试用例 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n"},{"url":"https://limeii.github.io/2020/06/angular-performance-checklists/","title":"【转载】Angular：性能优化清单","date":"2022-05-02T12:20:45.000Z","_content":"\n> 原文转自：https://limeii.github.io/2020/06/angular-performance-checklists/\n\n性能优化主要是从两方面入手，一个是网络性能，另一个是页面渲染。在具体介绍性能优化方式之前，先来解释下为什么网络性能和页面渲染会影响性能。\n\n在这里讨论的网络带宽的性能问题都是基于 HTTP/1.X，在 HTTP/2 中很多性能问题都解决了。\n\n在 HTTP/1.X 连接有三种方式：短连接，长连接和 HTTP 流水线。\n\n![](https://limeii.github.io/assets/images/posts/angular/angular-performance01.png)\n\n短连接是 HTTP/1.0 的默认模型，它每发一个请求时都会创建见一个新的 TCP 连接，收到 response 的时候就立马关闭连接，每次创建一个 TCP 连接都相当耗费资源，可想而知这种方式的性能很差，现在基本不用这种方式。\n\n在 HTTP/1.1 以后就有了长连接和流水线，长连接是指创建一个 TCP 连接后，可以保持连接完成多次连续的请求，减少了打开 TCP 连接的次数，在 HTTP/1.1 以后的版本是默认的长连接的模式，长连接的缺点是，就算在空闲状态，它还是会消耗服务器资源。长连接是通过 `Keep-Alive`消息头来控制。\n\n默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到应答以后才会发出，由于受到网络延迟和带宽的限制，在下一个请求发出可能需要等很长时间。流水线是指在同一个 TCP 长连接里连续发出请求，而不用等待前一个请求应答返回，理论上这种方式是最有效的，实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显，在 HTTP/2 已经有更好的方式替代流水线模式，流水线模式在浏览器里默认是不开启的。\n\n基于 HTTP/1.X 的连接限制，我们在开发中过程要尽量减少网络带宽的占用，比如尽可能的减小文件的大小和减少请求次数，可以从以下几方面考虑：\n\n*   Bundling\n*   Code Splitting\n*   Minify，Uglify\n*   Compression\n*   Tree-shaking\n*   Cache\n*   lazy loading 和 preloading\n*   如果是用了前端框架，部署的时候用 AoT 的编译方式\n*   Service Worker\n\n页面渲染，在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧，提高页面渲染的性能，可以从以下几方面考虑：\n\n*   减少页面重排和重绘，尽量避免以下会导致页面重排和重绘的操作：\n    *   在 JS 代码中操作页面 DOM\n    *   在页面 layout 稳定以后，增加和改变 CSS 样式\n    *   改变：窗口大小，字体大小\n    *   使用 table\n    *   动画实现数度选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame\n    *   读取 offsetwidth offsetheight\n    *   CSS 伪类，比如 :hover 某个元素弹出一个消息框\n*   JS 全阻塞，CSS 半阻塞（会阻塞 JS 执行和渲染树，但不阻塞 DOM 构建）\n    *   JS 阻塞构建 DOM CSSOM 树，从而会阻塞构建渲染树，而且同时还会阻塞其他静态资源（图片）的下载，所以要把`<script>`标签放到 body 最后，或者是在标签里添加`defer` 或者 `async` 属性。\n    *   CSS 文件下载解析，不会阻塞 HTML 文件解析，不会阻塞 DOM 树的构建，但是会阻塞 CSSOM 树，从而会阻塞渲染树的构建，所以 CSS 文件的连接可以放在 head 里，不影响\n    *   CSS 文件下载不会阻塞其他文件下载，但是会阻塞 JS 的文件执行\n*   Web Worker\n*   服务器端渲染\n\n## 网络性能\n\n**推荐用 Angular 自带的编译方式打包**\n\nAngular 内置了 webpack 打包方式，很多人在搭建 Angular(<6.0) 项目的时候，发现 Angular 内置的 webpack 并不能满足实际项目打包的一些需求，所以通过`ng eject`把内置的 webpack.config 文件暴露出来，然后根据自己项目需求重写整个 webpack.config 配置，可以参考文章：【[Angular：如何用 Angular(<6.0) 和 Webpack 搭建项目](https://limeii.github.io/2018/09/angular-webpack/)】\n\n但是 Angular(>= 6.0)，去掉了`ng eject`命令，鼓励大家用 Angular 内置的打包方式开发 Angular 项目，因为`AoT` `Tree-Shaking` `ngc` `tsc` `minification` `Uglification` `Production mode`等等这些在 Angular 内置的打包方式中都是默认配置，不需要我们自己再去找第三方的 loader 或者 plugin 来实现类似的功能；而且从性能上说内置的打包方式要比我们自己搭的要好。\n\n如何结合内置的打包方式和我们自己的 webpack 配置文件编译打包整个项目，可以参考文章：【[Angular：如何在 Angular(8.0) 中配置 Webpack](https://limeii.github.io/2019/08/angular-customize-webpack/)】\n\n**使用 AoT 编译**\n\n在打包过程中使用 AoT 编译，指的是把所有 HTML component NgModule CSS 都编译成浏览器可以识别的 es5 代码。从而用户访问 Angular 应用的时候，只需要下载相应的 budnle 文件后直接渲染。不需要先下载`@angular/compiler`编译器编译模板文件，然后再渲染，大大提高了页面渲染性能。\n\n在模板文件中 Angular 有自己的 directive component pipe，如果不先编译成 es6 代码，就没办法做 Tree Shaking。AoT(ngc) 编译，可以把模板文件先打包成 es6 （或者 TypeScript) 文件，这样就可以做 Tree Shaking，把一些没用的代码去掉，从而减少 bundle 文件的体积，也可以提高性能。\n\n关于深入理解 Angular 编译，可以参考这篇文章：【[Angular：深入理解 Angular 编译机制](https://limeii.github.io/2019/08/angular-compiler/)】\n\n**Tree Shaking**\n\n如果项目中有一些代码 （方法、文件），在项目里完全没有被用到，这种代码称为 Dead Code。大量 Dead Code 如果编译打包进 bundle 文件，会导致 bundle 文件过大，页面渲染下载 bundle 文件的时候会浪费带宽，也会影响性能。\n\nTree Shaking 就是用来解决这种问题，它是指在编译打包过程中把 Dead Code 去掉，不把这些没用到的代码打包到最后的 bundle 文件里，从而可以减小 bundle 文件的体积，提高应用性能。可以把整个应用想象成一棵树，function/component/service/lib 好比是树叶，而那些定义但又没有被调用的 function/component/service/lib 好比是枯树叶，Tree Shaking 就是把那些枯树叶从树上摇下去。\n\n关于更多 Tree Shaking 的理解和应用可以参考这篇文章： [Angular 性能优化：Tree Shaking](https://limeii.github.io/2019/08/angular-tree-shaking/)\n\n**lazy loading 和 preloading**\n\n如果把一个大项目所有文件都打包进一个 bundle 文件，用户打开浏览器访问这个网站的时候，首先要从服务器下载这个超大的 bundle 文件，加上还需要时间做一些解析，会导致网站响应过慢。在 Angular 项目中可以通过配置 lazy loading 和 preloading 来提高性能。关于 lazy loading 和 preloading 在 Angular 项目中的理解和应用可以参考这篇文章：【[Angular：lazy loading 和 preloading](https://limeii.github.io/2018/09/angular-lazy-loading/)】\n\n**webpack Code Splitting**\n\n在项目中经常会有一些公用代码，被多个 module 或者 component 引用，如果在打包的时候直接把公用代码重复打包进不同的 bundle 文件，会造成代码冗余，也会影响应用性能。我们可以通过 webpack Code Splitting 做代码切割，把公用的代码单独提取出来放在 chunk 文件里，用户访问页面的时候只需要下载一次这个 chunk 文件就可以了。具体可以参考这篇文章：[webpack(3)：代码切割](https://limeii.github.io/2018/10/webpack-code-splitting/)\n\n**缓存**\n\n*   用 RxJS 实现缓存效果 Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Cold Observable，这导致每次调用 API，都会生成一个新的 Observable 实例，有订阅之后才开始发送值，这也符合现在前端开发要求。但是实际开发过程中，有时候后端会有提供一些公用的常量 API，不同页面都需要用这些常量，按现在的调用 API 的方式，会导致常量 API 在不同的页面重复多次被调用，这种方式显然性能不好。可以通过 ReplaySubject 实现缓存效果，第一次调用常量 API 之后把这些常量缓存起来，之后调用同样的 API 就可以直接在 ReplaySubject 拿到值，不用每次都调用后端 API。具体实现可以参考文章：【[RxJS：如何通过 RxJS 实现缓存](https://limeii.github.io/2019/08/rxjs-caching/)】\n    \n*   选择合适的浏览器缓存策略 对于一些不经常改的静态资源，可以缓存在浏览器端，合理的缓存策略可以减少延迟，在重复利用缓存的资源文件同时，可以减少带宽和降低网络负荷，从而大大提高了性能。缓存机制可以参考文章：【[浏览器缓存机制：强缓存和协商缓存](https://limeii.github.io/2018/11/web-cache/)】\n    \n*   合理的利用浏览器数据存储 对于一些常用的数据，可以存在浏览器里，这样可以减少延迟和带宽，从而可以提高性能，浏览器数据存储方式有：Cookies、SessionStorage、LocalStorage、IndexedDB。对于这些存储方式的用法和区别可以参考文章：【[浏览器数据存储方式](https://limeii.github.io/2018/11/web-storage/)】\n    \n\n**防抖**\n\n超高频触发网路请求，不仅效率低而且没办法保证请求结果的正确性，我们可以结合 RxJS 中的操作符`debounceTime` `map` `filter` `distinctUntilChanged` 和`switchMap`实现防抖。具体可以参考文章：【[RxJS：如何用 RxJS 实现高效的 HTTP 请求](https://limeii.github.io/2019/08/rxjs-searchable-input/)】\n\n**Service Worker**\n\nService Worker 可以理解为客户端和服务器端中间的一个代理服务器，它是独立于主线程的一个线程，在主线程运行的同时，它在后台运行，两者之间互不干扰。它可以拦截所有客户端的请求，也可以向服务器端发送请求，可以离线缓存资源，也可以后台同步。Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能，毫无疑问，Service Worker 也可以大大的提高页面性能。关于 Service Worker 的理解和应用，可以参考文章：【[The offline cookbook](https://jakearchibald.com/2014/offline-cookbook/)】\n\n## 页面渲染\n\n**浏览器工作原理**\n\n在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧。关于浏览器是如何解析运行 HTML CSS JS，浏览器的工作原理，可以参考参考文章：【[How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)】\n\n**Web Worker**\n\nJS 是单线程的，并且是全阻塞的，全阻塞的意思是指：在浏览器中，只要 JS 引擎在执行 JS 代码，那么就会阻塞 HTML CSS 的解析执行，从而会阻塞页面渲染和交互，如果 JS 代码执行时间比较长，那么会导致页面卡顿，影响用户体验。\n\n在 H5 中引入了 Web Worker，它的作用就是为 JS 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给 Worker 线程。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰，它的意义在于可以将一些耗时的数据处理操作（复杂耗时的计算，大文本分析上传，图像处理，canvas 图像绘制等等）从主线程中剥离，让主线程专注于页面的渲染和交互，从而提高页面性能。关于 Web Worker 的具体用法可以参考文章：【[使用 Web Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)】\n\n**使用 ChangeDetectionStrategy.OnPush 策略**\n\nAngular 默认的变化检测机制是：异步事件 callback 结束后，NgZone 会触发整个组件树至上而下做变化检测，也就是说页面一个小小的 Click 事件就会触发所有组件的变化检测。虽然 Angular 变化检测本身性能已经很好了，在毫秒内可以做成百上千次变化检测。但是随着项目越来越大，其实很多不必要的变化检测还是会在一定程度上影响性能。在 Angular 中可以通过 OnPush 来跳过一些不必要的变化检测，从而优化整个应用的性能。更多关于 OnPush 策略的理解和应用可以参考这篇文章：【 [Angular Change Detection：变化检测策略](https://limeii.github.io/2019/06/angular-changeDetectionStrategy-OnPush/)】\n\n**服务器端渲染（Server Rendering）**\n\n一般来说，像 Angular 框架搭出来的 SPA 应用，都是客户端渲染（client-side rendering）。当路由到这个页面的时候，从服务器端下载相应的 bundle/chunk 文件，在这个文件里一般只是只包含了 DOM 结构代码和 JS 代码，不是 HTML 文件。浏览器拿到这些代码，需要构建 DOM 树 / CSSOM 树 / 渲染树 / 解析执行 JS 代码，最后才是页面渲染后跟用户进行交互，如果这其中某一个步骤耗时较长，就会导致用户只能看到空白页面一直在加载，显然性能和用户体验都不好。服务器端渲染就可以用来解决这个问题，当路由到某一个页面的时候，request 发到服务器端，在服务器端会构建好这个页面（HTML 文件），再把这个 HTML 文件直接发回给客户端，这样用户在一开始就能立马看到带有内容的页面，不用等浏览器构建页面、执行 JS 代码，大大提高了性能，有更好的用户体验。\n\n**域名拆分**\n\n我们知道，在 HTTP1.1 中，浏览器对同一域名的 TCP 连接数量有限制，一般是 6 到 8 个，超过这个数量之后，就会阻塞后续的请求。有些网站为了提高性能，并行的去服务端请求更多的资源，会把资源分布到不同的域名商去，让浏览器利用更多的 TCP socket 连接。\n\n在 Angular 中，可以用 Angular Universal 来实现服务器端渲染，关于服务器端渲染和 Angular Universal 的文章可以参考：【[Rendering on the Web](https://developers.google.com/web/updates/2019/02/rendering-on-the-web)】【[Angular Universal: a Complete Practical Guide](https://blog.angular-university.io/angular-universal/)】","source":"_posts/ReprintAngularOptimization.md","raw":"---\nurl: https://limeii.github.io/2020/06/angular-performance-checklists/\ntitle: 【转载】Angular：性能优化清单\ndate: 2022-05-02 20:20:45\ntags: [angular]\ncategories: [转载]\n---\n\n> 原文转自：https://limeii.github.io/2020/06/angular-performance-checklists/\n\n性能优化主要是从两方面入手，一个是网络性能，另一个是页面渲染。在具体介绍性能优化方式之前，先来解释下为什么网络性能和页面渲染会影响性能。\n\n在这里讨论的网络带宽的性能问题都是基于 HTTP/1.X，在 HTTP/2 中很多性能问题都解决了。\n\n在 HTTP/1.X 连接有三种方式：短连接，长连接和 HTTP 流水线。\n\n![](https://limeii.github.io/assets/images/posts/angular/angular-performance01.png)\n\n短连接是 HTTP/1.0 的默认模型，它每发一个请求时都会创建见一个新的 TCP 连接，收到 response 的时候就立马关闭连接，每次创建一个 TCP 连接都相当耗费资源，可想而知这种方式的性能很差，现在基本不用这种方式。\n\n在 HTTP/1.1 以后就有了长连接和流水线，长连接是指创建一个 TCP 连接后，可以保持连接完成多次连续的请求，减少了打开 TCP 连接的次数，在 HTTP/1.1 以后的版本是默认的长连接的模式，长连接的缺点是，就算在空闲状态，它还是会消耗服务器资源。长连接是通过 `Keep-Alive`消息头来控制。\n\n默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到应答以后才会发出，由于受到网络延迟和带宽的限制，在下一个请求发出可能需要等很长时间。流水线是指在同一个 TCP 长连接里连续发出请求，而不用等待前一个请求应答返回，理论上这种方式是最有效的，实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显，在 HTTP/2 已经有更好的方式替代流水线模式，流水线模式在浏览器里默认是不开启的。\n\n基于 HTTP/1.X 的连接限制，我们在开发中过程要尽量减少网络带宽的占用，比如尽可能的减小文件的大小和减少请求次数，可以从以下几方面考虑：\n\n*   Bundling\n*   Code Splitting\n*   Minify，Uglify\n*   Compression\n*   Tree-shaking\n*   Cache\n*   lazy loading 和 preloading\n*   如果是用了前端框架，部署的时候用 AoT 的编译方式\n*   Service Worker\n\n页面渲染，在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧，提高页面渲染的性能，可以从以下几方面考虑：\n\n*   减少页面重排和重绘，尽量避免以下会导致页面重排和重绘的操作：\n    *   在 JS 代码中操作页面 DOM\n    *   在页面 layout 稳定以后，增加和改变 CSS 样式\n    *   改变：窗口大小，字体大小\n    *   使用 table\n    *   动画实现数度选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame\n    *   读取 offsetwidth offsetheight\n    *   CSS 伪类，比如 :hover 某个元素弹出一个消息框\n*   JS 全阻塞，CSS 半阻塞（会阻塞 JS 执行和渲染树，但不阻塞 DOM 构建）\n    *   JS 阻塞构建 DOM CSSOM 树，从而会阻塞构建渲染树，而且同时还会阻塞其他静态资源（图片）的下载，所以要把`<script>`标签放到 body 最后，或者是在标签里添加`defer` 或者 `async` 属性。\n    *   CSS 文件下载解析，不会阻塞 HTML 文件解析，不会阻塞 DOM 树的构建，但是会阻塞 CSSOM 树，从而会阻塞渲染树的构建，所以 CSS 文件的连接可以放在 head 里，不影响\n    *   CSS 文件下载不会阻塞其他文件下载，但是会阻塞 JS 的文件执行\n*   Web Worker\n*   服务器端渲染\n\n## 网络性能\n\n**推荐用 Angular 自带的编译方式打包**\n\nAngular 内置了 webpack 打包方式，很多人在搭建 Angular(<6.0) 项目的时候，发现 Angular 内置的 webpack 并不能满足实际项目打包的一些需求，所以通过`ng eject`把内置的 webpack.config 文件暴露出来，然后根据自己项目需求重写整个 webpack.config 配置，可以参考文章：【[Angular：如何用 Angular(<6.0) 和 Webpack 搭建项目](https://limeii.github.io/2018/09/angular-webpack/)】\n\n但是 Angular(>= 6.0)，去掉了`ng eject`命令，鼓励大家用 Angular 内置的打包方式开发 Angular 项目，因为`AoT` `Tree-Shaking` `ngc` `tsc` `minification` `Uglification` `Production mode`等等这些在 Angular 内置的打包方式中都是默认配置，不需要我们自己再去找第三方的 loader 或者 plugin 来实现类似的功能；而且从性能上说内置的打包方式要比我们自己搭的要好。\n\n如何结合内置的打包方式和我们自己的 webpack 配置文件编译打包整个项目，可以参考文章：【[Angular：如何在 Angular(8.0) 中配置 Webpack](https://limeii.github.io/2019/08/angular-customize-webpack/)】\n\n**使用 AoT 编译**\n\n在打包过程中使用 AoT 编译，指的是把所有 HTML component NgModule CSS 都编译成浏览器可以识别的 es5 代码。从而用户访问 Angular 应用的时候，只需要下载相应的 budnle 文件后直接渲染。不需要先下载`@angular/compiler`编译器编译模板文件，然后再渲染，大大提高了页面渲染性能。\n\n在模板文件中 Angular 有自己的 directive component pipe，如果不先编译成 es6 代码，就没办法做 Tree Shaking。AoT(ngc) 编译，可以把模板文件先打包成 es6 （或者 TypeScript) 文件，这样就可以做 Tree Shaking，把一些没用的代码去掉，从而减少 bundle 文件的体积，也可以提高性能。\n\n关于深入理解 Angular 编译，可以参考这篇文章：【[Angular：深入理解 Angular 编译机制](https://limeii.github.io/2019/08/angular-compiler/)】\n\n**Tree Shaking**\n\n如果项目中有一些代码 （方法、文件），在项目里完全没有被用到，这种代码称为 Dead Code。大量 Dead Code 如果编译打包进 bundle 文件，会导致 bundle 文件过大，页面渲染下载 bundle 文件的时候会浪费带宽，也会影响性能。\n\nTree Shaking 就是用来解决这种问题，它是指在编译打包过程中把 Dead Code 去掉，不把这些没用到的代码打包到最后的 bundle 文件里，从而可以减小 bundle 文件的体积，提高应用性能。可以把整个应用想象成一棵树，function/component/service/lib 好比是树叶，而那些定义但又没有被调用的 function/component/service/lib 好比是枯树叶，Tree Shaking 就是把那些枯树叶从树上摇下去。\n\n关于更多 Tree Shaking 的理解和应用可以参考这篇文章： [Angular 性能优化：Tree Shaking](https://limeii.github.io/2019/08/angular-tree-shaking/)\n\n**lazy loading 和 preloading**\n\n如果把一个大项目所有文件都打包进一个 bundle 文件，用户打开浏览器访问这个网站的时候，首先要从服务器下载这个超大的 bundle 文件，加上还需要时间做一些解析，会导致网站响应过慢。在 Angular 项目中可以通过配置 lazy loading 和 preloading 来提高性能。关于 lazy loading 和 preloading 在 Angular 项目中的理解和应用可以参考这篇文章：【[Angular：lazy loading 和 preloading](https://limeii.github.io/2018/09/angular-lazy-loading/)】\n\n**webpack Code Splitting**\n\n在项目中经常会有一些公用代码，被多个 module 或者 component 引用，如果在打包的时候直接把公用代码重复打包进不同的 bundle 文件，会造成代码冗余，也会影响应用性能。我们可以通过 webpack Code Splitting 做代码切割，把公用的代码单独提取出来放在 chunk 文件里，用户访问页面的时候只需要下载一次这个 chunk 文件就可以了。具体可以参考这篇文章：[webpack(3)：代码切割](https://limeii.github.io/2018/10/webpack-code-splitting/)\n\n**缓存**\n\n*   用 RxJS 实现缓存效果 Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Cold Observable，这导致每次调用 API，都会生成一个新的 Observable 实例，有订阅之后才开始发送值，这也符合现在前端开发要求。但是实际开发过程中，有时候后端会有提供一些公用的常量 API，不同页面都需要用这些常量，按现在的调用 API 的方式，会导致常量 API 在不同的页面重复多次被调用，这种方式显然性能不好。可以通过 ReplaySubject 实现缓存效果，第一次调用常量 API 之后把这些常量缓存起来，之后调用同样的 API 就可以直接在 ReplaySubject 拿到值，不用每次都调用后端 API。具体实现可以参考文章：【[RxJS：如何通过 RxJS 实现缓存](https://limeii.github.io/2019/08/rxjs-caching/)】\n    \n*   选择合适的浏览器缓存策略 对于一些不经常改的静态资源，可以缓存在浏览器端，合理的缓存策略可以减少延迟，在重复利用缓存的资源文件同时，可以减少带宽和降低网络负荷，从而大大提高了性能。缓存机制可以参考文章：【[浏览器缓存机制：强缓存和协商缓存](https://limeii.github.io/2018/11/web-cache/)】\n    \n*   合理的利用浏览器数据存储 对于一些常用的数据，可以存在浏览器里，这样可以减少延迟和带宽，从而可以提高性能，浏览器数据存储方式有：Cookies、SessionStorage、LocalStorage、IndexedDB。对于这些存储方式的用法和区别可以参考文章：【[浏览器数据存储方式](https://limeii.github.io/2018/11/web-storage/)】\n    \n\n**防抖**\n\n超高频触发网路请求，不仅效率低而且没办法保证请求结果的正确性，我们可以结合 RxJS 中的操作符`debounceTime` `map` `filter` `distinctUntilChanged` 和`switchMap`实现防抖。具体可以参考文章：【[RxJS：如何用 RxJS 实现高效的 HTTP 请求](https://limeii.github.io/2019/08/rxjs-searchable-input/)】\n\n**Service Worker**\n\nService Worker 可以理解为客户端和服务器端中间的一个代理服务器，它是独立于主线程的一个线程，在主线程运行的同时，它在后台运行，两者之间互不干扰。它可以拦截所有客户端的请求，也可以向服务器端发送请求，可以离线缓存资源，也可以后台同步。Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能，毫无疑问，Service Worker 也可以大大的提高页面性能。关于 Service Worker 的理解和应用，可以参考文章：【[The offline cookbook](https://jakearchibald.com/2014/offline-cookbook/)】\n\n## 页面渲染\n\n**浏览器工作原理**\n\n在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧。关于浏览器是如何解析运行 HTML CSS JS，浏览器的工作原理，可以参考参考文章：【[How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)】\n\n**Web Worker**\n\nJS 是单线程的，并且是全阻塞的，全阻塞的意思是指：在浏览器中，只要 JS 引擎在执行 JS 代码，那么就会阻塞 HTML CSS 的解析执行，从而会阻塞页面渲染和交互，如果 JS 代码执行时间比较长，那么会导致页面卡顿，影响用户体验。\n\n在 H5 中引入了 Web Worker，它的作用就是为 JS 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给 Worker 线程。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰，它的意义在于可以将一些耗时的数据处理操作（复杂耗时的计算，大文本分析上传，图像处理，canvas 图像绘制等等）从主线程中剥离，让主线程专注于页面的渲染和交互，从而提高页面性能。关于 Web Worker 的具体用法可以参考文章：【[使用 Web Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)】\n\n**使用 ChangeDetectionStrategy.OnPush 策略**\n\nAngular 默认的变化检测机制是：异步事件 callback 结束后，NgZone 会触发整个组件树至上而下做变化检测，也就是说页面一个小小的 Click 事件就会触发所有组件的变化检测。虽然 Angular 变化检测本身性能已经很好了，在毫秒内可以做成百上千次变化检测。但是随着项目越来越大，其实很多不必要的变化检测还是会在一定程度上影响性能。在 Angular 中可以通过 OnPush 来跳过一些不必要的变化检测，从而优化整个应用的性能。更多关于 OnPush 策略的理解和应用可以参考这篇文章：【 [Angular Change Detection：变化检测策略](https://limeii.github.io/2019/06/angular-changeDetectionStrategy-OnPush/)】\n\n**服务器端渲染（Server Rendering）**\n\n一般来说，像 Angular 框架搭出来的 SPA 应用，都是客户端渲染（client-side rendering）。当路由到这个页面的时候，从服务器端下载相应的 bundle/chunk 文件，在这个文件里一般只是只包含了 DOM 结构代码和 JS 代码，不是 HTML 文件。浏览器拿到这些代码，需要构建 DOM 树 / CSSOM 树 / 渲染树 / 解析执行 JS 代码，最后才是页面渲染后跟用户进行交互，如果这其中某一个步骤耗时较长，就会导致用户只能看到空白页面一直在加载，显然性能和用户体验都不好。服务器端渲染就可以用来解决这个问题，当路由到某一个页面的时候，request 发到服务器端，在服务器端会构建好这个页面（HTML 文件），再把这个 HTML 文件直接发回给客户端，这样用户在一开始就能立马看到带有内容的页面，不用等浏览器构建页面、执行 JS 代码，大大提高了性能，有更好的用户体验。\n\n**域名拆分**\n\n我们知道，在 HTTP1.1 中，浏览器对同一域名的 TCP 连接数量有限制，一般是 6 到 8 个，超过这个数量之后，就会阻塞后续的请求。有些网站为了提高性能，并行的去服务端请求更多的资源，会把资源分布到不同的域名商去，让浏览器利用更多的 TCP socket 连接。\n\n在 Angular 中，可以用 Angular Universal 来实现服务器端渲染，关于服务器端渲染和 Angular Universal 的文章可以参考：【[Rendering on the Web](https://developers.google.com/web/updates/2019/02/rendering-on-the-web)】【[Angular Universal: a Complete Practical Guide](https://blog.angular-university.io/angular-universal/)】","slug":"ReprintAngularOptimization","published":1,"updated":"2023-03-02T12:39:28.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychd00137gh8aaxm561w","content":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://limeii.github.io/2020/06/angular-performance-checklists/\" >https://limeii.github.io/2020/06/angular-performance-checklists/ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<p>性能优化主要是从两方面入手，一个是网络性能，另一个是页面渲染。在具体介绍性能优化方式之前，先来解释下为什么网络性能和页面渲染会影响性能。</p>\n<p>在这里讨论的网络带宽的性能问题都是基于 HTTP&#x2F;1.X，在 HTTP&#x2F;2 中很多性能问题都解决了。</p>\n<p>在 HTTP&#x2F;1.X 连接有三种方式：短连接，长连接和 HTTP 流水线。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/angular/angular-performance01.png\"\n                     \n                ></p>\n<p>短连接是 HTTP&#x2F;1.0 的默认模型，它每发一个请求时都会创建见一个新的 TCP 连接，收到 response 的时候就立马关闭连接，每次创建一个 TCP 连接都相当耗费资源，可想而知这种方式的性能很差，现在基本不用这种方式。</p>\n<p>在 HTTP&#x2F;1.1 以后就有了长连接和流水线，长连接是指创建一个 TCP 连接后，可以保持连接完成多次连续的请求，减少了打开 TCP 连接的次数，在 HTTP&#x2F;1.1 以后的版本是默认的长连接的模式，长连接的缺点是，就算在空闲状态，它还是会消耗服务器资源。长连接是通过 <code>Keep-Alive</code>消息头来控制。</p>\n<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到应答以后才会发出，由于受到网络延迟和带宽的限制，在下一个请求发出可能需要等很长时间。流水线是指在同一个 TCP 长连接里连续发出请求，而不用等待前一个请求应答返回，理论上这种方式是最有效的，实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显，在 HTTP&#x2F;2 已经有更好的方式替代流水线模式，流水线模式在浏览器里默认是不开启的。</p>\n<p>基于 HTTP&#x2F;1.X 的连接限制，我们在开发中过程要尽量减少网络带宽的占用，比如尽可能的减小文件的大小和减少请求次数，可以从以下几方面考虑：</p>\n<ul>\n<li>Bundling</li>\n<li>Code Splitting</li>\n<li>Minify，Uglify</li>\n<li>Compression</li>\n<li>Tree-shaking</li>\n<li>Cache</li>\n<li>lazy loading 和 preloading</li>\n<li>如果是用了前端框架，部署的时候用 AoT 的编译方式</li>\n<li>Service Worker</li>\n</ul>\n<p>页面渲染，在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧，提高页面渲染的性能，可以从以下几方面考虑：</p>\n<ul>\n<li>减少页面重排和重绘，尽量避免以下会导致页面重排和重绘的操作：<ul>\n<li>在 JS 代码中操作页面 DOM</li>\n<li>在页面 layout 稳定以后，增加和改变 CSS 样式</li>\n<li>改变：窗口大小，字体大小</li>\n<li>使用 table</li>\n<li>动画实现数度选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li>\n<li>读取 offsetwidth offsetheight</li>\n<li>CSS 伪类，比如 :hover 某个元素弹出一个消息框</li>\n</ul>\n</li>\n<li>JS 全阻塞，CSS 半阻塞（会阻塞 JS 执行和渲染树，但不阻塞 DOM 构建）<ul>\n<li>JS 阻塞构建 DOM CSSOM 树，从而会阻塞构建渲染树，而且同时还会阻塞其他静态资源（图片）的下载，所以要把<code>&lt;script&gt;</code>标签放到 body 最后，或者是在标签里添加<code>defer</code> 或者 <code>async</code> 属性。</li>\n<li>CSS 文件下载解析，不会阻塞 HTML 文件解析，不会阻塞 DOM 树的构建，但是会阻塞 CSSOM 树，从而会阻塞渲染树的构建，所以 CSS 文件的连接可以放在 head 里，不影响</li>\n<li>CSS 文件下载不会阻塞其他文件下载，但是会阻塞 JS 的文件执行</li>\n</ul>\n</li>\n<li>Web Worker</li>\n<li>服务器端渲染</li>\n</ul>\n<h2 id=\"网络性能\"><a href=\"#网络性能\" class=\"headerlink\" title=\"网络性能\"></a>网络性能</h2><p><strong>推荐用 Angular 自带的编译方式打包</strong></p>\n<p>Angular 内置了 webpack 打包方式，很多人在搭建 Angular(&lt;6.0) 项目的时候，发现 Angular 内置的 webpack 并不能满足实际项目打包的一些需求，所以通过<code>ng eject</code>把内置的 webpack.config 文件暴露出来，然后根据自己项目需求重写整个 webpack.config 配置，可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/09/angular-webpack/\" >Angular：如何用 Angular(&lt;6.0) 和 Webpack 搭建项目 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p>但是 Angular(&gt;&#x3D; 6.0)，去掉了<code>ng eject</code>命令，鼓励大家用 Angular 内置的打包方式开发 Angular 项目，因为<code>AoT</code> <code>Tree-Shaking</code> <code>ngc</code> <code>tsc</code> <code>minification</code> <code>Uglification</code> <code>Production mode</code>等等这些在 Angular 内置的打包方式中都是默认配置，不需要我们自己再去找第三方的 loader 或者 plugin 来实现类似的功能；而且从性能上说内置的打包方式要比我们自己搭的要好。</p>\n<p>如何结合内置的打包方式和我们自己的 webpack 配置文件编译打包整个项目，可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/angular-customize-webpack/\" >Angular：如何在 Angular(8.0) 中配置 Webpack <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>使用 AoT 编译</strong></p>\n<p>在打包过程中使用 AoT 编译，指的是把所有 HTML component NgModule CSS 都编译成浏览器可以识别的 es5 代码。从而用户访问 Angular 应用的时候，只需要下载相应的 budnle 文件后直接渲染。不需要先下载<code>@angular/compiler</code>编译器编译模板文件，然后再渲染，大大提高了页面渲染性能。</p>\n<p>在模板文件中 Angular 有自己的 directive component pipe，如果不先编译成 es6 代码，就没办法做 Tree Shaking。AoT(ngc) 编译，可以把模板文件先打包成 es6 （或者 TypeScript) 文件，这样就可以做 Tree Shaking，把一些没用的代码去掉，从而减少 bundle 文件的体积，也可以提高性能。</p>\n<p>关于深入理解 Angular 编译，可以参考这篇文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/angular-compiler/\" >Angular：深入理解 Angular 编译机制 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>Tree Shaking</strong></p>\n<p>如果项目中有一些代码 （方法、文件），在项目里完全没有被用到，这种代码称为 Dead Code。大量 Dead Code 如果编译打包进 bundle 文件，会导致 bundle 文件过大，页面渲染下载 bundle 文件的时候会浪费带宽，也会影响性能。</p>\n<p>Tree Shaking 就是用来解决这种问题，它是指在编译打包过程中把 Dead Code 去掉，不把这些没用到的代码打包到最后的 bundle 文件里，从而可以减小 bundle 文件的体积，提高应用性能。可以把整个应用想象成一棵树，function&#x2F;component&#x2F;service&#x2F;lib 好比是树叶，而那些定义但又没有被调用的 function&#x2F;component&#x2F;service&#x2F;lib 好比是枯树叶，Tree Shaking 就是把那些枯树叶从树上摇下去。</p>\n<p>关于更多 Tree Shaking 的理解和应用可以参考这篇文章： <a class=\"link\"   href=\"https://limeii.github.io/2019/08/angular-tree-shaking/\" >Angular 性能优化：Tree Shaking <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>lazy loading 和 preloading</strong></p>\n<p>如果把一个大项目所有文件都打包进一个 bundle 文件，用户打开浏览器访问这个网站的时候，首先要从服务器下载这个超大的 bundle 文件，加上还需要时间做一些解析，会导致网站响应过慢。在 Angular 项目中可以通过配置 lazy loading 和 preloading 来提高性能。关于 lazy loading 和 preloading 在 Angular 项目中的理解和应用可以参考这篇文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/09/angular-lazy-loading/\" >Angular：lazy loading 和 preloading <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>webpack Code Splitting</strong></p>\n<p>在项目中经常会有一些公用代码，被多个 module 或者 component 引用，如果在打包的时候直接把公用代码重复打包进不同的 bundle 文件，会造成代码冗余，也会影响应用性能。我们可以通过 webpack Code Splitting 做代码切割，把公用的代码单独提取出来放在 chunk 文件里，用户访问页面的时候只需要下载一次这个 chunk 文件就可以了。具体可以参考这篇文章：<a class=\"link\"   href=\"https://limeii.github.io/2018/10/webpack-code-splitting/\" >webpack(3)：代码切割 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>缓存</strong></p>\n<ul>\n<li><p>用 RxJS 实现缓存效果 Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Cold Observable，这导致每次调用 API，都会生成一个新的 Observable 实例，有订阅之后才开始发送值，这也符合现在前端开发要求。但是实际开发过程中，有时候后端会有提供一些公用的常量 API，不同页面都需要用这些常量，按现在的调用 API 的方式，会导致常量 API 在不同的页面重复多次被调用，这种方式显然性能不好。可以通过 ReplaySubject 实现缓存效果，第一次调用常量 API 之后把这些常量缓存起来，之后调用同样的 API 就可以直接在 ReplaySubject 拿到值，不用每次都调用后端 API。具体实现可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/rxjs-caching/\" >RxJS：如何通过 RxJS 实现缓存 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n</li>\n<li><p>选择合适的浏览器缓存策略 对于一些不经常改的静态资源，可以缓存在浏览器端，合理的缓存策略可以减少延迟，在重复利用缓存的资源文件同时，可以减少带宽和降低网络负荷，从而大大提高了性能。缓存机制可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/11/web-cache/\" >浏览器缓存机制：强缓存和协商缓存 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n</li>\n<li><p>合理的利用浏览器数据存储 对于一些常用的数据，可以存在浏览器里，这样可以减少延迟和带宽，从而可以提高性能，浏览器数据存储方式有：Cookies、SessionStorage、LocalStorage、IndexedDB。对于这些存储方式的用法和区别可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/11/web-storage/\" >浏览器数据存储方式 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n</li>\n</ul>\n<p><strong>防抖</strong></p>\n<p>超高频触发网路请求，不仅效率低而且没办法保证请求结果的正确性，我们可以结合 RxJS 中的操作符<code>debounceTime</code> <code>map</code> <code>filter</code> <code>distinctUntilChanged</code> 和<code>switchMap</code>实现防抖。具体可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/rxjs-searchable-input/\" >RxJS：如何用 RxJS 实现高效的 HTTP 请求 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>Service Worker</strong></p>\n<p>Service Worker 可以理解为客户端和服务器端中间的一个代理服务器，它是独立于主线程的一个线程，在主线程运行的同时，它在后台运行，两者之间互不干扰。它可以拦截所有客户端的请求，也可以向服务器端发送请求，可以离线缓存资源，也可以后台同步。Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能，毫无疑问，Service Worker 也可以大大的提高页面性能。关于 Service Worker 的理解和应用，可以参考文章：【<a class=\"link\"   href=\"https://jakearchibald.com/2014/offline-cookbook/\" >The offline cookbook <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<h2 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h2><p><strong>浏览器工作原理</strong></p>\n<p>在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧。关于浏览器是如何解析运行 HTML CSS JS，浏览器的工作原理，可以参考参考文章：【<a class=\"link\"   href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/\" >How Browsers Work: Behind the scenes of modern web browsers <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>Web Worker</strong></p>\n<p>JS 是单线程的，并且是全阻塞的，全阻塞的意思是指：在浏览器中，只要 JS 引擎在执行 JS 代码，那么就会阻塞 HTML CSS 的解析执行，从而会阻塞页面渲染和交互，如果 JS 代码执行时间比较长，那么会导致页面卡顿，影响用户体验。</p>\n<p>在 H5 中引入了 Web Worker，它的作用就是为 JS 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给 Worker 线程。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰，它的意义在于可以将一些耗时的数据处理操作（复杂耗时的计算，大文本分析上传，图像处理，canvas 图像绘制等等）从主线程中剥离，让主线程专注于页面的渲染和交互，从而提高页面性能。关于 Web Worker 的具体用法可以参考文章：【<a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers\" >使用 Web Workers <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>使用 ChangeDetectionStrategy.OnPush 策略</strong></p>\n<p>Angular 默认的变化检测机制是：异步事件 callback 结束后，NgZone 会触发整个组件树至上而下做变化检测，也就是说页面一个小小的 Click 事件就会触发所有组件的变化检测。虽然 Angular 变化检测本身性能已经很好了，在毫秒内可以做成百上千次变化检测。但是随着项目越来越大，其实很多不必要的变化检测还是会在一定程度上影响性能。在 Angular 中可以通过 OnPush 来跳过一些不必要的变化检测，从而优化整个应用的性能。更多关于 OnPush 策略的理解和应用可以参考这篇文章：【 <a class=\"link\"   href=\"https://limeii.github.io/2019/06/angular-changeDetectionStrategy-OnPush/\" >Angular Change Detection：变化检测策略 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>服务器端渲染（Server Rendering）</strong></p>\n<p>一般来说，像 Angular 框架搭出来的 SPA 应用，都是客户端渲染（client-side rendering）。当路由到这个页面的时候，从服务器端下载相应的 bundle&#x2F;chunk 文件，在这个文件里一般只是只包含了 DOM 结构代码和 JS 代码，不是 HTML 文件。浏览器拿到这些代码，需要构建 DOM 树 &#x2F; CSSOM 树 &#x2F; 渲染树 &#x2F; 解析执行 JS 代码，最后才是页面渲染后跟用户进行交互，如果这其中某一个步骤耗时较长，就会导致用户只能看到空白页面一直在加载，显然性能和用户体验都不好。服务器端渲染就可以用来解决这个问题，当路由到某一个页面的时候，request 发到服务器端，在服务器端会构建好这个页面（HTML 文件），再把这个 HTML 文件直接发回给客户端，这样用户在一开始就能立马看到带有内容的页面，不用等浏览器构建页面、执行 JS 代码，大大提高了性能，有更好的用户体验。</p>\n<p><strong>域名拆分</strong></p>\n<p>我们知道，在 HTTP1.1 中，浏览器对同一域名的 TCP 连接数量有限制，一般是 6 到 8 个，超过这个数量之后，就会阻塞后续的请求。有些网站为了提高性能，并行的去服务端请求更多的资源，会把资源分布到不同的域名商去，让浏览器利用更多的 TCP socket 连接。</p>\n<p>在 Angular 中，可以用 Angular Universal 来实现服务器端渲染，关于服务器端渲染和 Angular Universal 的文章可以参考：【<a class=\"link\"   href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web\" >Rendering on the Web <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】【<a class=\"link\"   href=\"https://blog.angular-university.io/angular-universal/\" >Angular Universal: a Complete Practical Guide <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://limeii.github.io/2020/06/angular-performance-checklists/\" >https://limeii.github.io/2020/06/angular-performance-checklists/ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<p>性能优化主要是从两方面入手，一个是网络性能，另一个是页面渲染。在具体介绍性能优化方式之前，先来解释下为什么网络性能和页面渲染会影响性能。</p>\n<p>在这里讨论的网络带宽的性能问题都是基于 HTTP&#x2F;1.X，在 HTTP&#x2F;2 中很多性能问题都解决了。</p>\n<p>在 HTTP&#x2F;1.X 连接有三种方式：短连接，长连接和 HTTP 流水线。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/angular/angular-performance01.png\"\n                     \n                ></p>\n<p>短连接是 HTTP&#x2F;1.0 的默认模型，它每发一个请求时都会创建见一个新的 TCP 连接，收到 response 的时候就立马关闭连接，每次创建一个 TCP 连接都相当耗费资源，可想而知这种方式的性能很差，现在基本不用这种方式。</p>\n<p>在 HTTP&#x2F;1.1 以后就有了长连接和流水线，长连接是指创建一个 TCP 连接后，可以保持连接完成多次连续的请求，减少了打开 TCP 连接的次数，在 HTTP&#x2F;1.1 以后的版本是默认的长连接的模式，长连接的缺点是，就算在空闲状态，它还是会消耗服务器资源。长连接是通过 <code>Keep-Alive</code>消息头来控制。</p>\n<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到应答以后才会发出，由于受到网络延迟和带宽的限制，在下一个请求发出可能需要等很长时间。流水线是指在同一个 TCP 长连接里连续发出请求，而不用等待前一个请求应答返回，理论上这种方式是最有效的，实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显，在 HTTP&#x2F;2 已经有更好的方式替代流水线模式，流水线模式在浏览器里默认是不开启的。</p>\n<p>基于 HTTP&#x2F;1.X 的连接限制，我们在开发中过程要尽量减少网络带宽的占用，比如尽可能的减小文件的大小和减少请求次数，可以从以下几方面考虑：</p>\n<ul>\n<li>Bundling</li>\n<li>Code Splitting</li>\n<li>Minify，Uglify</li>\n<li>Compression</li>\n<li>Tree-shaking</li>\n<li>Cache</li>\n<li>lazy loading 和 preloading</li>\n<li>如果是用了前端框架，部署的时候用 AoT 的编译方式</li>\n<li>Service Worker</li>\n</ul>\n<p>页面渲染，在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧，提高页面渲染的性能，可以从以下几方面考虑：</p>\n<ul>\n<li>减少页面重排和重绘，尽量避免以下会导致页面重排和重绘的操作：<ul>\n<li>在 JS 代码中操作页面 DOM</li>\n<li>在页面 layout 稳定以后，增加和改变 CSS 样式</li>\n<li>改变：窗口大小，字体大小</li>\n<li>使用 table</li>\n<li>动画实现数度选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li>\n<li>读取 offsetwidth offsetheight</li>\n<li>CSS 伪类，比如 :hover 某个元素弹出一个消息框</li>\n</ul>\n</li>\n<li>JS 全阻塞，CSS 半阻塞（会阻塞 JS 执行和渲染树，但不阻塞 DOM 构建）<ul>\n<li>JS 阻塞构建 DOM CSSOM 树，从而会阻塞构建渲染树，而且同时还会阻塞其他静态资源（图片）的下载，所以要把<code>&lt;script&gt;</code>标签放到 body 最后，或者是在标签里添加<code>defer</code> 或者 <code>async</code> 属性。</li>\n<li>CSS 文件下载解析，不会阻塞 HTML 文件解析，不会阻塞 DOM 树的构建，但是会阻塞 CSSOM 树，从而会阻塞渲染树的构建，所以 CSS 文件的连接可以放在 head 里，不影响</li>\n<li>CSS 文件下载不会阻塞其他文件下载，但是会阻塞 JS 的文件执行</li>\n</ul>\n</li>\n<li>Web Worker</li>\n<li>服务器端渲染</li>\n</ul>\n<h2 id=\"网络性能\"><a href=\"#网络性能\" class=\"headerlink\" title=\"网络性能\"></a>网络性能</h2><p><strong>推荐用 Angular 自带的编译方式打包</strong></p>\n<p>Angular 内置了 webpack 打包方式，很多人在搭建 Angular(&lt;6.0) 项目的时候，发现 Angular 内置的 webpack 并不能满足实际项目打包的一些需求，所以通过<code>ng eject</code>把内置的 webpack.config 文件暴露出来，然后根据自己项目需求重写整个 webpack.config 配置，可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/09/angular-webpack/\" >Angular：如何用 Angular(&lt;6.0) 和 Webpack 搭建项目 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p>但是 Angular(&gt;&#x3D; 6.0)，去掉了<code>ng eject</code>命令，鼓励大家用 Angular 内置的打包方式开发 Angular 项目，因为<code>AoT</code> <code>Tree-Shaking</code> <code>ngc</code> <code>tsc</code> <code>minification</code> <code>Uglification</code> <code>Production mode</code>等等这些在 Angular 内置的打包方式中都是默认配置，不需要我们自己再去找第三方的 loader 或者 plugin 来实现类似的功能；而且从性能上说内置的打包方式要比我们自己搭的要好。</p>\n<p>如何结合内置的打包方式和我们自己的 webpack 配置文件编译打包整个项目，可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/angular-customize-webpack/\" >Angular：如何在 Angular(8.0) 中配置 Webpack <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>使用 AoT 编译</strong></p>\n<p>在打包过程中使用 AoT 编译，指的是把所有 HTML component NgModule CSS 都编译成浏览器可以识别的 es5 代码。从而用户访问 Angular 应用的时候，只需要下载相应的 budnle 文件后直接渲染。不需要先下载<code>@angular/compiler</code>编译器编译模板文件，然后再渲染，大大提高了页面渲染性能。</p>\n<p>在模板文件中 Angular 有自己的 directive component pipe，如果不先编译成 es6 代码，就没办法做 Tree Shaking。AoT(ngc) 编译，可以把模板文件先打包成 es6 （或者 TypeScript) 文件，这样就可以做 Tree Shaking，把一些没用的代码去掉，从而减少 bundle 文件的体积，也可以提高性能。</p>\n<p>关于深入理解 Angular 编译，可以参考这篇文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/angular-compiler/\" >Angular：深入理解 Angular 编译机制 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>Tree Shaking</strong></p>\n<p>如果项目中有一些代码 （方法、文件），在项目里完全没有被用到，这种代码称为 Dead Code。大量 Dead Code 如果编译打包进 bundle 文件，会导致 bundle 文件过大，页面渲染下载 bundle 文件的时候会浪费带宽，也会影响性能。</p>\n<p>Tree Shaking 就是用来解决这种问题，它是指在编译打包过程中把 Dead Code 去掉，不把这些没用到的代码打包到最后的 bundle 文件里，从而可以减小 bundle 文件的体积，提高应用性能。可以把整个应用想象成一棵树，function&#x2F;component&#x2F;service&#x2F;lib 好比是树叶，而那些定义但又没有被调用的 function&#x2F;component&#x2F;service&#x2F;lib 好比是枯树叶，Tree Shaking 就是把那些枯树叶从树上摇下去。</p>\n<p>关于更多 Tree Shaking 的理解和应用可以参考这篇文章： <a class=\"link\"   href=\"https://limeii.github.io/2019/08/angular-tree-shaking/\" >Angular 性能优化：Tree Shaking <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>lazy loading 和 preloading</strong></p>\n<p>如果把一个大项目所有文件都打包进一个 bundle 文件，用户打开浏览器访问这个网站的时候，首先要从服务器下载这个超大的 bundle 文件，加上还需要时间做一些解析，会导致网站响应过慢。在 Angular 项目中可以通过配置 lazy loading 和 preloading 来提高性能。关于 lazy loading 和 preloading 在 Angular 项目中的理解和应用可以参考这篇文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/09/angular-lazy-loading/\" >Angular：lazy loading 和 preloading <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>webpack Code Splitting</strong></p>\n<p>在项目中经常会有一些公用代码，被多个 module 或者 component 引用，如果在打包的时候直接把公用代码重复打包进不同的 bundle 文件，会造成代码冗余，也会影响应用性能。我们可以通过 webpack Code Splitting 做代码切割，把公用的代码单独提取出来放在 chunk 文件里，用户访问页面的时候只需要下载一次这个 chunk 文件就可以了。具体可以参考这篇文章：<a class=\"link\"   href=\"https://limeii.github.io/2018/10/webpack-code-splitting/\" >webpack(3)：代码切割 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>缓存</strong></p>\n<ul>\n<li><p>用 RxJS 实现缓存效果 Angular 中通过 HttpClient 执行 Http Request 返回的 Observables 是 Cold Observable，这导致每次调用 API，都会生成一个新的 Observable 实例，有订阅之后才开始发送值，这也符合现在前端开发要求。但是实际开发过程中，有时候后端会有提供一些公用的常量 API，不同页面都需要用这些常量，按现在的调用 API 的方式，会导致常量 API 在不同的页面重复多次被调用，这种方式显然性能不好。可以通过 ReplaySubject 实现缓存效果，第一次调用常量 API 之后把这些常量缓存起来，之后调用同样的 API 就可以直接在 ReplaySubject 拿到值，不用每次都调用后端 API。具体实现可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/rxjs-caching/\" >RxJS：如何通过 RxJS 实现缓存 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n</li>\n<li><p>选择合适的浏览器缓存策略 对于一些不经常改的静态资源，可以缓存在浏览器端，合理的缓存策略可以减少延迟，在重复利用缓存的资源文件同时，可以减少带宽和降低网络负荷，从而大大提高了性能。缓存机制可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/11/web-cache/\" >浏览器缓存机制：强缓存和协商缓存 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n</li>\n<li><p>合理的利用浏览器数据存储 对于一些常用的数据，可以存在浏览器里，这样可以减少延迟和带宽，从而可以提高性能，浏览器数据存储方式有：Cookies、SessionStorage、LocalStorage、IndexedDB。对于这些存储方式的用法和区别可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2018/11/web-storage/\" >浏览器数据存储方式 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n</li>\n</ul>\n<p><strong>防抖</strong></p>\n<p>超高频触发网路请求，不仅效率低而且没办法保证请求结果的正确性，我们可以结合 RxJS 中的操作符<code>debounceTime</code> <code>map</code> <code>filter</code> <code>distinctUntilChanged</code> 和<code>switchMap</code>实现防抖。具体可以参考文章：【<a class=\"link\"   href=\"https://limeii.github.io/2019/08/rxjs-searchable-input/\" >RxJS：如何用 RxJS 实现高效的 HTTP 请求 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>Service Worker</strong></p>\n<p>Service Worker 可以理解为客户端和服务器端中间的一个代理服务器，它是独立于主线程的一个线程，在主线程运行的同时，它在后台运行，两者之间互不干扰。它可以拦截所有客户端的请求，也可以向服务器端发送请求，可以离线缓存资源，也可以后台同步。Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能，毫无疑问，Service Worker 也可以大大的提高页面性能。关于 Service Worker 的理解和应用，可以参考文章：【<a class=\"link\"   href=\"https://jakearchibald.com/2014/offline-cookbook/\" >The offline cookbook <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<h2 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h2><p><strong>浏览器工作原理</strong></p>\n<p>在正常情况下浏览器是 60Hz 的刷新率，每 16.6ms 会刷新一次页面，渲染页面的操作需要在这 16.6ms 内完成，否则就会导致页面失帧。关于浏览器是如何解析运行 HTML CSS JS，浏览器的工作原理，可以参考参考文章：【<a class=\"link\"   href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/\" >How Browsers Work: Behind the scenes of modern web browsers <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>Web Worker</strong></p>\n<p>JS 是单线程的，并且是全阻塞的，全阻塞的意思是指：在浏览器中，只要 JS 引擎在执行 JS 代码，那么就会阻塞 HTML CSS 的解析执行，从而会阻塞页面渲染和交互，如果 JS 代码执行时间比较长，那么会导致页面卡顿，影响用户体验。</p>\n<p>在 H5 中引入了 Web Worker，它的作用就是为 JS 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给 Worker 线程。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰，它的意义在于可以将一些耗时的数据处理操作（复杂耗时的计算，大文本分析上传，图像处理，canvas 图像绘制等等）从主线程中剥离，让主线程专注于页面的渲染和交互，从而提高页面性能。关于 Web Worker 的具体用法可以参考文章：【<a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers\" >使用 Web Workers <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>使用 ChangeDetectionStrategy.OnPush 策略</strong></p>\n<p>Angular 默认的变化检测机制是：异步事件 callback 结束后，NgZone 会触发整个组件树至上而下做变化检测，也就是说页面一个小小的 Click 事件就会触发所有组件的变化检测。虽然 Angular 变化检测本身性能已经很好了，在毫秒内可以做成百上千次变化检测。但是随着项目越来越大，其实很多不必要的变化检测还是会在一定程度上影响性能。在 Angular 中可以通过 OnPush 来跳过一些不必要的变化检测，从而优化整个应用的性能。更多关于 OnPush 策略的理解和应用可以参考这篇文章：【 <a class=\"link\"   href=\"https://limeii.github.io/2019/06/angular-changeDetectionStrategy-OnPush/\" >Angular Change Detection：变化检测策略 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n<p><strong>服务器端渲染（Server Rendering）</strong></p>\n<p>一般来说，像 Angular 框架搭出来的 SPA 应用，都是客户端渲染（client-side rendering）。当路由到这个页面的时候，从服务器端下载相应的 bundle&#x2F;chunk 文件，在这个文件里一般只是只包含了 DOM 结构代码和 JS 代码，不是 HTML 文件。浏览器拿到这些代码，需要构建 DOM 树 &#x2F; CSSOM 树 &#x2F; 渲染树 &#x2F; 解析执行 JS 代码，最后才是页面渲染后跟用户进行交互，如果这其中某一个步骤耗时较长，就会导致用户只能看到空白页面一直在加载，显然性能和用户体验都不好。服务器端渲染就可以用来解决这个问题，当路由到某一个页面的时候，request 发到服务器端，在服务器端会构建好这个页面（HTML 文件），再把这个 HTML 文件直接发回给客户端，这样用户在一开始就能立马看到带有内容的页面，不用等浏览器构建页面、执行 JS 代码，大大提高了性能，有更好的用户体验。</p>\n<p><strong>域名拆分</strong></p>\n<p>我们知道，在 HTTP1.1 中，浏览器对同一域名的 TCP 连接数量有限制，一般是 6 到 8 个，超过这个数量之后，就会阻塞后续的请求。有些网站为了提高性能，并行的去服务端请求更多的资源，会把资源分布到不同的域名商去，让浏览器利用更多的 TCP socket 连接。</p>\n<p>在 Angular 中，可以用 Angular Universal 来实现服务器端渲染，关于服务器端渲染和 Angular Universal 的文章可以参考：【<a class=\"link\"   href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web\" >Rendering on the Web <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】【<a class=\"link\"   href=\"https://blog.angular-university.io/angular-universal/\" >Angular Universal: a Complete Practical Guide <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>】</p>\n"},{"url":"https://limeii.github.io/2019/05/js-eventloop/","title":"【转载】JS：详解 Event Loop 运行机制","date":"2021-09-12T12:33:02.000Z","_content":"\n> 原文转自：https://limeii.github.io/2019/05/js-eventloop/\n\n\n在这篇文章中会介绍以下内容：\n\n*   engine runtime 和 call stack 简介（以 V8 引擎为例）\n    \n*   Event Loop 运行机制的详解\n    \n*   microtasks 和 macrotask 的执行顺序\n    \n\n## engine runtime 和 call stack 简介\n\n在 chrome 浏览器和 nodejs 里都是用 V8 引擎解析和运行 JS 代码，我们先来看下 V8 引擎的简化图：\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop01.png)\n\n上图中 Heap 是用来做内存分配，`Call Stack`是用来执行 JS 代码，由于 JS 是单线程所以只有一个`Call Stack`。实际我们写网页开发的时候，除了一些 JS 代码，我们还会大量用到：DOM 事件、AJAX(XMLHttpRequest)、setTimeout 等等一些异步事件。从上图可以看出，这些异步事件都没有在 V8 引擎里，事实上这些异步事件不属于 V8 引擎，而是属于浏览器，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都分别有单独的线程来处理。由于`Call Stack`执行（JS 运行线程）和页面渲染线程是互斥的，如果所有的事情都由 V8 引擎处理，这样肯定会导致页面卡顿。\n\n浏览器多线程和 callback 机制完美避免了页面卡顿的问题。DOM 事件、AJAX(XMLHttpRequest)、setTimeout 这些异步事件在各自单独的线程处理完以后，每个异步事件都有 callback 回调函数，V8 引擎再把这些回调函数放在`Call Stack`执行。上述整个运行机制可以称为是 runtime，可以简化如下图：\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop02.png)\n\n如上图所示，web 异步事件结束以后，会有 callback，然后 runtime 把这些 callback 事件放到`Callback Queue`里，一旦`Call Stack`所有的方法都执行完以后，`Event Loop`会依次把 `Callback Queue`里的回调函数放到`Call Stack`里执行。\n\n## Event Loop 运行机制的详解\n\nEvent Loop 实际上就是一个 job，用来检测 Call Stack 和 Callback Queue，一旦 Call Stack 里代码执行完以后，就会把 Callback Queue 里第一个 callback 函数放到 Call Stack 里执行。我们来看个例子：\n\n```\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 1000);\n\nconsole.log('script end');\n\n```\n\n运行运行结果如下：\n```\nscript start\nscript end\nsetTimeout\n\n```\n\n我们具体一步一步看下整个流程：\n\n1，代码没有运行之前，`Call Stack` `Callback Queue`都是空的\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop03.png)\n\n2，把`console.log('script start')`加到 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop04.png)\n\n3，执行`console.log('script start')`，在 console 里打印出`script start`，执行结束后把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop05.png)\n\n4，把 setTimeout 放到 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop06.png)\n\n5, 执行 setTimeout，用 setTimout 线程执行 timeout 时间，Call Stack 中 setTimeout 执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop07.png)\n\n6, 把`console.log('script end')`加到 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop08.png)\n\n7，执行`console.log('script end')`，在 console 里打印出`script end`\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop09.png)\n\n8，`console.log('script end')`执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop10.png)\n\n9，1000 毫秒以后，计时结束，把 callback`cb1`函数放到 Callback Queue 里\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop11.png)\n\n10，此时 Callback Stack 是空的，Event Loop 把 cb1 拿到 Callback Stack 里\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop12.png)\n\n11，执行 cb1，cb1 里有`console.log('setTimeout')`，把`console.log('setTimeout')`放到 Call Stack 里\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop13.png)\n\n12，执行`console.log('setTimeout')`，在 console 里打印出`setTimeout`，`console.log('setTimeout')`执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop14.png)\n\n13，`cb1`执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop15.png)\n\n总结来说就是，JS 是单线程的，只有一个 Call Stack，浏览器是多线程的，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都是有单独的线程处理。在这些异步事件结束，runtime 会把它们的 callback 按顺序放到 Callback Queue 里，Event Loop 会检测 Call Stack，一旦它为空，就会把 Callback Queue 里的回调函数依次放到 Call Stack 里执行，直到 Callback Queue 为空。\n\n## microtasks 和 macrotask 的执行顺序\n\n刚才用 setTimeout 为例，解释了 JS 中 Event Loop 机制是怎么运行的，也提到过 runtime 会把回调函数依次按时间先后顺序放到 Callback Queue 里，然后 Event Loop 再依次把这些回调函数放到 Call Stack 里运行。我们在浏览器 Console 运行以下代码，看下结果：\n\n```\nconsole.log('script start');\n\nsetTimeout(function () {\n    console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function () {\n    console.log('promise1');\n}).then(function () {\n    console.log('promise2');\n});\n\nconsole.log('script end');\n\n```\n\n执行结果如下：\n\n```\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n\n```\n\n上述代码虽然 setTimeout 延时为 0，其实还是异步的。因为 H5 标准规定 setTimeout 函数的第二个参数不能小于 4 毫秒，不足会自动增加。\n\nsetTimeout 和 promise 都是异步事件，而且 setTimeout 写在 promise 之前，为什么 setTimeout 的回调要比 promise 后执行呢？那是因为 promise 属于微任务（microtasks）而 setTimeout 属于宏任务（macrotask），微任务（microtasks）的优先级要高于宏任务（macrotask）。\n\n首先我们需要明白以下几件事情：\n\n*   JS 分为同步任务和异步任务\n*   同步任务都在主线程上执行，形成一个执行栈\n*   主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。\n*   一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。\n\n根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列 (task queue)，一个任务队列便是一系列有序任务 (task) 的集合；每个任务都有一个任务源 (task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop16.png)\n\nCallback Queue（Task Queue）里的回调事件称为宏任务（macrotask），每次异步事件结束后，它们的回调函数会依次按时间顺序放在 Callback Queue 里，等待 Event Loop 依次把它们放到 Call Stack 里执行。比如：`setInterval` `setTimeout` `script` `setImmediate` `I/O` `UI rendering`就是宏任务（macrotask）。\n\n微任务（microtasks）是指异步事件结束后，回调函数不会放到 Callback Queue，而是放到一个微任务队列里（Microtasks Queue），在 Call Stack 为空时，Event Loop 会先查看微任务队列里是否有任务，如果有就会先执行微任务队列里的回调事件；如果没有微任务，才会到 Callback Queue 执行回到事件。比如：`promise` `process.netTick` `Object.observe` `MutationObserver`就是微任务（microtasks）。\n\n在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。\n\n整个 Event Loop 的执行顺序如下：\n\n*   执行一个宏任务（栈中没有就从事件队列中获取）\n*   执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n*   宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n*   当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染\n*   渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取，也就是 callbacke queue）\n\n流程图如下：\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop17.jpg)\n\n我们再把代码改一下，在创建 promise 的时候，加一行`console.log('Promise')`，而且在第一个 promise resolve 的时候再加一个 setTimeout，代码如下：\n\n```\nconsole.log('script start');\n\nsetTimeout(function () {\n    console.log('setTimeout');\n}, 0);\n\nnew Promise(resolve => {\n    console.log('Promise');\n    resolve();\n}).then(function () {\n    setTimeout(function () {\n        console.log('setTimeout in promise1');\n    }, 0);\n    console.log('promise1');\n}).then(function () {\n    console.log('promise2');\n});\n\nconsole.log('script end');\n\n/**\nscript start\nPromise\nscript end\npromise1\npromise2\nsetTimeout\nsetTimeout in promise1\n**/\n\n```\n\n`console.log('Promise')`在这里是同步代码，`console.log('script end')`是同步代码且放在最后，所以`Promise`在`script end`前面，而且在微任务（microtasks）里有宏任务（macrotask），macrotask 还是会依次被放到 Callback Queue 等待执行。\n\n如果有 async await 呢？再来看一段代码：\n\n```\n//请写出输出内容\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\nasync function async2() {\n\tconsole.log('async2');\n}\n\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\n\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n});\nconsole.log('script end');\n\n/**\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n**/\n\n```\n\n我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async/await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？\n\n由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tawait async2();\n\tconsole.log('async1 end');\n}\n\n```\n\n等价于：\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tPromise.resolve(async2()).then(() => {\n                console.log('async1 end');\n        })\n}\n\n```\n\n我们来看一个变式，将 async2 中的函数也变成了 Promise 函数：\n\n```\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\nasync function async2() {\n    //async2 做出如下更改：\n    new Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n    });\n}\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise3');\n    resolve();\n}).then(function() {\n    console.log('promise4');\n});\n\nconsole.log('script end');\n\n/**\nscript start\nasync1 start\npromise1\npromise3\nscript end\npromise2\nasync1 end\npromise4\nsetTimeout\n**/\n\n```\n\n我们再来看一个变式，将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下：\n\n```\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    //更改如下：\n    setTimeout(function() {\n        console.log('setTimeout1')\n    },0)\n}\nasync function async2() {\n    //更改如下：\n\tsetTimeout(function() {\n\t\tconsole.log('setTimeout2')\n\t},0)\n}\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout3');\n}, 0)\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n});\nconsole.log('script end');\n\n/**\nscript start\nasync1 start\npromise1\nscript end\npromise2\nsetTimeout3\nsetTimeout2\nsetTimeout1\n**/\n\n```\n\n我们再来看一个变式，代码如下：\n\n```\nasync function a1 () {\n    console.log('a1 start')\n    await a2()\n    console.log('a1 end')\n}\nasync function a2 () {\n    console.log('a2')\n}\n\nconsole.log('script start')\n\nsetTimeout(() => {\n    console.log('setTimeout')\n}, 0)\n\nPromise.resolve().then(() => {\n    console.log('promise1')\n})\n\na1()\n\nlet promise2 = new Promise((resolve) => {\n    resolve('promise2.then')\n    console.log('promise2')\n})\n\npromise2.then((res) => {\n    console.log(res)\n    Promise.resolve().then(() => {\n        console.log('promise3')\n    })\n})\nconsole.log('script end')\n\n/**\nscript start\na1 start\na2\npromise2\nscript end\npromise1\na1 end\npromise2.then\npromise3\nsetTimeout\n**/\n\n```\n\n参考资料：\n\n*   [“Event loops”, section in HTML5 spec.](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)\n*   [“Help, I’m stuck in an event-loop” by Philip Roberts (video).](https://vimeo.com/96425312)","source":"_posts/ReprintJSEventLoop.md","raw":"---\nurl: https://limeii.github.io/2019/05/js-eventloop/\ntitle: 【转载】JS：详解 Event Loop 运行机制\ndate: 2021-09-12 20:33:02\ntags: [JS]\ncategories: [转载]\n---\n\n> 原文转自：https://limeii.github.io/2019/05/js-eventloop/\n\n\n在这篇文章中会介绍以下内容：\n\n*   engine runtime 和 call stack 简介（以 V8 引擎为例）\n    \n*   Event Loop 运行机制的详解\n    \n*   microtasks 和 macrotask 的执行顺序\n    \n\n## engine runtime 和 call stack 简介\n\n在 chrome 浏览器和 nodejs 里都是用 V8 引擎解析和运行 JS 代码，我们先来看下 V8 引擎的简化图：\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop01.png)\n\n上图中 Heap 是用来做内存分配，`Call Stack`是用来执行 JS 代码，由于 JS 是单线程所以只有一个`Call Stack`。实际我们写网页开发的时候，除了一些 JS 代码，我们还会大量用到：DOM 事件、AJAX(XMLHttpRequest)、setTimeout 等等一些异步事件。从上图可以看出，这些异步事件都没有在 V8 引擎里，事实上这些异步事件不属于 V8 引擎，而是属于浏览器，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都分别有单独的线程来处理。由于`Call Stack`执行（JS 运行线程）和页面渲染线程是互斥的，如果所有的事情都由 V8 引擎处理，这样肯定会导致页面卡顿。\n\n浏览器多线程和 callback 机制完美避免了页面卡顿的问题。DOM 事件、AJAX(XMLHttpRequest)、setTimeout 这些异步事件在各自单独的线程处理完以后，每个异步事件都有 callback 回调函数，V8 引擎再把这些回调函数放在`Call Stack`执行。上述整个运行机制可以称为是 runtime，可以简化如下图：\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop02.png)\n\n如上图所示，web 异步事件结束以后，会有 callback，然后 runtime 把这些 callback 事件放到`Callback Queue`里，一旦`Call Stack`所有的方法都执行完以后，`Event Loop`会依次把 `Callback Queue`里的回调函数放到`Call Stack`里执行。\n\n## Event Loop 运行机制的详解\n\nEvent Loop 实际上就是一个 job，用来检测 Call Stack 和 Callback Queue，一旦 Call Stack 里代码执行完以后，就会把 Callback Queue 里第一个 callback 函数放到 Call Stack 里执行。我们来看个例子：\n\n```\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 1000);\n\nconsole.log('script end');\n\n```\n\n运行运行结果如下：\n```\nscript start\nscript end\nsetTimeout\n\n```\n\n我们具体一步一步看下整个流程：\n\n1，代码没有运行之前，`Call Stack` `Callback Queue`都是空的\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop03.png)\n\n2，把`console.log('script start')`加到 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop04.png)\n\n3，执行`console.log('script start')`，在 console 里打印出`script start`，执行结束后把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop05.png)\n\n4，把 setTimeout 放到 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop06.png)\n\n5, 执行 setTimeout，用 setTimout 线程执行 timeout 时间，Call Stack 中 setTimeout 执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop07.png)\n\n6, 把`console.log('script end')`加到 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop08.png)\n\n7，执行`console.log('script end')`，在 console 里打印出`script end`\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop09.png)\n\n8，`console.log('script end')`执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop10.png)\n\n9，1000 毫秒以后，计时结束，把 callback`cb1`函数放到 Callback Queue 里\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop11.png)\n\n10，此时 Callback Stack 是空的，Event Loop 把 cb1 拿到 Callback Stack 里\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop12.png)\n\n11，执行 cb1，cb1 里有`console.log('setTimeout')`，把`console.log('setTimeout')`放到 Call Stack 里\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop13.png)\n\n12，执行`console.log('setTimeout')`，在 console 里打印出`setTimeout`，`console.log('setTimeout')`执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop14.png)\n\n13，`cb1`执行结束，把它移出 Call Stack\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop15.png)\n\n总结来说就是，JS 是单线程的，只有一个 Call Stack，浏览器是多线程的，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都是有单独的线程处理。在这些异步事件结束，runtime 会把它们的 callback 按顺序放到 Callback Queue 里，Event Loop 会检测 Call Stack，一旦它为空，就会把 Callback Queue 里的回调函数依次放到 Call Stack 里执行，直到 Callback Queue 为空。\n\n## microtasks 和 macrotask 的执行顺序\n\n刚才用 setTimeout 为例，解释了 JS 中 Event Loop 机制是怎么运行的，也提到过 runtime 会把回调函数依次按时间先后顺序放到 Callback Queue 里，然后 Event Loop 再依次把这些回调函数放到 Call Stack 里运行。我们在浏览器 Console 运行以下代码，看下结果：\n\n```\nconsole.log('script start');\n\nsetTimeout(function () {\n    console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function () {\n    console.log('promise1');\n}).then(function () {\n    console.log('promise2');\n});\n\nconsole.log('script end');\n\n```\n\n执行结果如下：\n\n```\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n\n```\n\n上述代码虽然 setTimeout 延时为 0，其实还是异步的。因为 H5 标准规定 setTimeout 函数的第二个参数不能小于 4 毫秒，不足会自动增加。\n\nsetTimeout 和 promise 都是异步事件，而且 setTimeout 写在 promise 之前，为什么 setTimeout 的回调要比 promise 后执行呢？那是因为 promise 属于微任务（microtasks）而 setTimeout 属于宏任务（macrotask），微任务（microtasks）的优先级要高于宏任务（macrotask）。\n\n首先我们需要明白以下几件事情：\n\n*   JS 分为同步任务和异步任务\n*   同步任务都在主线程上执行，形成一个执行栈\n*   主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。\n*   一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。\n\n根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列 (task queue)，一个任务队列便是一系列有序任务 (task) 的集合；每个任务都有一个任务源 (task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop16.png)\n\nCallback Queue（Task Queue）里的回调事件称为宏任务（macrotask），每次异步事件结束后，它们的回调函数会依次按时间顺序放在 Callback Queue 里，等待 Event Loop 依次把它们放到 Call Stack 里执行。比如：`setInterval` `setTimeout` `script` `setImmediate` `I/O` `UI rendering`就是宏任务（macrotask）。\n\n微任务（microtasks）是指异步事件结束后，回调函数不会放到 Callback Queue，而是放到一个微任务队列里（Microtasks Queue），在 Call Stack 为空时，Event Loop 会先查看微任务队列里是否有任务，如果有就会先执行微任务队列里的回调事件；如果没有微任务，才会到 Callback Queue 执行回到事件。比如：`promise` `process.netTick` `Object.observe` `MutationObserver`就是微任务（microtasks）。\n\n在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。\n\n整个 Event Loop 的执行顺序如下：\n\n*   执行一个宏任务（栈中没有就从事件队列中获取）\n*   执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n*   宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n*   当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染\n*   渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取，也就是 callbacke queue）\n\n流程图如下：\n\n![](https://limeii.github.io/assets/images/posts/js/js-eventloop17.jpg)\n\n我们再把代码改一下，在创建 promise 的时候，加一行`console.log('Promise')`，而且在第一个 promise resolve 的时候再加一个 setTimeout，代码如下：\n\n```\nconsole.log('script start');\n\nsetTimeout(function () {\n    console.log('setTimeout');\n}, 0);\n\nnew Promise(resolve => {\n    console.log('Promise');\n    resolve();\n}).then(function () {\n    setTimeout(function () {\n        console.log('setTimeout in promise1');\n    }, 0);\n    console.log('promise1');\n}).then(function () {\n    console.log('promise2');\n});\n\nconsole.log('script end');\n\n/**\nscript start\nPromise\nscript end\npromise1\npromise2\nsetTimeout\nsetTimeout in promise1\n**/\n\n```\n\n`console.log('Promise')`在这里是同步代码，`console.log('script end')`是同步代码且放在最后，所以`Promise`在`script end`前面，而且在微任务（microtasks）里有宏任务（macrotask），macrotask 还是会依次被放到 Callback Queue 等待执行。\n\n如果有 async await 呢？再来看一段代码：\n\n```\n//请写出输出内容\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\nasync function async2() {\n\tconsole.log('async2');\n}\n\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\n\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n});\nconsole.log('script end');\n\n/**\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n**/\n\n```\n\n我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async/await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？\n\n由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tawait async2();\n\tconsole.log('async1 end');\n}\n\n```\n\n等价于：\n\n```\nasync function async1() {\n\tconsole.log('async1 start');\n\tPromise.resolve(async2()).then(() => {\n                console.log('async1 end');\n        })\n}\n\n```\n\n我们来看一个变式，将 async2 中的函数也变成了 Promise 函数：\n\n```\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\nasync function async2() {\n    //async2 做出如下更改：\n    new Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n    });\n}\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise3');\n    resolve();\n}).then(function() {\n    console.log('promise4');\n});\n\nconsole.log('script end');\n\n/**\nscript start\nasync1 start\npromise1\npromise3\nscript end\npromise2\nasync1 end\npromise4\nsetTimeout\n**/\n\n```\n\n我们再来看一个变式，将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下：\n\n```\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    //更改如下：\n    setTimeout(function() {\n        console.log('setTimeout1')\n    },0)\n}\nasync function async2() {\n    //更改如下：\n\tsetTimeout(function() {\n\t\tconsole.log('setTimeout2')\n\t},0)\n}\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout3');\n}, 0)\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n});\nconsole.log('script end');\n\n/**\nscript start\nasync1 start\npromise1\nscript end\npromise2\nsetTimeout3\nsetTimeout2\nsetTimeout1\n**/\n\n```\n\n我们再来看一个变式，代码如下：\n\n```\nasync function a1 () {\n    console.log('a1 start')\n    await a2()\n    console.log('a1 end')\n}\nasync function a2 () {\n    console.log('a2')\n}\n\nconsole.log('script start')\n\nsetTimeout(() => {\n    console.log('setTimeout')\n}, 0)\n\nPromise.resolve().then(() => {\n    console.log('promise1')\n})\n\na1()\n\nlet promise2 = new Promise((resolve) => {\n    resolve('promise2.then')\n    console.log('promise2')\n})\n\npromise2.then((res) => {\n    console.log(res)\n    Promise.resolve().then(() => {\n        console.log('promise3')\n    })\n})\nconsole.log('script end')\n\n/**\nscript start\na1 start\na2\npromise2\nscript end\npromise1\na1 end\npromise2.then\npromise3\nsetTimeout\n**/\n\n```\n\n参考资料：\n\n*   [“Event loops”, section in HTML5 spec.](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)\n*   [“Help, I’m stuck in an event-loop” by Philip Roberts (video).](https://vimeo.com/96425312)","slug":"ReprintJSEventLoop","published":1,"updated":"2023-03-02T12:38:35.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92yche00157gh83d8zfmkw","content":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://limeii.github.io/2019/05/js-eventloop/\" >https://limeii.github.io/2019/05/js-eventloop/ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<p>在这篇文章中会介绍以下内容：</p>\n<ul>\n<li><p>engine runtime 和 call stack 简介（以 V8 引擎为例）</p>\n</li>\n<li><p>Event Loop 运行机制的详解</p>\n</li>\n<li><p>microtasks 和 macrotask 的执行顺序</p>\n</li>\n</ul>\n<h2 id=\"engine-runtime-和-call-stack-简介\"><a href=\"#engine-runtime-和-call-stack-简介\" class=\"headerlink\" title=\"engine runtime 和 call stack 简介\"></a>engine runtime 和 call stack 简介</h2><p>在 chrome 浏览器和 nodejs 里都是用 V8 引擎解析和运行 JS 代码，我们先来看下 V8 引擎的简化图：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop01.png\"\n                     \n                ></p>\n<p>上图中 Heap 是用来做内存分配，<code>Call Stack</code>是用来执行 JS 代码，由于 JS 是单线程所以只有一个<code>Call Stack</code>。实际我们写网页开发的时候，除了一些 JS 代码，我们还会大量用到：DOM 事件、AJAX(XMLHttpRequest)、setTimeout 等等一些异步事件。从上图可以看出，这些异步事件都没有在 V8 引擎里，事实上这些异步事件不属于 V8 引擎，而是属于浏览器，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都分别有单独的线程来处理。由于<code>Call Stack</code>执行（JS 运行线程）和页面渲染线程是互斥的，如果所有的事情都由 V8 引擎处理，这样肯定会导致页面卡顿。</p>\n<p>浏览器多线程和 callback 机制完美避免了页面卡顿的问题。DOM 事件、AJAX(XMLHttpRequest)、setTimeout 这些异步事件在各自单独的线程处理完以后，每个异步事件都有 callback 回调函数，V8 引擎再把这些回调函数放在<code>Call Stack</code>执行。上述整个运行机制可以称为是 runtime，可以简化如下图：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop02.png\"\n                     \n                ></p>\n<p>如上图所示，web 异步事件结束以后，会有 callback，然后 runtime 把这些 callback 事件放到<code>Callback Queue</code>里，一旦<code>Call Stack</code>所有的方法都执行完以后，<code>Event Loop</code>会依次把 <code>Callback Queue</code>里的回调函数放到<code>Call Stack</code>里执行。</p>\n<h2 id=\"Event-Loop-运行机制的详解\"><a href=\"#Event-Loop-运行机制的详解\" class=\"headerlink\" title=\"Event Loop 运行机制的详解\"></a>Event Loop 运行机制的详解</h2><p>Event Loop 实际上就是一个 job，用来检测 Call Stack 和 Callback Queue，一旦 Call Stack 里代码执行完以后，就会把 Callback Queue 里第一个 callback 函数放到 Call Stack 里执行。我们来看个例子：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">  console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 1000);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>运行运行结果如下：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>我们具体一步一步看下整个流程：</p>\n<p>1，代码没有运行之前，<code>Call Stack</code> <code>Callback Queue</code>都是空的</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop03.png\"\n                     \n                ></p>\n<p>2，把<code>console.log(&#39;script start&#39;)</code>加到 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop04.png\"\n                     \n                ></p>\n<p>3，执行<code>console.log(&#39;script start&#39;)</code>，在 console 里打印出<code>script start</code>，执行结束后把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop05.png\"\n                     \n                ></p>\n<p>4，把 setTimeout 放到 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop06.png\"\n                     \n                ></p>\n<p>5, 执行 setTimeout，用 setTimout 线程执行 timeout 时间，Call Stack 中 setTimeout 执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop07.png\"\n                     \n                ></p>\n<p>6, 把<code>console.log(&#39;script end&#39;)</code>加到 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop08.png\"\n                     \n                ></p>\n<p>7，执行<code>console.log(&#39;script end&#39;)</code>，在 console 里打印出<code>script end</code></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop09.png\"\n                     \n                ></p>\n<p>8，<code>console.log(&#39;script end&#39;)</code>执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop10.png\"\n                     \n                ></p>\n<p>9，1000 毫秒以后，计时结束，把 callback<code>cb1</code>函数放到 Callback Queue 里</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop11.png\"\n                     \n                ></p>\n<p>10，此时 Callback Stack 是空的，Event Loop 把 cb1 拿到 Callback Stack 里</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop12.png\"\n                     \n                ></p>\n<p>11，执行 cb1，cb1 里有<code>console.log(&#39;setTimeout&#39;)</code>，把<code>console.log(&#39;setTimeout&#39;)</code>放到 Call Stack 里</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop13.png\"\n                     \n                ></p>\n<p>12，执行<code>console.log(&#39;setTimeout&#39;)</code>，在 console 里打印出<code>setTimeout</code>，<code>console.log(&#39;setTimeout&#39;)</code>执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop14.png\"\n                     \n                ></p>\n<p>13，<code>cb1</code>执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop15.png\"\n                     \n                ></p>\n<p>总结来说就是，JS 是单线程的，只有一个 Call Stack，浏览器是多线程的，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都是有单独的线程处理。在这些异步事件结束，runtime 会把它们的 callback 按顺序放到 Callback Queue 里，Event Loop 会检测 Call Stack，一旦它为空，就会把 Callback Queue 里的回调函数依次放到 Call Stack 里执行，直到 Callback Queue 为空。</p>\n<h2 id=\"microtasks-和-macrotask-的执行顺序\"><a href=\"#microtasks-和-macrotask-的执行顺序\" class=\"headerlink\" title=\"microtasks 和 macrotask 的执行顺序\"></a>microtasks 和 macrotask 的执行顺序</h2><p>刚才用 setTimeout 为例，解释了 JS 中 Event Loop 机制是怎么运行的，也提到过 runtime 会把回调函数依次按时间先后顺序放到 Callback Queue 里，然后 Event Loop 再依次把这些回调函数放到 Call Stack 里运行。我们在浏览器 Console 运行以下代码，看下结果：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>执行结果如下：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>上述代码虽然 setTimeout 延时为 0，其实还是异步的。因为 H5 标准规定 setTimeout 函数的第二个参数不能小于 4 毫秒，不足会自动增加。</p>\n<p>setTimeout 和 promise 都是异步事件，而且 setTimeout 写在 promise 之前，为什么 setTimeout 的回调要比 promise 后执行呢？那是因为 promise 属于微任务（microtasks）而 setTimeout 属于宏任务（macrotask），微任务（microtasks）的优先级要高于宏任务（macrotask）。</p>\n<p>首先我们需要明白以下几件事情：</p>\n<ul>\n<li>JS 分为同步任务和异步任务</li>\n<li>同步任务都在主线程上执行，形成一个执行栈</li>\n<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>\n<li>一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li>\n</ul>\n<p>根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列 (task queue)，一个任务队列便是一系列有序任务 (task) 的集合；每个任务都有一个任务源 (task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout&#x2F;Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop16.png\"\n                     \n                ></p>\n<p>Callback Queue（Task Queue）里的回调事件称为宏任务（macrotask），每次异步事件结束后，它们的回调函数会依次按时间顺序放在 Callback Queue 里，等待 Event Loop 依次把它们放到 Call Stack 里执行。比如：<code>setInterval</code> <code>setTimeout</code> <code>script</code> <code>setImmediate</code> <code>I/O</code> <code>UI rendering</code>就是宏任务（macrotask）。</p>\n<p>微任务（microtasks）是指异步事件结束后，回调函数不会放到 Callback Queue，而是放到一个微任务队列里（Microtasks Queue），在 Call Stack 为空时，Event Loop 会先查看微任务队列里是否有任务，如果有就会先执行微任务队列里的回调事件；如果没有微任务，才会到 Callback Queue 执行回到事件。比如：<code>promise</code> <code>process.netTick</code> <code>Object.observe</code> <code>MutationObserver</code>就是微任务（microtasks）。</p>\n<p>在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p>\n<p>整个 Event Loop 的执行顺序如下：</p>\n<ul>\n<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>\n<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li>\n<li>渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取，也就是 callbacke queue）</li>\n</ul>\n<p>流程图如下：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop17.jpg\"\n                     \n                ></p>\n<p>我们再把代码改一下，在创建 promise 的时候，加一行<code>console.log(&#39;Promise&#39;)</code>，而且在第一个 promise resolve 的时候再加一个 setTimeout，代码如下：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;Promise&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        console.log(&#x27;setTimeout in promise1&#x27;);</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">Promise</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">setTimeout in promise1</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p><code>console.log(&#39;Promise&#39;)</code>在这里是同步代码，<code>console.log(&#39;script end&#39;)</code>是同步代码且放在最后，所以<code>Promise</code>在<code>script end</code>前面，而且在微任务（microtasks）里有宏任务（macrotask），macrotask 还是会依次被放到 Callback Queue 等待执行。</p>\n<p>如果有 async await 呢？再来看一段代码：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//请写出输出内容</span><br><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    console.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;async2&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">async1 start</span><br><span class=\"line\">async2</span><br><span class=\"line\">promise1</span><br><span class=\"line\">script end</span><br><span class=\"line\">async1 end</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async&#x2F;await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？</p>\n<p>由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">\tawait async2();</span><br><span class=\"line\">\tconsole.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>等价于：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">\tPromise.resolve(async2()).then(() =&gt; &#123;</span><br><span class=\"line\">                console.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>我们来看一个变式，将 async2 中的函数也变成了 Promise 函数：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    console.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    //async2 做出如下更改：</span><br><span class=\"line\">    new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise3&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise4&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">async1 start</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise3</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise2</span><br><span class=\"line\">async1 end</span><br><span class=\"line\">promise4</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>我们再来看一个变式，将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    //更改如下：</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">        console.log(&#x27;setTimeout1&#x27;)</span><br><span class=\"line\">    &#125;,0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    //更改如下：</span><br><span class=\"line\">\tsetTimeout(function() &#123;</span><br><span class=\"line\">\t\tconsole.log(&#x27;setTimeout2&#x27;)</span><br><span class=\"line\">\t&#125;,0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout3&#x27;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">async1 start</span><br><span class=\"line\">promise1</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout3</span><br><span class=\"line\">setTimeout2</span><br><span class=\"line\">setTimeout1</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>我们再来看一个变式，代码如下：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function a1 () &#123;</span><br><span class=\"line\">    console.log(&#x27;a1 start&#x27;)</span><br><span class=\"line\">    await a2()</span><br><span class=\"line\">    console.log(&#x27;a1 end&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function a2 () &#123;</span><br><span class=\"line\">    console.log(&#x27;a2&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script start&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">a1()</span><br><span class=\"line\"></span><br><span class=\"line\">let promise2 = new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">    resolve(&#x27;promise2.then&#x27;)</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise2.then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    Promise.resolve().then(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;promise3&#x27;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&#x27;script end&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">a1 start</span><br><span class=\"line\">a2</span><br><span class=\"line\">promise2</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">a1 end</span><br><span class=\"line\">promise2.then</span><br><span class=\"line\">promise3</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>参考资料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\" >“Event loops”, section in HTML5 spec. <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://vimeo.com/96425312\" >“Help, I’m stuck in an event-loop” by Philip Roberts (video). <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://limeii.github.io/2019/05/js-eventloop/\" >https://limeii.github.io/2019/05/js-eventloop/ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<p>在这篇文章中会介绍以下内容：</p>\n<ul>\n<li><p>engine runtime 和 call stack 简介（以 V8 引擎为例）</p>\n</li>\n<li><p>Event Loop 运行机制的详解</p>\n</li>\n<li><p>microtasks 和 macrotask 的执行顺序</p>\n</li>\n</ul>\n<h2 id=\"engine-runtime-和-call-stack-简介\"><a href=\"#engine-runtime-和-call-stack-简介\" class=\"headerlink\" title=\"engine runtime 和 call stack 简介\"></a>engine runtime 和 call stack 简介</h2><p>在 chrome 浏览器和 nodejs 里都是用 V8 引擎解析和运行 JS 代码，我们先来看下 V8 引擎的简化图：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop01.png\"\n                     \n                ></p>\n<p>上图中 Heap 是用来做内存分配，<code>Call Stack</code>是用来执行 JS 代码，由于 JS 是单线程所以只有一个<code>Call Stack</code>。实际我们写网页开发的时候，除了一些 JS 代码，我们还会大量用到：DOM 事件、AJAX(XMLHttpRequest)、setTimeout 等等一些异步事件。从上图可以看出，这些异步事件都没有在 V8 引擎里，事实上这些异步事件不属于 V8 引擎，而是属于浏览器，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都分别有单独的线程来处理。由于<code>Call Stack</code>执行（JS 运行线程）和页面渲染线程是互斥的，如果所有的事情都由 V8 引擎处理，这样肯定会导致页面卡顿。</p>\n<p>浏览器多线程和 callback 机制完美避免了页面卡顿的问题。DOM 事件、AJAX(XMLHttpRequest)、setTimeout 这些异步事件在各自单独的线程处理完以后，每个异步事件都有 callback 回调函数，V8 引擎再把这些回调函数放在<code>Call Stack</code>执行。上述整个运行机制可以称为是 runtime，可以简化如下图：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop02.png\"\n                     \n                ></p>\n<p>如上图所示，web 异步事件结束以后，会有 callback，然后 runtime 把这些 callback 事件放到<code>Callback Queue</code>里，一旦<code>Call Stack</code>所有的方法都执行完以后，<code>Event Loop</code>会依次把 <code>Callback Queue</code>里的回调函数放到<code>Call Stack</code>里执行。</p>\n<h2 id=\"Event-Loop-运行机制的详解\"><a href=\"#Event-Loop-运行机制的详解\" class=\"headerlink\" title=\"Event Loop 运行机制的详解\"></a>Event Loop 运行机制的详解</h2><p>Event Loop 实际上就是一个 job，用来检测 Call Stack 和 Callback Queue，一旦 Call Stack 里代码执行完以后，就会把 Callback Queue 里第一个 callback 函数放到 Call Stack 里执行。我们来看个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">  console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 1000);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>运行运行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们具体一步一步看下整个流程：</p>\n<p>1，代码没有运行之前，<code>Call Stack</code> <code>Callback Queue</code>都是空的</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop03.png\"\n                     \n                ></p>\n<p>2，把<code>console.log(&#39;script start&#39;)</code>加到 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop04.png\"\n                     \n                ></p>\n<p>3，执行<code>console.log(&#39;script start&#39;)</code>，在 console 里打印出<code>script start</code>，执行结束后把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop05.png\"\n                     \n                ></p>\n<p>4，把 setTimeout 放到 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop06.png\"\n                     \n                ></p>\n<p>5, 执行 setTimeout，用 setTimout 线程执行 timeout 时间，Call Stack 中 setTimeout 执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop07.png\"\n                     \n                ></p>\n<p>6, 把<code>console.log(&#39;script end&#39;)</code>加到 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop08.png\"\n                     \n                ></p>\n<p>7，执行<code>console.log(&#39;script end&#39;)</code>，在 console 里打印出<code>script end</code></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop09.png\"\n                     \n                ></p>\n<p>8，<code>console.log(&#39;script end&#39;)</code>执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop10.png\"\n                     \n                ></p>\n<p>9，1000 毫秒以后，计时结束，把 callback<code>cb1</code>函数放到 Callback Queue 里</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop11.png\"\n                     \n                ></p>\n<p>10，此时 Callback Stack 是空的，Event Loop 把 cb1 拿到 Callback Stack 里</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop12.png\"\n                     \n                ></p>\n<p>11，执行 cb1，cb1 里有<code>console.log(&#39;setTimeout&#39;)</code>，把<code>console.log(&#39;setTimeout&#39;)</code>放到 Call Stack 里</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop13.png\"\n                     \n                ></p>\n<p>12，执行<code>console.log(&#39;setTimeout&#39;)</code>，在 console 里打印出<code>setTimeout</code>，<code>console.log(&#39;setTimeout&#39;)</code>执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop14.png\"\n                     \n                ></p>\n<p>13，<code>cb1</code>执行结束，把它移出 Call Stack</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop15.png\"\n                     \n                ></p>\n<p>总结来说就是，JS 是单线程的，只有一个 Call Stack，浏览器是多线程的，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都是有单独的线程处理。在这些异步事件结束，runtime 会把它们的 callback 按顺序放到 Callback Queue 里，Event Loop 会检测 Call Stack，一旦它为空，就会把 Callback Queue 里的回调函数依次放到 Call Stack 里执行，直到 Callback Queue 为空。</p>\n<h2 id=\"microtasks-和-macrotask-的执行顺序\"><a href=\"#microtasks-和-macrotask-的执行顺序\" class=\"headerlink\" title=\"microtasks 和 macrotask 的执行顺序\"></a>microtasks 和 macrotask 的执行顺序</h2><p>刚才用 setTimeout 为例，解释了 JS 中 Event Loop 机制是怎么运行的，也提到过 runtime 会把回调函数依次按时间先后顺序放到 Callback Queue 里，然后 Event Loop 再依次把这些回调函数放到 Call Stack 里运行。我们在浏览器 Console 运行以下代码，看下结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上述代码虽然 setTimeout 延时为 0，其实还是异步的。因为 H5 标准规定 setTimeout 函数的第二个参数不能小于 4 毫秒，不足会自动增加。</p>\n<p>setTimeout 和 promise 都是异步事件，而且 setTimeout 写在 promise 之前，为什么 setTimeout 的回调要比 promise 后执行呢？那是因为 promise 属于微任务（microtasks）而 setTimeout 属于宏任务（macrotask），微任务（microtasks）的优先级要高于宏任务（macrotask）。</p>\n<p>首先我们需要明白以下几件事情：</p>\n<ul>\n<li>JS 分为同步任务和异步任务</li>\n<li>同步任务都在主线程上执行，形成一个执行栈</li>\n<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>\n<li>一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li>\n</ul>\n<p>根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列 (task queue)，一个任务队列便是一系列有序任务 (task) 的集合；每个任务都有一个任务源 (task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout&#x2F;Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop16.png\"\n                     \n                ></p>\n<p>Callback Queue（Task Queue）里的回调事件称为宏任务（macrotask），每次异步事件结束后，它们的回调函数会依次按时间顺序放在 Callback Queue 里，等待 Event Loop 依次把它们放到 Call Stack 里执行。比如：<code>setInterval</code> <code>setTimeout</code> <code>script</code> <code>setImmediate</code> <code>I/O</code> <code>UI rendering</code>就是宏任务（macrotask）。</p>\n<p>微任务（microtasks）是指异步事件结束后，回调函数不会放到 Callback Queue，而是放到一个微任务队列里（Microtasks Queue），在 Call Stack 为空时，Event Loop 会先查看微任务队列里是否有任务，如果有就会先执行微任务队列里的回调事件；如果没有微任务，才会到 Callback Queue 执行回到事件。比如：<code>promise</code> <code>process.netTick</code> <code>Object.observe</code> <code>MutationObserver</code>就是微任务（microtasks）。</p>\n<p>在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p>\n<p>整个 Event Loop 的执行顺序如下：</p>\n<ul>\n<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>\n<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li>\n<li>渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取，也就是 callbacke queue）</li>\n</ul>\n<p>流程图如下：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://limeii.github.io/assets/images/posts/js/js-eventloop17.jpg\"\n                     \n                ></p>\n<p>我们再把代码改一下，在创建 promise 的时候，加一行<code>console.log(&#39;Promise&#39;)</code>，而且在第一个 promise resolve 的时候再加一个 setTimeout，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;Promise&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        console.log(&#x27;setTimeout in promise1&#x27;);</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">Promise</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">setTimeout in promise1</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>console.log(&#39;Promise&#39;)</code>在这里是同步代码，<code>console.log(&#39;script end&#39;)</code>是同步代码且放在最后，所以<code>Promise</code>在<code>script end</code>前面，而且在微任务（microtasks）里有宏任务（macrotask），macrotask 还是会依次被放到 Callback Queue 等待执行。</p>\n<p>如果有 async await 呢？再来看一段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//请写出输出内容</span><br><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    console.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;async2&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">async1 start</span><br><span class=\"line\">async2</span><br><span class=\"line\">promise1</span><br><span class=\"line\">script end</span><br><span class=\"line\">async1 end</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async&#x2F;await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？</p>\n<p>由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">\tawait async2();</span><br><span class=\"line\">\tconsole.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>等价于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">\tconsole.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">\tPromise.resolve(async2()).then(() =&gt; &#123;</span><br><span class=\"line\">                console.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们来看一个变式，将 async2 中的函数也变成了 Promise 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    console.log(&#x27;async1 end&#x27;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    //async2 做出如下更改：</span><br><span class=\"line\">    new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise3&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise4&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">async1 start</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise3</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise2</span><br><span class=\"line\">async1 end</span><br><span class=\"line\">promise4</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们再来看一个变式，将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#x27;async1 start&#x27;);</span><br><span class=\"line\">    await async2();</span><br><span class=\"line\">    //更改如下：</span><br><span class=\"line\">    setTimeout(function() &#123;</span><br><span class=\"line\">        console.log(&#x27;setTimeout1&#x27;)</span><br><span class=\"line\">    &#125;,0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    //更改如下：</span><br><span class=\"line\">\tsetTimeout(function() &#123;</span><br><span class=\"line\">\t\tconsole.log(&#x27;setTimeout2&#x27;)</span><br><span class=\"line\">\t&#125;,0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout3&#x27;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&#x27;script end&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">async1 start</span><br><span class=\"line\">promise1</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout3</span><br><span class=\"line\">setTimeout2</span><br><span class=\"line\">setTimeout1</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们再来看一个变式，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function a1 () &#123;</span><br><span class=\"line\">    console.log(&#x27;a1 start&#x27;)</span><br><span class=\"line\">    await a2()</span><br><span class=\"line\">    console.log(&#x27;a1 end&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function a2 () &#123;</span><br><span class=\"line\">    console.log(&#x27;a2&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script start&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&#x27;promise1&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">a1()</span><br><span class=\"line\"></span><br><span class=\"line\">let promise2 = new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">    resolve(&#x27;promise2.then&#x27;)</span><br><span class=\"line\">    console.log(&#x27;promise2&#x27;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise2.then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    Promise.resolve().then(() =&gt; &#123;</span><br><span class=\"line\">        console.log(&#x27;promise3&#x27;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&#x27;script end&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">script start</span><br><span class=\"line\">a1 start</span><br><span class=\"line\">a2</span><br><span class=\"line\">promise2</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">a1 end</span><br><span class=\"line\">promise2.then</span><br><span class=\"line\">promise3</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\">**/</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>参考资料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\" >“Event loops”, section in HTML5 spec. <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://vimeo.com/96425312\" >“Help, I’m stuck in an event-loop” by Philip Roberts (video). <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n"},{"url":"https://zhuanlan.zhihu.com/p/408272742","title":"【转载】Vue Composition API","date":"2022-05-02T12:39:42.000Z","_content":"\n> 原文转自：https://zhuanlan.zhihu.com/p/408272742\n\n\n## 前言\n\n关注 React 的同学应该知道，React 在 19 年推出了 Hooks API，从而可以抛弃难以理解的 class 完全转向函数式组件。当然，它对开发者的意义不止于此，更为重要的是它提供了从组件中**提取状态逻辑**的能力，让我们能以业务逻辑为细粒度拆分组件，并在组件之间复用业务逻辑。\n\n后续尤大马上发布了 Vue Function-based API RFC（在之后重写成了 Composition API），并作为 Vue3 的核心特性，可想而知它的重要性。\n\n接下来让我们抛开 React，来看看 Composition API 都有哪些内容。\n\n## 一、介绍\n\n**1.1 什么是 Composition API ？**\n\nVue 3 中引入的一种新的编写 Vue 组件的方式，可以将 2.x 中与组件逻辑相关的选项以 API 函数的形式重新设计。\n\n**1.2 基本例子**\n\n![](https://pic2.zhimg.com/v2-3215832798dad4d85252c140e509f445_r.jpg)\n\n我们使用 Composition API 对左侧进行重构，其实就是将组件选项抽离到了 `setup` 函数当中进行编排，并在最后把模板用到的变量返回，最后的结果和将变量定义在 `data` 或者 `methods` 中没有什么区别。\n\n当然，setup 和 2.x 的选项一起混用也是没有问题的，并且依旧可以通过 `this.xx` 访问到 `setup` 返回的变量。\n\n❓ 如果只是把代码迁移到 `setup` 函数中，变成一长条的面条式代码，有什么意义呢\n\n**1.3 更进一步的例子**\n\n![](https://pic3.zhimg.com/v2-7889c66d30a72bf92842103cf92ed84e_r.jpg)\n\n这一次我们将 `setup` 中的代码进一步抽离，拆出了 `useMouse` 组合函数，里面封装了对鼠标位置的监听逻辑。`useMouse` 只需要将要暴露给组件的状态（`x`、`y`）以响应式的数据源的方式返回出来，就可以在我们的组件代码中使用。\n\n对于 Component 来说，里面没有任何监听鼠标位置的逻辑代码，只需要调用 `useMouse` 拿到 `x`、`y` 即可。\n\n❓ 这些我用 Mixins 也能实现呀\n\n**1.4 更更进一步的例子**\n\n![](https://pic4.zhimg.com/v2-7e01ef06f0e5e71970a6f98dcc5a610f_r.jpg)\n\n首先我们通过模板来理解 `useDark` 的工作内容，就是返回了一个表示是否是黑夜模式的布尔值，并且可以通过 `useToggle` 来快速得到一个 toggle 函数。\n\n然后观察 `useDark`，我们可以看到它身为一个组合函数的同时，又调用了其他的组合函数 `usePreferredDark` 和 `useLocalStorage` 来获取系统主题色和本地配置色。当然，我们不需要太关心它们的具体实现，只需要专注于处理结果，并返回以本地配置色为优先的结果即可。\n\n其中的组合函数调用关系如下图所示：\n\n![](https://pic3.zhimg.com/v2-1f58c63c4fccaffaa58660947892808a_r.jpg)\n\n组合函数的底层又依赖了其他组合函数，比如 `useLocalStorage` 依赖统一封装了 SessionStorage 和 LocalStorage 逻辑的 `useStorage`，`usePreferredDark` 依赖封装了 `window.matchMedia` 逻辑的 `useMediaQuery`。它们最后又都通过 `useEventListener` 来做状态改变的响应，并且能自动卸载。\n\n涉及的每一个函数都能独立使用，并且有自己的职责，最后进行组合。\n\n这个例子来源于 [VueUse](https://link.zhihu.com/?target=https%3A//github.com/vueuse/vueuse).\n\n当然，我们不可能总是写到这么通用的代码，但是在业务中也可以使用 Composition API 来对业务逻辑进行拆分，让每一个组合函数负责独立的业务，比如埋点上报、RichTextPanel 组件参数与回调、页面控件逻辑等。这些组件内的状态、方法现在我们可以将它提取到组合函数中，可以是为了复用，也可以仅仅是为了让 .vue 文件看起来更干净。\n\n## 二、API\n\n**2.1 setup**\n\n`setup` 是组合式 API 的入口点，它的执行时机在 `beforeCreate` 和 `created`，并且只会执行一次。\n\n所以我们不需要 `onBeforeCreate` 和 `onCreated`，这些钩子对应的代码应该直接在 `setup` 函数中编写。\n\n它接收两个参数：\n\n1.  响应式的 `props`\n2.  非响应式的 `context`，包含：attrs、slots、emit\n\n它执行的时候组件实例尚未被创建，所以我们无法访问 data、computed、methods 这些组件选项。\n\n如果它返回一个对象，那么对象的 property 就可以在选项或者模板中访问到。\n\n**2.1.1 返回渲染函数**\n\n![](https://pic1.zhimg.com/v2-ed3d1aa04bf9bf33e9878a0d935fb074_r.jpg)\n\n在 Babel Plugin 支持下可以返回 JSX：[feat: add @vue/composition-api support #142](https://link.zhihu.com/?target=https%3A//github.com/vuejs/jsx/pull/142)\n\n**2.1.2 getCurrentInstance**\n\n如果确实需要访问组件实例，可以使用 `getCurrentInstance()`。\n\n只能在 `setup`、生命周期钩子和组合函数中使用。\n\n![](https://pic4.zhimg.com/v2-2219ce295be181f25efcf766f103d15b_r.jpg)\n\n**2.2 reactive**\n\n返回对象的响应式副本，相当于 `Vue.observable(obj)` 。\n\n该响应式转换是 “深度转换”——它会影响嵌套对象传递的所有 property。\n\n怎么理解这里的响应式呢？就是我们在渲染期间使用响应式对象，当值改变的时候视图会自动更新，就和修改挂在 data 对象里的值一样。\n\n**2.2.1 无法代理原始值类型**\n\nreactive() 函数可以代理一个对象，但不能代理基本类型值，这是因为原始值类型只有值而没有引用，无法追踪变量的后续变化。\n\n**2.2.2 响应丢失**\n\n![](https://pic2.zhimg.com/v2-bde37e9bd232fafb93168b55251367b9_r.jpg)\n\n**2.3 ref**\n\n接收一个值，返回的响应式且可变的包装对象。\n\n它只有一个属性：`.value` ，该属性指向内部被包装的值。这个值可以直接修改。\n\n我们没法用 reactive 处理原始值类型，但是我们可以创建一个对象将原始值挂在它的同名 property 下，再传递给 reactive。Vue 提供了 ref 来替我们做这件事。\n\n![](https://pic1.zhimg.com/v2-19e7df03e22381ebc37428bf17a8e594_r.jpg)\n\n**2.3.1 自动解包（不需要加 .value 的情况）**\n\n1.  ref 在模板中会自动解包\n\n2.`watch` 可以直接接受 ref 作为监听对象，在回调函数中会直接返回解包后的值。\n\n![](https://pic2.zhimg.com/v2-61b795e0a933eaba882ebe38e65d3acd_r.jpg)\n\n3. 使用 reactive() / readonly() 解包对象嵌套的 ref\n\n![](https://pic3.zhimg.com/v2-6b5120ec665ba0e9330220c967ac023a_r.jpg)\n\n但是从 `Array` 或原生集合类型如 `Map`访问 ref 时，不会进行解包。\n\n**2.3.2 unref（ref 的反向操作）**\n\n传入一个 ref，返回 `ref.value`，否则原样返回。\n\n纠结是否需要加 `.value`（比如某个函数参数的类型是 `Ref<number> | number`）来取值，可以使用 unref 来解包。\n\n![](https://pic1.zhimg.com/v2-be644447a3adfae139ccb07863b4fe30_r.jpg)\n\n**2.3.3 重复使用已有 ref**\n\n将一个 ref 传递给 `ref()` 构造函数，它会原样返回。\n\n如果你的函数需要返回一个 ref，但是不确定参数的类型，可以直接 `return ref(param)`，如果是 ref 则会复用，不是则返回一个新的 ref。\n\n**2.3.4 可以使用 ES6 解构语法**\n\n解构一个值是 ref 的对象不会丢失响应式。\n\n![](https://pic3.zhimg.com/v2-fb83022e342cde7e017a54e710b8d6b6_r.jpg)\n\n**2.3.5 this.$refs 的解决方案**\n\n在虚拟 DOM 补丁算法中，如果 VNode 的 `ref` 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。\n\n由于是在虚拟 DOM 挂载 / 打补丁过程中执行的，因此 ref 只会在初始渲染之后才获得赋值。\n\n![](https://pic4.zhimg.com/v2-c08e93238d9074b4e78284dcca4b94cb_r.jpg)\n\n**2.4 toRefs**\n\n将响应式对象转换为普通对象，并对每个 property 对应的 value 转换成 ref。\n\n可以用来解决 `reactive` 或者 `props` 在解构的时候丢失响应式的问题。\n\n![](https://pic1.zhimg.com/v2-e1550002c1ead321c4dde992c78f944c_r.jpg)\n\n**2.5 computed**\n\n接收 getter 函数，返回一个**只读**的响应式 ref 对象。\n\n![](https://pic1.zhimg.com/v2-b2e6f76a4f4265e182212f3dff7b8ab4_r.jpg)\n\n如果参数是具有 get 和 set 函数的对象，返回的结果会是一个**可写**的响应式 ref 对象。\n\n![](https://pic4.zhimg.com/v2-c7dadc1902029f1fa98537e6c13744d3_r.jpg)\n\n**2.6 watch**\n\n第一个参数接收数据源，可以是：\n\n*   getter 函数、ref\n*   包含上述两种类型的数组（也就是可以 watch 多个源，其中任一个变化都会触发回调）\n\n第二个参数是回调函数，在数据源变动的时候触发。\n\n![](https://pic3.zhimg.com/v2-b0556885105bd72c7b0b6ea131af826a_r.jpg)\n\n**2.6.1 停止观察**\n\n`watch()` 返回一个停止观察的函数：\n\n![](https://pic1.zhimg.com/v2-75541dc512f2994a4ac1719df0e23a64_r.jpg)\n\n如果 `watch()` 是在一个组件的 `setup()` 或是生命周期函数中被调用的，那么该 watcher 会在当前组件被销毁时也一同被自动停\n\n**2.6.2 清理 effect**\n\nwatcher 的回调会接收到的第三个参数是一个用来注册清理操作的函数。\n\n有时候当观察的数据源变化后，我们可能需要对之前所执行的副作用进行清理。举例来说，一个异步操作在完成之前数据就产生了变化，我们可能要撤销还在等待的前一个操作。\n\n调用这个函数可以注册一个清理函数，执行时机在：\n\n*   回调被下一次调用前\n*   watcher 被停止前\n\n![](https://pic4.zhimg.com/v2-f81961ecde2ab5d1edecc76cb51940b3_r.jpg)\n\n## 三、设计动机\n\n**3.1 从 Class API 到 Function API 再到 Composition API**\n\n我们可以在 Vue RFC 中看到最初的 [Class API](https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/17) 到 [Function-based Component API](https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/42) 取其 FP 的精华，再到被修订为 [Composition API](https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/78) 采用 Reactivity 的过程。\n\n**3.2 解决了什么问题**\n\n对比 2.x 对象式 API：\n\n*   极易复用。\n\n*   状态可以从组件中拆出来放到组合函数中。\n\n*   更清楚的逻辑。\n\n*   代码可以按功能 / 逻辑组织，而不是分散在各个选项中。\n\n*   更好的 TypeScript 类型支持。\n\n*   基于 Class 的 API 存在 TS 类型问题，而基于函数的 API 天然对类型推导很友好，因为 TS 对函数的参数、返回值和泛型的支持已经非常完备。\n\n*   更小的打包体积。\n\n*   基于函数的 API 每一个函数都可以作为 named ES export 被单独引入，这使得它们对 tree-shaking 非常友好。没有被使用的 API 的相关代码可以在最终打包时被移除。\n*   同时，基于函数 API 所写的代码也有更好的压缩效率，因为所有的函数名和 setup 函数体内部的变量名都可以被压缩，但对象和 class 的属性 / 方法名却不可以。\n\n**3.3 对比 2.x 的复用模式**\n\nVue 2.x 目前的 API 我们有一些常见的逻辑复用模式，包括：\n\n*   Mixins\n*   高阶组件 (Higher-order Components, aka HOCs)\n*   Renderless Components （基于 scoped slots / 作用域插槽封装逻辑的组件）\n\n总体来说，以上这些模式存在以下问题：\n\n*   模版中的数据来源不清晰。\n\n*   举例来说，当一个组件中使用了多个 mixin 的时候，光看模版会很难分清一个属性到底是来自哪一个 mixin。HOC 也有类似的问题。\n\n*   使用 Composition API 只需要观察 setup 函数就可以知道数据的来源。\n*   命名空间冲突。\n\n*   由不同开发者开发的 mixin 无法保证不会正好用到一样的属性或是方法名。HOC 在注入的 props 中也存在类似问题。\n\n*   组合函数在使用和返回给渲染层的两个阶段都可以做重命名的操作。\n*   性能。\n\n*   HOC 和 Renderless Components 都需要额外的组件实例嵌套来封装逻辑，导致无谓的性能开销。\n\n*   组合函数没有创建额外的组件实例所带来的性能损耗。\n\n**3.4 对比 React Hooks**\n\nComposition API 虽然借鉴了 React Hooks，两者具有同等的基于函数抽取和复用逻辑的能力，但是出于框架的性质两者在实现上是天差地别的。\n\nReact Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。而 Vue 的 `setup()` 每个组件实例只会在初始化时调用一次 ，状态通过引用储存在 `setup()` 的闭包内。\n\n也就是说，Composition API 相比 React Hooks：\n\n*   整体上更符合 JavaScript 的直觉；\n\n*   Mutable 写法。\n\n*   不受调用顺序的限制，可以有条件地被调用；\n\n*   Hooks 需要使用下标来获取对应的 state。\n\n*   不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；\n\n*   Hooks 的每次渲染都是单独的闭包。\n\n*   不需要总是使用 `useCallback` 来缓存传给子组件的回调以防止过度更新；\n\n*   如果给子组件传了函数，每次渲染都会被当作新 props。\n\n*   不需要担心传了错误的依赖数组给 `useEffect/useMemo/useCallback` 从而导致回调中使用了过期的值。\n\n*   Vue 的依赖收集是全自动的，可以做到最小粒度的更新。\n\n这都是基于 Vue 的响应式更新能力。\n\n有兴趣的同学可以通过下面的链接了解 React Hooks 的心智模型有多么沉重：\n\n[Hooks FAQ](https://link.zhihu.com/?target=https%3A//zh-hans.reactjs.org/docs/hooks-faq.html%23from-classes-to-hooks)\n\n[使用 React Hooks 声明 setInterval](https://link.zhihu.com/?target=https%3A//overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/)\n\n[useEffect 完整指南](https://link.zhihu.com/?target=https%3A//overreacted.io/zh-hans/a-complete-guide-to-useeffect/)\n\n**3.5 那么它有缺点吗？**\n\n**3.5.1 ref 和 reactive 的区别**\n\n<table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>ref</th><th>reactive</th></tr><tr><td>可以处理原始值，也可以处理对象</td><td>只能处理对象</td></tr><tr><td>需要加 .value，需要考虑自动解包</td><td>不需要加 .value</td></tr><tr><td>有单独的类型</td><td>和普通的对象没有什么区别，无法直接通过类型判断是否是响应式</td></tr><tr><td>可以使用解构赋值</td><td>不可以使用解构赋值，会丢失响应式</td></tr><tr><td></td><td>需要使用箭头函数包装才能使用 watch</td></tr></tbody></table>\n\n**3.5.2 考虑响应式和 .value**\n\n虽然写 Composition API 不会有 `useEffect` 的困扰，还能使用完全一致的生命周期钩子函数，但是此次 Vue 把响应式 API 暴露给我们，实际上在编写代码的时候，需要考虑是否是响应式、是否是 ref 和响应式丢失的问题，也会带来一定的心智负担。\n\n## 总结\n\n**面向生命周期编程 vs 面向业务逻辑编程**  \nComposition API 带来了组件逻辑抽取和复用的优化，抽取逻辑会变得非常简单，所以我们不必只在需要复用逻辑的时候才抽取函数，也可以单纯为了更好地组织代码去抽取函数，以此避免每个逻辑任务的代码都被选项切成了多个碎片分散在各处。  \n当然如果组件足够简单，我们还是可以只使用 Options API，以原来的习惯写代码。**我可以在 Vue 2 中使用吗？**  \n可以的，官方团队提供了可供 Vue 2 使用的插件： [@vue/composition-api](https://link.zhihu.com/?target=https%3A//github.com/vuejs/composition-api)。  \n另外他们也计划让 Composition API 在 Vue 2.7 原生支持。\n\n## 参考\n\n[官方文档](https://link.zhihu.com/?target=https%3A//v3.cn.vuejs.org/guide/composition-api-introduction.html%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E7%25BB%2584%25E5%2590%2588%25E5%25BC%258F-api)\n\n[Vue Function-based API RFC](https://zhuanlan.zhihu.com/p/68477600)\n\n[VueUse 作者 Anthony Fu 分享可组合的 Vue](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1x54y1V7H6/)\n\n[深入理解 Vue3 Reactivity API](https://zhuanlan.zhihu.com/p/146097763)","source":"_posts/ReprintVueCompositionAPI.md","raw":"---\nurl: https://zhuanlan.zhihu.com/p/408272742\ntitle: 【转载】Vue Composition API\ndate: 2022-05-02 20:39:42\ntags: [JS]\ncategories: [转载]\n---\n\n> 原文转自：https://zhuanlan.zhihu.com/p/408272742\n\n\n## 前言\n\n关注 React 的同学应该知道，React 在 19 年推出了 Hooks API，从而可以抛弃难以理解的 class 完全转向函数式组件。当然，它对开发者的意义不止于此，更为重要的是它提供了从组件中**提取状态逻辑**的能力，让我们能以业务逻辑为细粒度拆分组件，并在组件之间复用业务逻辑。\n\n后续尤大马上发布了 Vue Function-based API RFC（在之后重写成了 Composition API），并作为 Vue3 的核心特性，可想而知它的重要性。\n\n接下来让我们抛开 React，来看看 Composition API 都有哪些内容。\n\n## 一、介绍\n\n**1.1 什么是 Composition API ？**\n\nVue 3 中引入的一种新的编写 Vue 组件的方式，可以将 2.x 中与组件逻辑相关的选项以 API 函数的形式重新设计。\n\n**1.2 基本例子**\n\n![](https://pic2.zhimg.com/v2-3215832798dad4d85252c140e509f445_r.jpg)\n\n我们使用 Composition API 对左侧进行重构，其实就是将组件选项抽离到了 `setup` 函数当中进行编排，并在最后把模板用到的变量返回，最后的结果和将变量定义在 `data` 或者 `methods` 中没有什么区别。\n\n当然，setup 和 2.x 的选项一起混用也是没有问题的，并且依旧可以通过 `this.xx` 访问到 `setup` 返回的变量。\n\n❓ 如果只是把代码迁移到 `setup` 函数中，变成一长条的面条式代码，有什么意义呢\n\n**1.3 更进一步的例子**\n\n![](https://pic3.zhimg.com/v2-7889c66d30a72bf92842103cf92ed84e_r.jpg)\n\n这一次我们将 `setup` 中的代码进一步抽离，拆出了 `useMouse` 组合函数，里面封装了对鼠标位置的监听逻辑。`useMouse` 只需要将要暴露给组件的状态（`x`、`y`）以响应式的数据源的方式返回出来，就可以在我们的组件代码中使用。\n\n对于 Component 来说，里面没有任何监听鼠标位置的逻辑代码，只需要调用 `useMouse` 拿到 `x`、`y` 即可。\n\n❓ 这些我用 Mixins 也能实现呀\n\n**1.4 更更进一步的例子**\n\n![](https://pic4.zhimg.com/v2-7e01ef06f0e5e71970a6f98dcc5a610f_r.jpg)\n\n首先我们通过模板来理解 `useDark` 的工作内容，就是返回了一个表示是否是黑夜模式的布尔值，并且可以通过 `useToggle` 来快速得到一个 toggle 函数。\n\n然后观察 `useDark`，我们可以看到它身为一个组合函数的同时，又调用了其他的组合函数 `usePreferredDark` 和 `useLocalStorage` 来获取系统主题色和本地配置色。当然，我们不需要太关心它们的具体实现，只需要专注于处理结果，并返回以本地配置色为优先的结果即可。\n\n其中的组合函数调用关系如下图所示：\n\n![](https://pic3.zhimg.com/v2-1f58c63c4fccaffaa58660947892808a_r.jpg)\n\n组合函数的底层又依赖了其他组合函数，比如 `useLocalStorage` 依赖统一封装了 SessionStorage 和 LocalStorage 逻辑的 `useStorage`，`usePreferredDark` 依赖封装了 `window.matchMedia` 逻辑的 `useMediaQuery`。它们最后又都通过 `useEventListener` 来做状态改变的响应，并且能自动卸载。\n\n涉及的每一个函数都能独立使用，并且有自己的职责，最后进行组合。\n\n这个例子来源于 [VueUse](https://link.zhihu.com/?target=https%3A//github.com/vueuse/vueuse).\n\n当然，我们不可能总是写到这么通用的代码，但是在业务中也可以使用 Composition API 来对业务逻辑进行拆分，让每一个组合函数负责独立的业务，比如埋点上报、RichTextPanel 组件参数与回调、页面控件逻辑等。这些组件内的状态、方法现在我们可以将它提取到组合函数中，可以是为了复用，也可以仅仅是为了让 .vue 文件看起来更干净。\n\n## 二、API\n\n**2.1 setup**\n\n`setup` 是组合式 API 的入口点，它的执行时机在 `beforeCreate` 和 `created`，并且只会执行一次。\n\n所以我们不需要 `onBeforeCreate` 和 `onCreated`，这些钩子对应的代码应该直接在 `setup` 函数中编写。\n\n它接收两个参数：\n\n1.  响应式的 `props`\n2.  非响应式的 `context`，包含：attrs、slots、emit\n\n它执行的时候组件实例尚未被创建，所以我们无法访问 data、computed、methods 这些组件选项。\n\n如果它返回一个对象，那么对象的 property 就可以在选项或者模板中访问到。\n\n**2.1.1 返回渲染函数**\n\n![](https://pic1.zhimg.com/v2-ed3d1aa04bf9bf33e9878a0d935fb074_r.jpg)\n\n在 Babel Plugin 支持下可以返回 JSX：[feat: add @vue/composition-api support #142](https://link.zhihu.com/?target=https%3A//github.com/vuejs/jsx/pull/142)\n\n**2.1.2 getCurrentInstance**\n\n如果确实需要访问组件实例，可以使用 `getCurrentInstance()`。\n\n只能在 `setup`、生命周期钩子和组合函数中使用。\n\n![](https://pic4.zhimg.com/v2-2219ce295be181f25efcf766f103d15b_r.jpg)\n\n**2.2 reactive**\n\n返回对象的响应式副本，相当于 `Vue.observable(obj)` 。\n\n该响应式转换是 “深度转换”——它会影响嵌套对象传递的所有 property。\n\n怎么理解这里的响应式呢？就是我们在渲染期间使用响应式对象，当值改变的时候视图会自动更新，就和修改挂在 data 对象里的值一样。\n\n**2.2.1 无法代理原始值类型**\n\nreactive() 函数可以代理一个对象，但不能代理基本类型值，这是因为原始值类型只有值而没有引用，无法追踪变量的后续变化。\n\n**2.2.2 响应丢失**\n\n![](https://pic2.zhimg.com/v2-bde37e9bd232fafb93168b55251367b9_r.jpg)\n\n**2.3 ref**\n\n接收一个值，返回的响应式且可变的包装对象。\n\n它只有一个属性：`.value` ，该属性指向内部被包装的值。这个值可以直接修改。\n\n我们没法用 reactive 处理原始值类型，但是我们可以创建一个对象将原始值挂在它的同名 property 下，再传递给 reactive。Vue 提供了 ref 来替我们做这件事。\n\n![](https://pic1.zhimg.com/v2-19e7df03e22381ebc37428bf17a8e594_r.jpg)\n\n**2.3.1 自动解包（不需要加 .value 的情况）**\n\n1.  ref 在模板中会自动解包\n\n2.`watch` 可以直接接受 ref 作为监听对象，在回调函数中会直接返回解包后的值。\n\n![](https://pic2.zhimg.com/v2-61b795e0a933eaba882ebe38e65d3acd_r.jpg)\n\n3. 使用 reactive() / readonly() 解包对象嵌套的 ref\n\n![](https://pic3.zhimg.com/v2-6b5120ec665ba0e9330220c967ac023a_r.jpg)\n\n但是从 `Array` 或原生集合类型如 `Map`访问 ref 时，不会进行解包。\n\n**2.3.2 unref（ref 的反向操作）**\n\n传入一个 ref，返回 `ref.value`，否则原样返回。\n\n纠结是否需要加 `.value`（比如某个函数参数的类型是 `Ref<number> | number`）来取值，可以使用 unref 来解包。\n\n![](https://pic1.zhimg.com/v2-be644447a3adfae139ccb07863b4fe30_r.jpg)\n\n**2.3.3 重复使用已有 ref**\n\n将一个 ref 传递给 `ref()` 构造函数，它会原样返回。\n\n如果你的函数需要返回一个 ref，但是不确定参数的类型，可以直接 `return ref(param)`，如果是 ref 则会复用，不是则返回一个新的 ref。\n\n**2.3.4 可以使用 ES6 解构语法**\n\n解构一个值是 ref 的对象不会丢失响应式。\n\n![](https://pic3.zhimg.com/v2-fb83022e342cde7e017a54e710b8d6b6_r.jpg)\n\n**2.3.5 this.$refs 的解决方案**\n\n在虚拟 DOM 补丁算法中，如果 VNode 的 `ref` 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。\n\n由于是在虚拟 DOM 挂载 / 打补丁过程中执行的，因此 ref 只会在初始渲染之后才获得赋值。\n\n![](https://pic4.zhimg.com/v2-c08e93238d9074b4e78284dcca4b94cb_r.jpg)\n\n**2.4 toRefs**\n\n将响应式对象转换为普通对象，并对每个 property 对应的 value 转换成 ref。\n\n可以用来解决 `reactive` 或者 `props` 在解构的时候丢失响应式的问题。\n\n![](https://pic1.zhimg.com/v2-e1550002c1ead321c4dde992c78f944c_r.jpg)\n\n**2.5 computed**\n\n接收 getter 函数，返回一个**只读**的响应式 ref 对象。\n\n![](https://pic1.zhimg.com/v2-b2e6f76a4f4265e182212f3dff7b8ab4_r.jpg)\n\n如果参数是具有 get 和 set 函数的对象，返回的结果会是一个**可写**的响应式 ref 对象。\n\n![](https://pic4.zhimg.com/v2-c7dadc1902029f1fa98537e6c13744d3_r.jpg)\n\n**2.6 watch**\n\n第一个参数接收数据源，可以是：\n\n*   getter 函数、ref\n*   包含上述两种类型的数组（也就是可以 watch 多个源，其中任一个变化都会触发回调）\n\n第二个参数是回调函数，在数据源变动的时候触发。\n\n![](https://pic3.zhimg.com/v2-b0556885105bd72c7b0b6ea131af826a_r.jpg)\n\n**2.6.1 停止观察**\n\n`watch()` 返回一个停止观察的函数：\n\n![](https://pic1.zhimg.com/v2-75541dc512f2994a4ac1719df0e23a64_r.jpg)\n\n如果 `watch()` 是在一个组件的 `setup()` 或是生命周期函数中被调用的，那么该 watcher 会在当前组件被销毁时也一同被自动停\n\n**2.6.2 清理 effect**\n\nwatcher 的回调会接收到的第三个参数是一个用来注册清理操作的函数。\n\n有时候当观察的数据源变化后，我们可能需要对之前所执行的副作用进行清理。举例来说，一个异步操作在完成之前数据就产生了变化，我们可能要撤销还在等待的前一个操作。\n\n调用这个函数可以注册一个清理函数，执行时机在：\n\n*   回调被下一次调用前\n*   watcher 被停止前\n\n![](https://pic4.zhimg.com/v2-f81961ecde2ab5d1edecc76cb51940b3_r.jpg)\n\n## 三、设计动机\n\n**3.1 从 Class API 到 Function API 再到 Composition API**\n\n我们可以在 Vue RFC 中看到最初的 [Class API](https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/17) 到 [Function-based Component API](https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/42) 取其 FP 的精华，再到被修订为 [Composition API](https://link.zhihu.com/?target=https%3A//github.com/vuejs/rfcs/pull/78) 采用 Reactivity 的过程。\n\n**3.2 解决了什么问题**\n\n对比 2.x 对象式 API：\n\n*   极易复用。\n\n*   状态可以从组件中拆出来放到组合函数中。\n\n*   更清楚的逻辑。\n\n*   代码可以按功能 / 逻辑组织，而不是分散在各个选项中。\n\n*   更好的 TypeScript 类型支持。\n\n*   基于 Class 的 API 存在 TS 类型问题，而基于函数的 API 天然对类型推导很友好，因为 TS 对函数的参数、返回值和泛型的支持已经非常完备。\n\n*   更小的打包体积。\n\n*   基于函数的 API 每一个函数都可以作为 named ES export 被单独引入，这使得它们对 tree-shaking 非常友好。没有被使用的 API 的相关代码可以在最终打包时被移除。\n*   同时，基于函数 API 所写的代码也有更好的压缩效率，因为所有的函数名和 setup 函数体内部的变量名都可以被压缩，但对象和 class 的属性 / 方法名却不可以。\n\n**3.3 对比 2.x 的复用模式**\n\nVue 2.x 目前的 API 我们有一些常见的逻辑复用模式，包括：\n\n*   Mixins\n*   高阶组件 (Higher-order Components, aka HOCs)\n*   Renderless Components （基于 scoped slots / 作用域插槽封装逻辑的组件）\n\n总体来说，以上这些模式存在以下问题：\n\n*   模版中的数据来源不清晰。\n\n*   举例来说，当一个组件中使用了多个 mixin 的时候，光看模版会很难分清一个属性到底是来自哪一个 mixin。HOC 也有类似的问题。\n\n*   使用 Composition API 只需要观察 setup 函数就可以知道数据的来源。\n*   命名空间冲突。\n\n*   由不同开发者开发的 mixin 无法保证不会正好用到一样的属性或是方法名。HOC 在注入的 props 中也存在类似问题。\n\n*   组合函数在使用和返回给渲染层的两个阶段都可以做重命名的操作。\n*   性能。\n\n*   HOC 和 Renderless Components 都需要额外的组件实例嵌套来封装逻辑，导致无谓的性能开销。\n\n*   组合函数没有创建额外的组件实例所带来的性能损耗。\n\n**3.4 对比 React Hooks**\n\nComposition API 虽然借鉴了 React Hooks，两者具有同等的基于函数抽取和复用逻辑的能力，但是出于框架的性质两者在实现上是天差地别的。\n\nReact Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。而 Vue 的 `setup()` 每个组件实例只会在初始化时调用一次 ，状态通过引用储存在 `setup()` 的闭包内。\n\n也就是说，Composition API 相比 React Hooks：\n\n*   整体上更符合 JavaScript 的直觉；\n\n*   Mutable 写法。\n\n*   不受调用顺序的限制，可以有条件地被调用；\n\n*   Hooks 需要使用下标来获取对应的 state。\n\n*   不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；\n\n*   Hooks 的每次渲染都是单独的闭包。\n\n*   不需要总是使用 `useCallback` 来缓存传给子组件的回调以防止过度更新；\n\n*   如果给子组件传了函数，每次渲染都会被当作新 props。\n\n*   不需要担心传了错误的依赖数组给 `useEffect/useMemo/useCallback` 从而导致回调中使用了过期的值。\n\n*   Vue 的依赖收集是全自动的，可以做到最小粒度的更新。\n\n这都是基于 Vue 的响应式更新能力。\n\n有兴趣的同学可以通过下面的链接了解 React Hooks 的心智模型有多么沉重：\n\n[Hooks FAQ](https://link.zhihu.com/?target=https%3A//zh-hans.reactjs.org/docs/hooks-faq.html%23from-classes-to-hooks)\n\n[使用 React Hooks 声明 setInterval](https://link.zhihu.com/?target=https%3A//overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/)\n\n[useEffect 完整指南](https://link.zhihu.com/?target=https%3A//overreacted.io/zh-hans/a-complete-guide-to-useeffect/)\n\n**3.5 那么它有缺点吗？**\n\n**3.5.1 ref 和 reactive 的区别**\n\n<table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>ref</th><th>reactive</th></tr><tr><td>可以处理原始值，也可以处理对象</td><td>只能处理对象</td></tr><tr><td>需要加 .value，需要考虑自动解包</td><td>不需要加 .value</td></tr><tr><td>有单独的类型</td><td>和普通的对象没有什么区别，无法直接通过类型判断是否是响应式</td></tr><tr><td>可以使用解构赋值</td><td>不可以使用解构赋值，会丢失响应式</td></tr><tr><td></td><td>需要使用箭头函数包装才能使用 watch</td></tr></tbody></table>\n\n**3.5.2 考虑响应式和 .value**\n\n虽然写 Composition API 不会有 `useEffect` 的困扰，还能使用完全一致的生命周期钩子函数，但是此次 Vue 把响应式 API 暴露给我们，实际上在编写代码的时候，需要考虑是否是响应式、是否是 ref 和响应式丢失的问题，也会带来一定的心智负担。\n\n## 总结\n\n**面向生命周期编程 vs 面向业务逻辑编程**  \nComposition API 带来了组件逻辑抽取和复用的优化，抽取逻辑会变得非常简单，所以我们不必只在需要复用逻辑的时候才抽取函数，也可以单纯为了更好地组织代码去抽取函数，以此避免每个逻辑任务的代码都被选项切成了多个碎片分散在各处。  \n当然如果组件足够简单，我们还是可以只使用 Options API，以原来的习惯写代码。**我可以在 Vue 2 中使用吗？**  \n可以的，官方团队提供了可供 Vue 2 使用的插件： [@vue/composition-api](https://link.zhihu.com/?target=https%3A//github.com/vuejs/composition-api)。  \n另外他们也计划让 Composition API 在 Vue 2.7 原生支持。\n\n## 参考\n\n[官方文档](https://link.zhihu.com/?target=https%3A//v3.cn.vuejs.org/guide/composition-api-introduction.html%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E7%25BB%2584%25E5%2590%2588%25E5%25BC%258F-api)\n\n[Vue Function-based API RFC](https://zhuanlan.zhihu.com/p/68477600)\n\n[VueUse 作者 Anthony Fu 分享可组合的 Vue](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1x54y1V7H6/)\n\n[深入理解 Vue3 Reactivity API](https://zhuanlan.zhihu.com/p/146097763)","slug":"ReprintVueCompositionAPI","published":1,"updated":"2023-03-02T15:42:04.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychf00197gh86shpb4av","content":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/408272742\" >https://zhuanlan.zhihu.com/p/408272742 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>关注 React 的同学应该知道，React 在 19 年推出了 Hooks API，从而可以抛弃难以理解的 class 完全转向函数式组件。当然，它对开发者的意义不止于此，更为重要的是它提供了从组件中<strong>提取状态逻辑</strong>的能力，让我们能以业务逻辑为细粒度拆分组件，并在组件之间复用业务逻辑。</p>\n<p>后续尤大马上发布了 Vue Function-based API RFC（在之后重写成了 Composition API），并作为 Vue3 的核心特性，可想而知它的重要性。</p>\n<p>接下来让我们抛开 React，来看看 Composition API 都有哪些内容。</p>\n<h2 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h2><p><strong>1.1 什么是 Composition API ？</strong></p>\n<p>Vue 3 中引入的一种新的编写 Vue 组件的方式，可以将 2.x 中与组件逻辑相关的选项以 API 函数的形式重新设计。</p>\n<p><strong>1.2 基本例子</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic2.zhimg.com/v2-3215832798dad4d85252c140e509f445_r.jpg\"\n                     \n                ></p>\n<p>我们使用 Composition API 对左侧进行重构，其实就是将组件选项抽离到了 <code>setup</code> 函数当中进行编排，并在最后把模板用到的变量返回，最后的结果和将变量定义在 <code>data</code> 或者 <code>methods</code> 中没有什么区别。</p>\n<p>当然，setup 和 2.x 的选项一起混用也是没有问题的，并且依旧可以通过 <code>this.xx</code> 访问到 <code>setup</code> 返回的变量。</p>\n<p>❓ 如果只是把代码迁移到 <code>setup</code> 函数中，变成一长条的面条式代码，有什么意义呢</p>\n<p><strong>1.3 更进一步的例子</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-7889c66d30a72bf92842103cf92ed84e_r.jpg\"\n                     \n                ></p>\n<p>这一次我们将 <code>setup</code> 中的代码进一步抽离，拆出了 <code>useMouse</code> 组合函数，里面封装了对鼠标位置的监听逻辑。<code>useMouse</code> 只需要将要暴露给组件的状态（<code>x</code>、<code>y</code>）以响应式的数据源的方式返回出来，就可以在我们的组件代码中使用。</p>\n<p>对于 Component 来说，里面没有任何监听鼠标位置的逻辑代码，只需要调用 <code>useMouse</code> 拿到 <code>x</code>、<code>y</code> 即可。</p>\n<p>❓ 这些我用 Mixins 也能实现呀</p>\n<p><strong>1.4 更更进一步的例子</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-7e01ef06f0e5e71970a6f98dcc5a610f_r.jpg\"\n                     \n                ></p>\n<p>首先我们通过模板来理解 <code>useDark</code> 的工作内容，就是返回了一个表示是否是黑夜模式的布尔值，并且可以通过 <code>useToggle</code> 来快速得到一个 toggle 函数。</p>\n<p>然后观察 <code>useDark</code>，我们可以看到它身为一个组合函数的同时，又调用了其他的组合函数 <code>usePreferredDark</code> 和 <code>useLocalStorage</code> 来获取系统主题色和本地配置色。当然，我们不需要太关心它们的具体实现，只需要专注于处理结果，并返回以本地配置色为优先的结果即可。</p>\n<p>其中的组合函数调用关系如下图所示：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-1f58c63c4fccaffaa58660947892808a_r.jpg\"\n                     \n                ></p>\n<p>组合函数的底层又依赖了其他组合函数，比如 <code>useLocalStorage</code> 依赖统一封装了 SessionStorage 和 LocalStorage 逻辑的 <code>useStorage</code>，<code>usePreferredDark</code> 依赖封装了 <code>window.matchMedia</code> 逻辑的 <code>useMediaQuery</code>。它们最后又都通过 <code>useEventListener</code> 来做状态改变的响应，并且能自动卸载。</p>\n<p>涉及的每一个函数都能独立使用，并且有自己的职责，最后进行组合。</p>\n<p>这个例子来源于 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vueuse/vueuse\" >VueUse <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>.</p>\n<p>当然，我们不可能总是写到这么通用的代码，但是在业务中也可以使用 Composition API 来对业务逻辑进行拆分，让每一个组合函数负责独立的业务，比如埋点上报、RichTextPanel 组件参数与回调、页面控件逻辑等。这些组件内的状态、方法现在我们可以将它提取到组合函数中，可以是为了复用，也可以仅仅是为了让 .vue 文件看起来更干净。</p>\n<h2 id=\"二、API\"><a href=\"#二、API\" class=\"headerlink\" title=\"二、API\"></a>二、API</h2><p><strong>2.1 setup</strong></p>\n<p><code>setup</code> 是组合式 API 的入口点，它的执行时机在 <code>beforeCreate</code> 和 <code>created</code>，并且只会执行一次。</p>\n<p>所以我们不需要 <code>onBeforeCreate</code> 和 <code>onCreated</code>，这些钩子对应的代码应该直接在 <code>setup</code> 函数中编写。</p>\n<p>它接收两个参数：</p>\n<ol>\n<li>响应式的 <code>props</code></li>\n<li>非响应式的 <code>context</code>，包含：attrs、slots、emit</li>\n</ol>\n<p>它执行的时候组件实例尚未被创建，所以我们无法访问 data、computed、methods 这些组件选项。</p>\n<p>如果它返回一个对象，那么对象的 property 就可以在选项或者模板中访问到。</p>\n<p><strong>2.1.1 返回渲染函数</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-ed3d1aa04bf9bf33e9878a0d935fb074_r.jpg\"\n                     \n                ></p>\n<p>在 Babel Plugin 支持下可以返回 JSX：<a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/jsx/pull/142\" >feat: add @vue&#x2F;composition-api support #142 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>2.1.2 getCurrentInstance</strong></p>\n<p>如果确实需要访问组件实例，可以使用 <code>getCurrentInstance()</code>。</p>\n<p>只能在 <code>setup</code>、生命周期钩子和组合函数中使用。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-2219ce295be181f25efcf766f103d15b_r.jpg\"\n                     \n                ></p>\n<p><strong>2.2 reactive</strong></p>\n<p>返回对象的响应式副本，相当于 <code>Vue.observable(obj)</code> 。</p>\n<p>该响应式转换是 “深度转换”——它会影响嵌套对象传递的所有 property。</p>\n<p>怎么理解这里的响应式呢？就是我们在渲染期间使用响应式对象，当值改变的时候视图会自动更新，就和修改挂在 data 对象里的值一样。</p>\n<p><strong>2.2.1 无法代理原始值类型</strong></p>\n<p>reactive() 函数可以代理一个对象，但不能代理基本类型值，这是因为原始值类型只有值而没有引用，无法追踪变量的后续变化。</p>\n<p><strong>2.2.2 响应丢失</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic2.zhimg.com/v2-bde37e9bd232fafb93168b55251367b9_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3 ref</strong></p>\n<p>接收一个值，返回的响应式且可变的包装对象。</p>\n<p>它只有一个属性：<code>.value</code> ，该属性指向内部被包装的值。这个值可以直接修改。</p>\n<p>我们没法用 reactive 处理原始值类型，但是我们可以创建一个对象将原始值挂在它的同名 property 下，再传递给 reactive。Vue 提供了 ref 来替我们做这件事。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-19e7df03e22381ebc37428bf17a8e594_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3.1 自动解包（不需要加 .value 的情况）</strong></p>\n<ol>\n<li>ref 在模板中会自动解包</li>\n</ol>\n<p>2.<code>watch</code> 可以直接接受 ref 作为监听对象，在回调函数中会直接返回解包后的值。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic2.zhimg.com/v2-61b795e0a933eaba882ebe38e65d3acd_r.jpg\"\n                     \n                ></p>\n<ol start=\"3\">\n<li>使用 reactive() &#x2F; readonly() 解包对象嵌套的 ref</li>\n</ol>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-6b5120ec665ba0e9330220c967ac023a_r.jpg\"\n                     \n                ></p>\n<p>但是从 <code>Array</code> 或原生集合类型如 <code>Map</code>访问 ref 时，不会进行解包。</p>\n<p><strong>2.3.2 unref（ref 的反向操作）</strong></p>\n<p>传入一个 ref，返回 <code>ref.value</code>，否则原样返回。</p>\n<p>纠结是否需要加 <code>.value</code>（比如某个函数参数的类型是 <code>Ref&lt;number&gt; | number</code>）来取值，可以使用 unref 来解包。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-be644447a3adfae139ccb07863b4fe30_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3.3 重复使用已有 ref</strong></p>\n<p>将一个 ref 传递给 <code>ref()</code> 构造函数，它会原样返回。</p>\n<p>如果你的函数需要返回一个 ref，但是不确定参数的类型，可以直接 <code>return ref(param)</code>，如果是 ref 则会复用，不是则返回一个新的 ref。</p>\n<p><strong>2.3.4 可以使用 ES6 解构语法</strong></p>\n<p>解构一个值是 ref 的对象不会丢失响应式。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-fb83022e342cde7e017a54e710b8d6b6_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3.5 this.$refs 的解决方案</strong></p>\n<p>在虚拟 DOM 补丁算法中，如果 VNode 的 <code>ref</code> 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。</p>\n<p>由于是在虚拟 DOM 挂载 &#x2F; 打补丁过程中执行的，因此 ref 只会在初始渲染之后才获得赋值。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-c08e93238d9074b4e78284dcca4b94cb_r.jpg\"\n                     \n                ></p>\n<p><strong>2.4 toRefs</strong></p>\n<p>将响应式对象转换为普通对象，并对每个 property 对应的 value 转换成 ref。</p>\n<p>可以用来解决 <code>reactive</code> 或者 <code>props</code> 在解构的时候丢失响应式的问题。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-e1550002c1ead321c4dde992c78f944c_r.jpg\"\n                     \n                ></p>\n<p><strong>2.5 computed</strong></p>\n<p>接收 getter 函数，返回一个<strong>只读</strong>的响应式 ref 对象。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-b2e6f76a4f4265e182212f3dff7b8ab4_r.jpg\"\n                     \n                ></p>\n<p>如果参数是具有 get 和 set 函数的对象，返回的结果会是一个<strong>可写</strong>的响应式 ref 对象。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-c7dadc1902029f1fa98537e6c13744d3_r.jpg\"\n                     \n                ></p>\n<p><strong>2.6 watch</strong></p>\n<p>第一个参数接收数据源，可以是：</p>\n<ul>\n<li>getter 函数、ref</li>\n<li>包含上述两种类型的数组（也就是可以 watch 多个源，其中任一个变化都会触发回调）</li>\n</ul>\n<p>第二个参数是回调函数，在数据源变动的时候触发。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-b0556885105bd72c7b0b6ea131af826a_r.jpg\"\n                     \n                ></p>\n<p><strong>2.6.1 停止观察</strong></p>\n<p><code>watch()</code> 返回一个停止观察的函数：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-75541dc512f2994a4ac1719df0e23a64_r.jpg\"\n                     \n                ></p>\n<p>如果 <code>watch()</code> 是在一个组件的 <code>setup()</code> 或是生命周期函数中被调用的，那么该 watcher 会在当前组件被销毁时也一同被自动停</p>\n<p><strong>2.6.2 清理 effect</strong></p>\n<p>watcher 的回调会接收到的第三个参数是一个用来注册清理操作的函数。</p>\n<p>有时候当观察的数据源变化后，我们可能需要对之前所执行的副作用进行清理。举例来说，一个异步操作在完成之前数据就产生了变化，我们可能要撤销还在等待的前一个操作。</p>\n<p>调用这个函数可以注册一个清理函数，执行时机在：</p>\n<ul>\n<li>回调被下一次调用前</li>\n<li>watcher 被停止前</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-f81961ecde2ab5d1edecc76cb51940b3_r.jpg\"\n                     \n                ></p>\n<h2 id=\"三、设计动机\"><a href=\"#三、设计动机\" class=\"headerlink\" title=\"三、设计动机\"></a>三、设计动机</h2><p><strong>3.1 从 Class API 到 Function API 再到 Composition API</strong></p>\n<p>我们可以在 Vue RFC 中看到最初的 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/17\" >Class API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 到 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/42\" >Function-based Component API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 取其 FP 的精华，再到被修订为 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/78\" >Composition API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 采用 Reactivity 的过程。</p>\n<p><strong>3.2 解决了什么问题</strong></p>\n<p>对比 2.x 对象式 API：</p>\n<ul>\n<li><p>极易复用。</p>\n</li>\n<li><p>状态可以从组件中拆出来放到组合函数中。</p>\n</li>\n<li><p>更清楚的逻辑。</p>\n</li>\n<li><p>代码可以按功能 &#x2F; 逻辑组织，而不是分散在各个选项中。</p>\n</li>\n<li><p>更好的 TypeScript 类型支持。</p>\n</li>\n<li><p>基于 Class 的 API 存在 TS 类型问题，而基于函数的 API 天然对类型推导很友好，因为 TS 对函数的参数、返回值和泛型的支持已经非常完备。</p>\n</li>\n<li><p>更小的打包体积。</p>\n</li>\n<li><p>基于函数的 API 每一个函数都可以作为 named ES export 被单独引入，这使得它们对 tree-shaking 非常友好。没有被使用的 API 的相关代码可以在最终打包时被移除。</p>\n</li>\n<li><p>同时，基于函数 API 所写的代码也有更好的压缩效率，因为所有的函数名和 setup 函数体内部的变量名都可以被压缩，但对象和 class 的属性 &#x2F; 方法名却不可以。</p>\n</li>\n</ul>\n<p><strong>3.3 对比 2.x 的复用模式</strong></p>\n<p>Vue 2.x 目前的 API 我们有一些常见的逻辑复用模式，包括：</p>\n<ul>\n<li>Mixins</li>\n<li>高阶组件 (Higher-order Components, aka HOCs)</li>\n<li>Renderless Components （基于 scoped slots &#x2F; 作用域插槽封装逻辑的组件）</li>\n</ul>\n<p>总体来说，以上这些模式存在以下问题：</p>\n<ul>\n<li><p>模版中的数据来源不清晰。</p>\n</li>\n<li><p>举例来说，当一个组件中使用了多个 mixin 的时候，光看模版会很难分清一个属性到底是来自哪一个 mixin。HOC 也有类似的问题。</p>\n</li>\n<li><p>使用 Composition API 只需要观察 setup 函数就可以知道数据的来源。</p>\n</li>\n<li><p>命名空间冲突。</p>\n</li>\n<li><p>由不同开发者开发的 mixin 无法保证不会正好用到一样的属性或是方法名。HOC 在注入的 props 中也存在类似问题。</p>\n</li>\n<li><p>组合函数在使用和返回给渲染层的两个阶段都可以做重命名的操作。</p>\n</li>\n<li><p>性能。</p>\n</li>\n<li><p>HOC 和 Renderless Components 都需要额外的组件实例嵌套来封装逻辑，导致无谓的性能开销。</p>\n</li>\n<li><p>组合函数没有创建额外的组件实例所带来的性能损耗。</p>\n</li>\n</ul>\n<p><strong>3.4 对比 React Hooks</strong></p>\n<p>Composition API 虽然借鉴了 React Hooks，两者具有同等的基于函数抽取和复用逻辑的能力，但是出于框架的性质两者在实现上是天差地别的。</p>\n<p>React Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。而 Vue 的 <code>setup()</code> 每个组件实例只会在初始化时调用一次 ，状态通过引用储存在 <code>setup()</code> 的闭包内。</p>\n<p>也就是说，Composition API 相比 React Hooks：</p>\n<ul>\n<li><p>整体上更符合 JavaScript 的直觉；</p>\n</li>\n<li><p>Mutable 写法。</p>\n</li>\n<li><p>不受调用顺序的限制，可以有条件地被调用；</p>\n</li>\n<li><p>Hooks 需要使用下标来获取对应的 state。</p>\n</li>\n<li><p>不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</p>\n</li>\n<li><p>Hooks 的每次渲染都是单独的闭包。</p>\n</li>\n<li><p>不需要总是使用 <code>useCallback</code> 来缓存传给子组件的回调以防止过度更新；</p>\n</li>\n<li><p>如果给子组件传了函数，每次渲染都会被当作新 props。</p>\n</li>\n<li><p>不需要担心传了错误的依赖数组给 <code>useEffect/useMemo/useCallback</code> 从而导致回调中使用了过期的值。</p>\n</li>\n<li><p>Vue 的依赖收集是全自动的，可以做到最小粒度的更新。</p>\n</li>\n</ul>\n<p>这都是基于 Vue 的响应式更新能力。</p>\n<p>有兴趣的同学可以通过下面的链接了解 React Hooks 的心智模型有多么沉重：</p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://zh-hans.reactjs.org/docs/hooks-faq.html%23from-classes-to-hooks\" >Hooks FAQ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/\" >使用 React Hooks 声明 setInterval <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\" >useEffect 完整指南 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>3.5 那么它有缺点吗？</strong></p>\n<p><strong>3.5.1 ref 和 reactive 的区别</strong></p>\n<table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>ref</th><th>reactive</th></tr><tr><td>可以处理原始值，也可以处理对象</td><td>只能处理对象</td></tr><tr><td>需要加 .value，需要考虑自动解包</td><td>不需要加 .value</td></tr><tr><td>有单独的类型</td><td>和普通的对象没有什么区别，无法直接通过类型判断是否是响应式</td></tr><tr><td>可以使用解构赋值</td><td>不可以使用解构赋值，会丢失响应式</td></tr><tr><td></td><td>需要使用箭头函数包装才能使用 watch</td></tr></tbody></table>\n\n<p><strong>3.5.2 考虑响应式和 .value</strong></p>\n<p>虽然写 Composition API 不会有 <code>useEffect</code> 的困扰，还能使用完全一致的生命周期钩子函数，但是此次 Vue 把响应式 API 暴露给我们，实际上在编写代码的时候，需要考虑是否是响应式、是否是 ref 和响应式丢失的问题，也会带来一定的心智负担。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>面向生命周期编程 vs 面向业务逻辑编程</strong><br>Composition API 带来了组件逻辑抽取和复用的优化，抽取逻辑会变得非常简单，所以我们不必只在需要复用逻辑的时候才抽取函数，也可以单纯为了更好地组织代码去抽取函数，以此避免每个逻辑任务的代码都被选项切成了多个碎片分散在各处。<br>当然如果组件足够简单，我们还是可以只使用 Options API，以原来的习惯写代码。<strong>我可以在 Vue 2 中使用吗？</strong><br>可以的，官方团队提供了可供 Vue 2 使用的插件： <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/composition-api\" >@vue&#x2F;composition-api <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。<br>另外他们也计划让 Composition API 在 Vue 2.7 原生支持。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://v3.cn.vuejs.org/guide/composition-api-introduction.html%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E7%25BB%2584%25E5%2590%2588%25E5%25BC%258F-api\" >官方文档 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/68477600\" >Vue Function-based API RFC <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1x54y1V7H6/\" >VueUse 作者 Anthony Fu 分享可组合的 Vue <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/146097763\" >深入理解 Vue3 Reactivity API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/408272742\" >https://zhuanlan.zhihu.com/p/408272742 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>关注 React 的同学应该知道，React 在 19 年推出了 Hooks API，从而可以抛弃难以理解的 class 完全转向函数式组件。当然，它对开发者的意义不止于此，更为重要的是它提供了从组件中<strong>提取状态逻辑</strong>的能力，让我们能以业务逻辑为细粒度拆分组件，并在组件之间复用业务逻辑。</p>\n<p>后续尤大马上发布了 Vue Function-based API RFC（在之后重写成了 Composition API），并作为 Vue3 的核心特性，可想而知它的重要性。</p>\n<p>接下来让我们抛开 React，来看看 Composition API 都有哪些内容。</p>\n<h2 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h2><p><strong>1.1 什么是 Composition API ？</strong></p>\n<p>Vue 3 中引入的一种新的编写 Vue 组件的方式，可以将 2.x 中与组件逻辑相关的选项以 API 函数的形式重新设计。</p>\n<p><strong>1.2 基本例子</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic2.zhimg.com/v2-3215832798dad4d85252c140e509f445_r.jpg\"\n                     \n                ></p>\n<p>我们使用 Composition API 对左侧进行重构，其实就是将组件选项抽离到了 <code>setup</code> 函数当中进行编排，并在最后把模板用到的变量返回，最后的结果和将变量定义在 <code>data</code> 或者 <code>methods</code> 中没有什么区别。</p>\n<p>当然，setup 和 2.x 的选项一起混用也是没有问题的，并且依旧可以通过 <code>this.xx</code> 访问到 <code>setup</code> 返回的变量。</p>\n<p>❓ 如果只是把代码迁移到 <code>setup</code> 函数中，变成一长条的面条式代码，有什么意义呢</p>\n<p><strong>1.3 更进一步的例子</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-7889c66d30a72bf92842103cf92ed84e_r.jpg\"\n                     \n                ></p>\n<p>这一次我们将 <code>setup</code> 中的代码进一步抽离，拆出了 <code>useMouse</code> 组合函数，里面封装了对鼠标位置的监听逻辑。<code>useMouse</code> 只需要将要暴露给组件的状态（<code>x</code>、<code>y</code>）以响应式的数据源的方式返回出来，就可以在我们的组件代码中使用。</p>\n<p>对于 Component 来说，里面没有任何监听鼠标位置的逻辑代码，只需要调用 <code>useMouse</code> 拿到 <code>x</code>、<code>y</code> 即可。</p>\n<p>❓ 这些我用 Mixins 也能实现呀</p>\n<p><strong>1.4 更更进一步的例子</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-7e01ef06f0e5e71970a6f98dcc5a610f_r.jpg\"\n                     \n                ></p>\n<p>首先我们通过模板来理解 <code>useDark</code> 的工作内容，就是返回了一个表示是否是黑夜模式的布尔值，并且可以通过 <code>useToggle</code> 来快速得到一个 toggle 函数。</p>\n<p>然后观察 <code>useDark</code>，我们可以看到它身为一个组合函数的同时，又调用了其他的组合函数 <code>usePreferredDark</code> 和 <code>useLocalStorage</code> 来获取系统主题色和本地配置色。当然，我们不需要太关心它们的具体实现，只需要专注于处理结果，并返回以本地配置色为优先的结果即可。</p>\n<p>其中的组合函数调用关系如下图所示：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-1f58c63c4fccaffaa58660947892808a_r.jpg\"\n                     \n                ></p>\n<p>组合函数的底层又依赖了其他组合函数，比如 <code>useLocalStorage</code> 依赖统一封装了 SessionStorage 和 LocalStorage 逻辑的 <code>useStorage</code>，<code>usePreferredDark</code> 依赖封装了 <code>window.matchMedia</code> 逻辑的 <code>useMediaQuery</code>。它们最后又都通过 <code>useEventListener</code> 来做状态改变的响应，并且能自动卸载。</p>\n<p>涉及的每一个函数都能独立使用，并且有自己的职责，最后进行组合。</p>\n<p>这个例子来源于 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vueuse/vueuse\" >VueUse <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>.</p>\n<p>当然，我们不可能总是写到这么通用的代码，但是在业务中也可以使用 Composition API 来对业务逻辑进行拆分，让每一个组合函数负责独立的业务，比如埋点上报、RichTextPanel 组件参数与回调、页面控件逻辑等。这些组件内的状态、方法现在我们可以将它提取到组合函数中，可以是为了复用，也可以仅仅是为了让 .vue 文件看起来更干净。</p>\n<h2 id=\"二、API\"><a href=\"#二、API\" class=\"headerlink\" title=\"二、API\"></a>二、API</h2><p><strong>2.1 setup</strong></p>\n<p><code>setup</code> 是组合式 API 的入口点，它的执行时机在 <code>beforeCreate</code> 和 <code>created</code>，并且只会执行一次。</p>\n<p>所以我们不需要 <code>onBeforeCreate</code> 和 <code>onCreated</code>，这些钩子对应的代码应该直接在 <code>setup</code> 函数中编写。</p>\n<p>它接收两个参数：</p>\n<ol>\n<li>响应式的 <code>props</code></li>\n<li>非响应式的 <code>context</code>，包含：attrs、slots、emit</li>\n</ol>\n<p>它执行的时候组件实例尚未被创建，所以我们无法访问 data、computed、methods 这些组件选项。</p>\n<p>如果它返回一个对象，那么对象的 property 就可以在选项或者模板中访问到。</p>\n<p><strong>2.1.1 返回渲染函数</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-ed3d1aa04bf9bf33e9878a0d935fb074_r.jpg\"\n                     \n                ></p>\n<p>在 Babel Plugin 支持下可以返回 JSX：<a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/jsx/pull/142\" >feat: add @vue&#x2F;composition-api support #142 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>2.1.2 getCurrentInstance</strong></p>\n<p>如果确实需要访问组件实例，可以使用 <code>getCurrentInstance()</code>。</p>\n<p>只能在 <code>setup</code>、生命周期钩子和组合函数中使用。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-2219ce295be181f25efcf766f103d15b_r.jpg\"\n                     \n                ></p>\n<p><strong>2.2 reactive</strong></p>\n<p>返回对象的响应式副本，相当于 <code>Vue.observable(obj)</code> 。</p>\n<p>该响应式转换是 “深度转换”——它会影响嵌套对象传递的所有 property。</p>\n<p>怎么理解这里的响应式呢？就是我们在渲染期间使用响应式对象，当值改变的时候视图会自动更新，就和修改挂在 data 对象里的值一样。</p>\n<p><strong>2.2.1 无法代理原始值类型</strong></p>\n<p>reactive() 函数可以代理一个对象，但不能代理基本类型值，这是因为原始值类型只有值而没有引用，无法追踪变量的后续变化。</p>\n<p><strong>2.2.2 响应丢失</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic2.zhimg.com/v2-bde37e9bd232fafb93168b55251367b9_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3 ref</strong></p>\n<p>接收一个值，返回的响应式且可变的包装对象。</p>\n<p>它只有一个属性：<code>.value</code> ，该属性指向内部被包装的值。这个值可以直接修改。</p>\n<p>我们没法用 reactive 处理原始值类型，但是我们可以创建一个对象将原始值挂在它的同名 property 下，再传递给 reactive。Vue 提供了 ref 来替我们做这件事。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-19e7df03e22381ebc37428bf17a8e594_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3.1 自动解包（不需要加 .value 的情况）</strong></p>\n<ol>\n<li>ref 在模板中会自动解包</li>\n</ol>\n<p>2.<code>watch</code> 可以直接接受 ref 作为监听对象，在回调函数中会直接返回解包后的值。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic2.zhimg.com/v2-61b795e0a933eaba882ebe38e65d3acd_r.jpg\"\n                     \n                ></p>\n<ol start=\"3\">\n<li>使用 reactive() &#x2F; readonly() 解包对象嵌套的 ref</li>\n</ol>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-6b5120ec665ba0e9330220c967ac023a_r.jpg\"\n                     \n                ></p>\n<p>但是从 <code>Array</code> 或原生集合类型如 <code>Map</code>访问 ref 时，不会进行解包。</p>\n<p><strong>2.3.2 unref（ref 的反向操作）</strong></p>\n<p>传入一个 ref，返回 <code>ref.value</code>，否则原样返回。</p>\n<p>纠结是否需要加 <code>.value</code>（比如某个函数参数的类型是 <code>Ref&lt;number&gt; | number</code>）来取值，可以使用 unref 来解包。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-be644447a3adfae139ccb07863b4fe30_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3.3 重复使用已有 ref</strong></p>\n<p>将一个 ref 传递给 <code>ref()</code> 构造函数，它会原样返回。</p>\n<p>如果你的函数需要返回一个 ref，但是不确定参数的类型，可以直接 <code>return ref(param)</code>，如果是 ref 则会复用，不是则返回一个新的 ref。</p>\n<p><strong>2.3.4 可以使用 ES6 解构语法</strong></p>\n<p>解构一个值是 ref 的对象不会丢失响应式。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-fb83022e342cde7e017a54e710b8d6b6_r.jpg\"\n                     \n                ></p>\n<p><strong>2.3.5 this.$refs 的解决方案</strong></p>\n<p>在虚拟 DOM 补丁算法中，如果 VNode 的 <code>ref</code> 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。</p>\n<p>由于是在虚拟 DOM 挂载 &#x2F; 打补丁过程中执行的，因此 ref 只会在初始渲染之后才获得赋值。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-c08e93238d9074b4e78284dcca4b94cb_r.jpg\"\n                     \n                ></p>\n<p><strong>2.4 toRefs</strong></p>\n<p>将响应式对象转换为普通对象，并对每个 property 对应的 value 转换成 ref。</p>\n<p>可以用来解决 <code>reactive</code> 或者 <code>props</code> 在解构的时候丢失响应式的问题。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-e1550002c1ead321c4dde992c78f944c_r.jpg\"\n                     \n                ></p>\n<p><strong>2.5 computed</strong></p>\n<p>接收 getter 函数，返回一个<strong>只读</strong>的响应式 ref 对象。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-b2e6f76a4f4265e182212f3dff7b8ab4_r.jpg\"\n                     \n                ></p>\n<p>如果参数是具有 get 和 set 函数的对象，返回的结果会是一个<strong>可写</strong>的响应式 ref 对象。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-c7dadc1902029f1fa98537e6c13744d3_r.jpg\"\n                     \n                ></p>\n<p><strong>2.6 watch</strong></p>\n<p>第一个参数接收数据源，可以是：</p>\n<ul>\n<li>getter 函数、ref</li>\n<li>包含上述两种类型的数组（也就是可以 watch 多个源，其中任一个变化都会触发回调）</li>\n</ul>\n<p>第二个参数是回调函数，在数据源变动的时候触发。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic3.zhimg.com/v2-b0556885105bd72c7b0b6ea131af826a_r.jpg\"\n                     \n                ></p>\n<p><strong>2.6.1 停止观察</strong></p>\n<p><code>watch()</code> 返回一个停止观察的函数：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic1.zhimg.com/v2-75541dc512f2994a4ac1719df0e23a64_r.jpg\"\n                     \n                ></p>\n<p>如果 <code>watch()</code> 是在一个组件的 <code>setup()</code> 或是生命周期函数中被调用的，那么该 watcher 会在当前组件被销毁时也一同被自动停</p>\n<p><strong>2.6.2 清理 effect</strong></p>\n<p>watcher 的回调会接收到的第三个参数是一个用来注册清理操作的函数。</p>\n<p>有时候当观察的数据源变化后，我们可能需要对之前所执行的副作用进行清理。举例来说，一个异步操作在完成之前数据就产生了变化，我们可能要撤销还在等待的前一个操作。</p>\n<p>调用这个函数可以注册一个清理函数，执行时机在：</p>\n<ul>\n<li>回调被下一次调用前</li>\n<li>watcher 被停止前</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://pic4.zhimg.com/v2-f81961ecde2ab5d1edecc76cb51940b3_r.jpg\"\n                     \n                ></p>\n<h2 id=\"三、设计动机\"><a href=\"#三、设计动机\" class=\"headerlink\" title=\"三、设计动机\"></a>三、设计动机</h2><p><strong>3.1 从 Class API 到 Function API 再到 Composition API</strong></p>\n<p>我们可以在 Vue RFC 中看到最初的 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/17\" >Class API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 到 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/42\" >Function-based Component API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 取其 FP 的精华，再到被修订为 <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/rfcs/pull/78\" >Composition API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 采用 Reactivity 的过程。</p>\n<p><strong>3.2 解决了什么问题</strong></p>\n<p>对比 2.x 对象式 API：</p>\n<ul>\n<li><p>极易复用。</p>\n</li>\n<li><p>状态可以从组件中拆出来放到组合函数中。</p>\n</li>\n<li><p>更清楚的逻辑。</p>\n</li>\n<li><p>代码可以按功能 &#x2F; 逻辑组织，而不是分散在各个选项中。</p>\n</li>\n<li><p>更好的 TypeScript 类型支持。</p>\n</li>\n<li><p>基于 Class 的 API 存在 TS 类型问题，而基于函数的 API 天然对类型推导很友好，因为 TS 对函数的参数、返回值和泛型的支持已经非常完备。</p>\n</li>\n<li><p>更小的打包体积。</p>\n</li>\n<li><p>基于函数的 API 每一个函数都可以作为 named ES export 被单独引入，这使得它们对 tree-shaking 非常友好。没有被使用的 API 的相关代码可以在最终打包时被移除。</p>\n</li>\n<li><p>同时，基于函数 API 所写的代码也有更好的压缩效率，因为所有的函数名和 setup 函数体内部的变量名都可以被压缩，但对象和 class 的属性 &#x2F; 方法名却不可以。</p>\n</li>\n</ul>\n<p><strong>3.3 对比 2.x 的复用模式</strong></p>\n<p>Vue 2.x 目前的 API 我们有一些常见的逻辑复用模式，包括：</p>\n<ul>\n<li>Mixins</li>\n<li>高阶组件 (Higher-order Components, aka HOCs)</li>\n<li>Renderless Components （基于 scoped slots &#x2F; 作用域插槽封装逻辑的组件）</li>\n</ul>\n<p>总体来说，以上这些模式存在以下问题：</p>\n<ul>\n<li><p>模版中的数据来源不清晰。</p>\n</li>\n<li><p>举例来说，当一个组件中使用了多个 mixin 的时候，光看模版会很难分清一个属性到底是来自哪一个 mixin。HOC 也有类似的问题。</p>\n</li>\n<li><p>使用 Composition API 只需要观察 setup 函数就可以知道数据的来源。</p>\n</li>\n<li><p>命名空间冲突。</p>\n</li>\n<li><p>由不同开发者开发的 mixin 无法保证不会正好用到一样的属性或是方法名。HOC 在注入的 props 中也存在类似问题。</p>\n</li>\n<li><p>组合函数在使用和返回给渲染层的两个阶段都可以做重命名的操作。</p>\n</li>\n<li><p>性能。</p>\n</li>\n<li><p>HOC 和 Renderless Components 都需要额外的组件实例嵌套来封装逻辑，导致无谓的性能开销。</p>\n</li>\n<li><p>组合函数没有创建额外的组件实例所带来的性能损耗。</p>\n</li>\n</ul>\n<p><strong>3.4 对比 React Hooks</strong></p>\n<p>Composition API 虽然借鉴了 React Hooks，两者具有同等的基于函数抽取和复用逻辑的能力，但是出于框架的性质两者在实现上是天差地别的。</p>\n<p>React Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。而 Vue 的 <code>setup()</code> 每个组件实例只会在初始化时调用一次 ，状态通过引用储存在 <code>setup()</code> 的闭包内。</p>\n<p>也就是说，Composition API 相比 React Hooks：</p>\n<ul>\n<li><p>整体上更符合 JavaScript 的直觉；</p>\n</li>\n<li><p>Mutable 写法。</p>\n</li>\n<li><p>不受调用顺序的限制，可以有条件地被调用；</p>\n</li>\n<li><p>Hooks 需要使用下标来获取对应的 state。</p>\n</li>\n<li><p>不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</p>\n</li>\n<li><p>Hooks 的每次渲染都是单独的闭包。</p>\n</li>\n<li><p>不需要总是使用 <code>useCallback</code> 来缓存传给子组件的回调以防止过度更新；</p>\n</li>\n<li><p>如果给子组件传了函数，每次渲染都会被当作新 props。</p>\n</li>\n<li><p>不需要担心传了错误的依赖数组给 <code>useEffect/useMemo/useCallback</code> 从而导致回调中使用了过期的值。</p>\n</li>\n<li><p>Vue 的依赖收集是全自动的，可以做到最小粒度的更新。</p>\n</li>\n</ul>\n<p>这都是基于 Vue 的响应式更新能力。</p>\n<p>有兴趣的同学可以通过下面的链接了解 React Hooks 的心智模型有多么沉重：</p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://zh-hans.reactjs.org/docs/hooks-faq.html%23from-classes-to-hooks\" >Hooks FAQ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/\" >使用 React Hooks 声明 setInterval <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\" >useEffect 完整指南 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><strong>3.5 那么它有缺点吗？</strong></p>\n<p><strong>3.5.1 ref 和 reactive 的区别</strong></p>\n<table data-draft-node=\"block\" data-draft-type=\"table\" data-size=\"normal\" data-row-style=\"normal\"><tbody><tr><th>ref</th><th>reactive</th></tr><tr><td>可以处理原始值，也可以处理对象</td><td>只能处理对象</td></tr><tr><td>需要加 .value，需要考虑自动解包</td><td>不需要加 .value</td></tr><tr><td>有单独的类型</td><td>和普通的对象没有什么区别，无法直接通过类型判断是否是响应式</td></tr><tr><td>可以使用解构赋值</td><td>不可以使用解构赋值，会丢失响应式</td></tr><tr><td></td><td>需要使用箭头函数包装才能使用 watch</td></tr></tbody></table>\n\n<p><strong>3.5.2 考虑响应式和 .value</strong></p>\n<p>虽然写 Composition API 不会有 <code>useEffect</code> 的困扰，还能使用完全一致的生命周期钩子函数，但是此次 Vue 把响应式 API 暴露给我们，实际上在编写代码的时候，需要考虑是否是响应式、是否是 ref 和响应式丢失的问题，也会带来一定的心智负担。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>面向生命周期编程 vs 面向业务逻辑编程</strong><br>Composition API 带来了组件逻辑抽取和复用的优化，抽取逻辑会变得非常简单，所以我们不必只在需要复用逻辑的时候才抽取函数，也可以单纯为了更好地组织代码去抽取函数，以此避免每个逻辑任务的代码都被选项切成了多个碎片分散在各处。<br>当然如果组件足够简单，我们还是可以只使用 Options API，以原来的习惯写代码。<strong>我可以在 Vue 2 中使用吗？</strong><br>可以的，官方团队提供了可供 Vue 2 使用的插件： <a class=\"link\"   href=\"https://link.zhihu.com/?target=https://github.com/vuejs/composition-api\" >@vue&#x2F;composition-api <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。<br>另外他们也计划让 Composition API 在 Vue 2.7 原生支持。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://v3.cn.vuejs.org/guide/composition-api-introduction.html%23%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E7%25BB%2584%25E5%2590%2588%25E5%25BC%258F-api\" >官方文档 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/68477600\" >Vue Function-based API RFC <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://link.zhihu.com/?target=https://www.bilibili.com/video/BV1x54y1V7H6/\" >VueUse 作者 Anthony Fu 分享可组合的 Vue <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/146097763\" >深入理解 Vue3 Reactivity API <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n"},{"url":"https://segmentfault.com/a/1190000014018604","title":"【转载】浏览器渲染机制","date":"2021-03-02T12:13:22.000Z","_content":"\n> 原文转自：https://segmentfault.com/a/1190000014018604\n\n### 线程和进程\n\n进程和线程的概念可以这样理解：\n\n进程是一个工厂，工厂有它的独立资源 -- 工厂之间相互独立 -- 线程是工厂中的工人，多个工人协作完成任务 -- 工厂内有一个或多个工人 -- 工人之间共享空间\n\n工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。\n\n![](https://segmentfault.com/img/bV6ZbY?w=834&h=742)\n\n进程是`cpu`资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存）  \n线程是`cpu`调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）\n\n### 浏览器是多进程的\n\n![](https://segmentfault.com/img/bV6RM7?w=864&h=471)\n\n浏览器是多进程的，每打开一个`tab`页，就相当于创建了一个独立的浏览器进程。\n\n### 浏览器包含的进程：\n\n1.  `Browser`进程：浏览器的主进程（负责协调，主控），只有一个，作用有：\n    \n    *   负责浏览器的界面显示，与用户交互，如前进，后退等\n    *   负责各个页面的管理，创建和销毁其它进程\n    *   将`Rendered`进程得到的内存中的`Bitmap`, 绘制到用户界面上\n    *   网络资源的管理，下载\n2.  第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。\n3.  `GPU`进程：最多一个，用于`3D`绘制等。\n4.  浏览器渲染进程（浏览器内核）（`Render`进程，内部是多线程的）：默认每个`Tab`页面一个进程，互不影响。主要作用为：\n    \n    *   页面渲染，脚本执行，事件处理等\n\n在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）\n\n### 浏览器多进程的优势\n\n*   避免单个`page crash`影响整个浏览器\n*   避免第三方插件`crash`影响整个浏览器\n*   多进程充分利用多核优势\n*   方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\n\n简单理解就是：如果浏览器是单进程的，某个`Tab`页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器；\n当然，内存等资源消耗也会更大，像空间换时间一样。\n\n## 重点是浏览器内核（渲染进程）\n\n对于普通的前端操作来说，最重要的**渲染进程**：页面的渲染，`js`的执行，事件的循环等都在这个进程内执行；\n**浏览器是多进程的，浏览器的渲染进程是多线程的；**\n\n### `GUI`渲染线程\n\n*   负责渲染浏览器界面，解析`HTML`,`CSS`, 构建`DOM`树和`RenderObject`树，布局和绘制等。\n*   当界面需要重绘或由于某种操作引发回流时，该线程就会执行。\n*   注意，**`GUI`渲染线程与`JS`引擎线程是互斥的**，当`JS`引擎执行时`GUI`线程会被挂起（相当于冻结了）,`GUI`更新会被保存在一个队列中等到`JS`引擎空闲时立即被执行。\n\n### `JS`引擎线程\n\n*   也称为`JS`内核，负责处理`JavaScript`脚本程序。（例如`V8`引擎）。\n*   `JS`引擎线程负责解析`JavaScript`脚本，运行代码。\n*   `JS`引擎一直等待着任务队列中任务的到来，然后加以处理，一个`Tab`页（`render`进程）中无论什么时候都只有一个`JS`线程在运行`JS`程序。\n*   同样注意，`GUI`渲染线程与`JS`引擎线程是互斥的，所以如果`JS`执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n### 事件触发线程\n\n*   归属于浏览器而不是`JS`引擎，用来控制事件循环（可以理解成`JS`引擎自己都忙不过来，需要浏览器另开线程协助）。\n*   当`JS`引擎执行代码块如`setTimeout`时（也可来自浏览器内核的其它线程，如鼠标点击，`AJAX`异步请求等），会将对应任务添加到事件线程中。\n*   当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待`JS`引擎的处理。\n*   注意，由于`JS`的单线程关系，所以这些待处理队列中的事件都得排队等待`JS`引擎处理（当`JS`引擎空闲时才会去执行）。\n\n### 定时触发器线程\n\n*   传说中的`setTimeout`和`setInterval`所在的线程\n*   浏览器定时计数器并不是由`JavaScript`引擎计数的，（因为`JavaScript`引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）\n*   因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待`JS`引擎空闲后执行）\n*   注意，`W3C`在`HTML`标准中规定，规定要求`setTimeout`中低于`4ms`的时间间隔算为`4ms`。\n\n### 异步`http`请求线程\n\n*   在`XMLHttpRequest`在连接后是通过浏览器新型一个线程请求\n*   将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由`JavaScript`引擎执行\n\n总结下来，渲染进程如下：\n\n![](https://segmentfault.com/img/bV6ZLo?w=655&h=608)\n\n### Browser 主进程和浏览器内核（渲染进程）的通信过程\n\n打开一个浏览器，可以看到：任务管理器出现了 2 个进程（一个主进程，一个是打开`Tab`页的渲染进程）；\n\n*   `Browser`主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）, 随后将该任务通过`RendererHost`接口传递给`Render`渲染进程\n*   `Render`渲染进程的`Renderer`接口收到消息，简单解释后，交给渲染线程`GUI`，然后开始渲染\n*   `GUI`渲染线程接收请求，加载网页并渲染网页，这其中可能需要`Browser`主进程获取资源和需要`GPU`进程来帮助渲染\n*   当然可能会有`JS`线程操作`DOM`（这可能会造成回流并重绘）\n*   最后`Render`渲染进程将结果传递给`Browser`主进程\n*   `Browser`主进程接收到结果并将结果绘制出来\n\n![](https://segmentfault.com/img/bV66KM?w=1034&h=560)\n\n### 浏览器内核（渲染进程）中线程之间的关系\n\n**GUI 渲染线程与 JS 引擎线程互斥**\n\n由于`JavaScript`是可操作`DOM`的，如果在修改这些元素属性同时渲染界面（即`JS`线程和`GUI`线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n\n因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当`JS`引擎执行时`GUI`线程会被挂起。`GUI`更新则会被保存在一个队列中等到`JS`引擎线程空闲时立即被执行。\n\n**JS 阻塞页面加载**\n\n从上述的互斥关系，可以推导出，`JS`如果执行时间过长就会阻塞页面。\n\n譬如，假设`JS`引擎正在进行巨量的计算，此时就算`GUI`有更新，也会被保存在队列中，要等到`JS`引擎空闲后执行。然后由于巨量计算，所以`JS`引擎可能很久很久才能空闲，肯定就会感觉很卡。\n\n所以，要尽量避免`JS`执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n**`css`加载是否会阻塞`dom`树渲染**\n\n这里说的是头部引入`css`的情况  \n首先，我们都知道：`css`是由单独的下载线程异步下载的。  \n然后还有几个现象：\n\n1.  `css`加载不会阻塞`DOM`树解析（异步加载时`dom`照常构建）\n2.  但会阻塞`render`树渲染（渲染时需要等`css`加载完毕，因为`render`树需要`css`信息）\n\n这可能也是浏览器的一种优化机制  \n因为你加载`css`的时候，可能会修改下面`DOM`节点的样式，如果`css`加载不阻塞`render`树渲染的话，那么当`css`加载完之后，`render`树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗  \n所以干脆把`DOM`树的结构先解析完，把可以做的工作做完，然后等`css`加载完之后，在根据最终的样式来渲染`render`树，这种做法确实对性能好一点。\n\n**`WebWorker`,`JS`的多线程？**\n\n前文中有提到`JS`引擎是单线程的，而且`JS`执行时间过长会阻塞页面，那么`JS`就真的对`cpu`密集型计算无能为力么？\n\n所以，后来`HTML5`中支持了`WebWorker`。\n\n这样理解下：\n\n创建`Worker`时，`JS`引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作`DOM`）  \n`JS`引擎线程与`worker`线程间通过特定的方式通信（`postMessage API`，需要通过序列化对象来与线程交互特定的数据）\n\n所以，如果有非常耗时的工作，请单独开一个`Worker`线程，这样里面不管如何翻天覆地都不会影响`JS`引擎主线程，只待计算出结果后，将结果通信给主线程即可，`perfect!`\n\n而且注意下，`JS`引擎是单线程的，这一点的本质仍然未改变，`Worker`可以理解是浏览器给`JS`引擎开的外挂，专门用来解决那些大量计算问题。\n\n**`WebWorker`与`SharedWorker`**\n\n既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）\n\n`WebWorker`只属于某个页面，不会和其他页面的`Render`进程（浏览器内核进程）共享  \n所以`Chrome`在`Render`进程中（每一个`Tab`页就是一个`render`进程）创建一个新的线程来运行`Worker`中的`JavaScript`程序。\n\n`SharedWorker`是浏览器所有页面共享的，不能采用与`Worker`同样的方式实现，因为它不隶属于某个`Render`进程，可以为多个`Render`进程共享使用  \n所以`Chrome`浏览器为`SharedWorker`单独创建一个进程来运行`JavaScript`程序，在浏览器中每个相同的`JavaScript`只存在一个`SharedWorker`进程，不管它被创建多少次。\n\n看到这里，应该就很容易明白了，本质上就是进程和线程的区别。`SharedWorker`由独立的进程管理，`WebWorker`只是属于`render`进程下的一个线程\n\n### 总结浏览器渲染流程\n\n浏览器输入`url`，浏览器主进程接管，开一个下载线程，然后进行`http`请求（略去`DNS`查询，`IP`寻址等等操作），然后等待响应，获取内容，随后将内容通过`RendererHost`接口转交给`Render`进程 -- 浏览器渲染流程开始\n\n浏览器内核拿到内容后，渲染大概可以划分为：\n\n1.  解析`html`建立`dom`要\n2.  解析`css`构建`render`树（将`css`代码解析成树形的数据结构，然后结合`dom`合并成`render`树）\n3.  布局`render`树（`Layout/reflow`）, 负责各元素尺寸，位置的计算\n4.  绘制`render`树（`paint`），绘制页面像素信息\n5.  浏览器会将各层的信息发送给`GPU`，`GPU`会将各层合成（`composite`）, 显示在屏幕上\n\n渲染完毕后就是`load`事件了，之后就是自己的`JS`逻辑处理了，略去了详细步骤。\n\n**`load`事件与`DOMContentLoaded`事件的先后**\n\n上面提到，渲染完毕后会触发`load`事件，那么你能分清楚`load`事件与`DOMContentLoaded`事件的先后么？\n\n很简单，知道它们的定义就可以了：\n\n当 `DOMContentLoaded` 事件触发时，仅当`DOM`加载完成，不包括样式表，图片。  \n（譬如如果有`async`加载的脚本就不一定完成）\n\n当 `onload` 事件触发时，页面上所有的`DOM`，样式表，脚本，图片都已经加载完成了。（渲染完毕了）\n\n所以，顺序是：`DOMContentLoaded` -> `load`\n\n### 普通图层和复合图层\n\n渲染步骤就提到了`composite`概念；浏览器渲染的图层一般包含两大类：普通图层以及复合图层。\n\n1.  普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）\n2.  `absolute`布局（`fixed`也一样），虽然可以脱离文档流，但它仍然属于默认复合层\n3.  可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）\n\n可以简单理解下：`GPU`中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒\n\n**如何变成复合图层（硬件加速）**\n\n将元素变成一个复合图层，就是传说中的硬件加速技术\n\n*   最常用的方式：`translate3d`,`translatez`\n*   `opacity`属性 / 过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\n*   `will-chang`属性（这个比较偏僻），一般配合`opacity`与`translate`使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\n*   `<video><iframe><canvas><webgl>`等元素\n*   其它，譬如以前的`flash`插件\n\n**`absolute`和硬件加速的区别**\n\n可以看到，`absolute`虽然可以脱离普通文档流，但是无法脱离默认复合层。\n\n所以，就算`absolute`中信息改变时不会改变普通文档流中`render`树，但是，浏览器最终绘制时，是整个复合层绘制的，所以`absolute`中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，`absolute`带来的绘制信息变化过大，资源消耗是非常严重的）\n\n而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）\n\n**复合图层的作用**\n\n一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。  \n但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。\n\n**硬件加速时请使用`index`**\n\n使用硬件加速时，尽可能的使用 index, 防止浏览器默认给后续的元素创建复合层渲染  \n具体的原理是：  \n`webkit CSS3`中，如果这个元素添加了硬件加速，并且`index`层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且`relective`或`absolute`属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能\n\n简单点理解，可以认为是一个隐式合成的概念：如果 a 是一个复合层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，这点需要特别注意\n\n## 从`Event Loop`谈`JS`的运行机制\n\n到此时，已经是属于浏览器页面初次渲染完毕后的事情，`JS`引擎的一些运行机制分析。主要是结合`Event Loop`来谈`JS`代码是如何执行的。  \n我们已经知道了`JS`引擎是单线程的，知道了`JS`引擎线程，事件触发线程，定时触发器线程。  \n然后还需要知道：\n\n*   `JS`分为同步任务和异步任务\n*   同步任务都在主线程上执行，形成一个执行栈\n*   主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件\n*   一旦执行栈中的所有同步任务执行完毕（此时`JS`引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。\n\n![](https://segmentfault.com/img/bV6WyG?w=716&h=506)\n\n看到这里，应该就可以理解了：为什么有时候`setTimeOut`推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以就必须等待，自然有误差。\n\n![](https://segmentfault.com/img/bV6WOP?w=703&h=509)\n\n主线程在运行时会产生执行栈，栈中的代码调用某些`api`时，它们会在事件队列中添加各种事件（当满足触发条件后，如`ajax`请求完毕）。而当栈中的代码执行完毕，就会去读取事件队列中的事件，去执行那些回调，如此循环。\n\n### 定时器\n\n上面事件循环机制的核心是：`JS`引擎线程和事件触发线程\n\n调用`setTimeout`后，是由定时器线程控制等到特定时间后添加到事件队列的，因为`JS`引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时。\n\n当使用`setTimout`或`setInterval`时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。\n\n如：\n\n```\nsetTimeout(()=>console.log('hello!),1000)\n//等 1000 毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行\n\nsetTimeout(()=>{\n    console.log('hello')\n},0)\nconsole.log('begin')\n\n```\n\n这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行。\n\n注意：\n\n1.  执行结果是：先`begin`，后`hello`\n2.  虽然代码的本意是`0`毫秒就推入事件队列，但是`W3C`在`HTML`标准中规定，规定要求`setTimeout`中低于`4ms`的时间间隔算为`4ms`\n3.  就算不等待`4ms`，就算假设`0`毫秒就推入事件队列，也会先执行`begin`（因为只能可执行栈内空了后才会主动读取事件队列）\n\n**`setInterval`**\n\n用`setTimeout`模拟定期计时和直接用`setInterval`是有区别的：\n\n*   每次`setTimeout`计时到后就会去执行，然后执行一段时间后才会继续`setTimeout`, 中间就多了误差\n*   而`setInterval`则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）\n\n而且`setInterval`有一些比较致命的问题：\n\n*   累积效应，如果`setInterval`代码在`setInterval`再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个`setInterval`的代码执行时间可能会比预期小（因为代码执行需要一定时间）\n*   比如你`ios`的`webview`，或者`safari`等浏览器中都有一人特点，在滚动的时候是不执行`JS`的，如果使用了`setInterval`，会发现在滚动结束后会执行多次由于滚动不执行`JS`积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（`setInterval`自带的优化，如果当前事件队列中有`setInterval`的回调，不会重复添加回调）\n*   而且把浏览器最小化显示等操作时，`setInterval`并不是不执行程序，它会把`setInterval`的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行\n\n所以，至于这么问题，一般认为的最佳方案是：用`setTimeout`模拟`setInterval`或者特殊场合直接用`requestAnimationFrame`\n\n### `Promise`时代的`microtask`与`macrotask`\n\n在`es6`盛行的现在，可以看下这题：\n\n```\nconsole.log('script start');\n\nsetTimeout(()=>{\n    console.log('setTimeout')\n},0);\n\nPromise.resolve()\n.then(()=>console.log('promise1'))\n.then(()=>console.log('promise2'))\n\nconsole.log('script end')\n\n//执行结果：\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n\n```\n\n因为`promise`有一个新的概念`microtask`. 或者可以说`JS`中分为两种任务：`macrotask`和`microtask`;  \n理解如下：\n\n*   `macrotask`（又叫宏任务）, 主代码块，`setTimeout`,`setInterval`等（可以看到，事件队列中的每一个事件都是一个`macrotask`）\n*   可以理解是每次执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\n*   第一个`macrotask`会从头到尾将这个任务执行完毕，不会执行其它\n*   浏览器为了能够使得`JS`内部`macrotask`与`DOM`任务能够有序的执行，会在一个`macrotask`执行结束后，在下一个`macrotask`执行开始前，对页面进行重新渲染（`task`-> 渲染 ->`task`->...）\n*   `microtask`（又叫微任务），`Promise`,`process.nextTick`等。\n*   可以理解是在当前`macrotask`执行结束后立即执行的任务\n*   也就是说在当前`macrotask`任务后，下一个`macrotask`之前，在渲染之前\n*   所以它的响应速度相比`setTimeout`(`setTimeout`是`macrotask`) 会更快因为无需等待渲染\n*   也就是说，在某一个`macrotask`执行完成后，就会将在它执行期间产生的所有`microtask`都执行完毕（在渲染前）\n\n注意：在`Node`环境下，`process.nextTick`的优先级高于`promise`. 也就是：在宏任务结束后会先执行微任务队列中的`nextTick`部分，然后才会执行微任务中的`promise`部分。\n\n另外，`setImmediate`则是规定：在下一次`Event Loop`（宏任务）时触发（所以它是属于优先级较高的宏任务），（`Node.js`文档中称，`setImmediate`指定的回调函数，总是排在`setTimeout`前面），所以`setImmediate`如果嵌套的话，是需要经过多个`Loop`才能完成的，而不会像`process.nextTick`一样没完没了。\n\n可以理解：\n\n*   `macrotask`中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护。\n*   `microtask`中的所有微任务都是添加到微任务队列中，等待当前`macrotask`执行完后执行，而这个队列由`JS`引擎线程维护。\n\n所以：\n\n*   执行一个宏任务（栈中没有就从事件队列中获取）\n*   执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n*   宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n*   当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染\n*   渲染完毕后，`JS`线程继续接管，开始下一个宏任务（从事件队列中获取）\n\n![](https://segmentfault.com/img/bV6YSS?w=506&h=570)\n\n![](https://segmentfault.com/img/bV7W88?w=479&h=457)\n\n**`new Promise`里的函数是直接执行的算做主程序里，而且`.then`后面的才会放到微任务中。**\n\n**另外，请注意下`Promise`的`polyfill`与官方版本的区别：**\n\n官方版本中，是标准的`microtask`形式  \n`polyfill`，一般都是通过`setTimeout`模拟的，所以是`macrotask`形式  \n请特别注意这两点区别\n\n注意，有一些浏览器执行结果不一样（因为它们可能把`microtask`当成`macrotask`来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）\n\n`Mutation Observer`可以用来实现`microtask`（它属于`microtask`，优先级小于`Promise`，一般是`Promise`不支持时才会这样做）\n\n它是`HTML5`中的新特性，作用是：监听一个`DOM`变动，当`DOM`对象树发生任何变动时，`Mutation Observer`会得到通知\n\n像以前的`Vue`源码中就是利用它来模拟`nextTick`的，具体原理是，创建一个`TextNode`并监听内容变化，然后要`nextTick`的时候去改一下这个节点的文本内容，如下：（`Vue`的源码，未修改）\n\n```\nvar counter=1\nvar observer=newMutationObserver(nextTickHandler)\nvar textNode=document.createTextNode(String(counter))\nobserver.observe(textNode,{characterData:true})\ntimerFunc=()=>{\n    counter=(counter+1)%2\n    textNode.data=String(counter)\n}\n\n```\n\n不过，现在的`Vue（2.5+）`的`nextTick`实现移除了`Mutation Observer`的方式（据说是兼容性原因），取而代之的是使用`MessageChannel`（当然，默认情况仍然是`Promise`，不支持才兼容的）。\n\n`MessageChannel`属于宏任务，优先级是：`setImmediate->MessageChannel->setTimeout`，所以`Vue（2.5+）`内部的`nextTick`与`2.4`及之前的实现是不一样的，需要注意下。","source":"_posts/ReprintBrowserRender.md","raw":"---\nurl: https://segmentfault.com/a/1190000014018604\ntitle: 【转载】浏览器渲染机制\ndate: 2021-03-02 20:13:22\ntags: [browser]\ncategories: [转载]\n---\n\n> 原文转自：https://segmentfault.com/a/1190000014018604\n\n### 线程和进程\n\n进程和线程的概念可以这样理解：\n\n进程是一个工厂，工厂有它的独立资源 -- 工厂之间相互独立 -- 线程是工厂中的工人，多个工人协作完成任务 -- 工厂内有一个或多个工人 -- 工人之间共享空间\n\n工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。\n\n![](https://segmentfault.com/img/bV6ZbY?w=834&h=742)\n\n进程是`cpu`资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存）  \n线程是`cpu`调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）\n\n### 浏览器是多进程的\n\n![](https://segmentfault.com/img/bV6RM7?w=864&h=471)\n\n浏览器是多进程的，每打开一个`tab`页，就相当于创建了一个独立的浏览器进程。\n\n### 浏览器包含的进程：\n\n1.  `Browser`进程：浏览器的主进程（负责协调，主控），只有一个，作用有：\n    \n    *   负责浏览器的界面显示，与用户交互，如前进，后退等\n    *   负责各个页面的管理，创建和销毁其它进程\n    *   将`Rendered`进程得到的内存中的`Bitmap`, 绘制到用户界面上\n    *   网络资源的管理，下载\n2.  第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。\n3.  `GPU`进程：最多一个，用于`3D`绘制等。\n4.  浏览器渲染进程（浏览器内核）（`Render`进程，内部是多线程的）：默认每个`Tab`页面一个进程，互不影响。主要作用为：\n    \n    *   页面渲染，脚本执行，事件处理等\n\n在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）\n\n### 浏览器多进程的优势\n\n*   避免单个`page crash`影响整个浏览器\n*   避免第三方插件`crash`影响整个浏览器\n*   多进程充分利用多核优势\n*   方便使用沙盒模型隔离插件等进程，提高浏览器稳定性\n\n简单理解就是：如果浏览器是单进程的，某个`Tab`页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器；\n当然，内存等资源消耗也会更大，像空间换时间一样。\n\n## 重点是浏览器内核（渲染进程）\n\n对于普通的前端操作来说，最重要的**渲染进程**：页面的渲染，`js`的执行，事件的循环等都在这个进程内执行；\n**浏览器是多进程的，浏览器的渲染进程是多线程的；**\n\n### `GUI`渲染线程\n\n*   负责渲染浏览器界面，解析`HTML`,`CSS`, 构建`DOM`树和`RenderObject`树，布局和绘制等。\n*   当界面需要重绘或由于某种操作引发回流时，该线程就会执行。\n*   注意，**`GUI`渲染线程与`JS`引擎线程是互斥的**，当`JS`引擎执行时`GUI`线程会被挂起（相当于冻结了）,`GUI`更新会被保存在一个队列中等到`JS`引擎空闲时立即被执行。\n\n### `JS`引擎线程\n\n*   也称为`JS`内核，负责处理`JavaScript`脚本程序。（例如`V8`引擎）。\n*   `JS`引擎线程负责解析`JavaScript`脚本，运行代码。\n*   `JS`引擎一直等待着任务队列中任务的到来，然后加以处理，一个`Tab`页（`render`进程）中无论什么时候都只有一个`JS`线程在运行`JS`程序。\n*   同样注意，`GUI`渲染线程与`JS`引擎线程是互斥的，所以如果`JS`执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n### 事件触发线程\n\n*   归属于浏览器而不是`JS`引擎，用来控制事件循环（可以理解成`JS`引擎自己都忙不过来，需要浏览器另开线程协助）。\n*   当`JS`引擎执行代码块如`setTimeout`时（也可来自浏览器内核的其它线程，如鼠标点击，`AJAX`异步请求等），会将对应任务添加到事件线程中。\n*   当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待`JS`引擎的处理。\n*   注意，由于`JS`的单线程关系，所以这些待处理队列中的事件都得排队等待`JS`引擎处理（当`JS`引擎空闲时才会去执行）。\n\n### 定时触发器线程\n\n*   传说中的`setTimeout`和`setInterval`所在的线程\n*   浏览器定时计数器并不是由`JavaScript`引擎计数的，（因为`JavaScript`引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）\n*   因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待`JS`引擎空闲后执行）\n*   注意，`W3C`在`HTML`标准中规定，规定要求`setTimeout`中低于`4ms`的时间间隔算为`4ms`。\n\n### 异步`http`请求线程\n\n*   在`XMLHttpRequest`在连接后是通过浏览器新型一个线程请求\n*   将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由`JavaScript`引擎执行\n\n总结下来，渲染进程如下：\n\n![](https://segmentfault.com/img/bV6ZLo?w=655&h=608)\n\n### Browser 主进程和浏览器内核（渲染进程）的通信过程\n\n打开一个浏览器，可以看到：任务管理器出现了 2 个进程（一个主进程，一个是打开`Tab`页的渲染进程）；\n\n*   `Browser`主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）, 随后将该任务通过`RendererHost`接口传递给`Render`渲染进程\n*   `Render`渲染进程的`Renderer`接口收到消息，简单解释后，交给渲染线程`GUI`，然后开始渲染\n*   `GUI`渲染线程接收请求，加载网页并渲染网页，这其中可能需要`Browser`主进程获取资源和需要`GPU`进程来帮助渲染\n*   当然可能会有`JS`线程操作`DOM`（这可能会造成回流并重绘）\n*   最后`Render`渲染进程将结果传递给`Browser`主进程\n*   `Browser`主进程接收到结果并将结果绘制出来\n\n![](https://segmentfault.com/img/bV66KM?w=1034&h=560)\n\n### 浏览器内核（渲染进程）中线程之间的关系\n\n**GUI 渲染线程与 JS 引擎线程互斥**\n\n由于`JavaScript`是可操作`DOM`的，如果在修改这些元素属性同时渲染界面（即`JS`线程和`GUI`线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n\n因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当`JS`引擎执行时`GUI`线程会被挂起。`GUI`更新则会被保存在一个队列中等到`JS`引擎线程空闲时立即被执行。\n\n**JS 阻塞页面加载**\n\n从上述的互斥关系，可以推导出，`JS`如果执行时间过长就会阻塞页面。\n\n譬如，假设`JS`引擎正在进行巨量的计算，此时就算`GUI`有更新，也会被保存在队列中，要等到`JS`引擎空闲后执行。然后由于巨量计算，所以`JS`引擎可能很久很久才能空闲，肯定就会感觉很卡。\n\n所以，要尽量避免`JS`执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n**`css`加载是否会阻塞`dom`树渲染**\n\n这里说的是头部引入`css`的情况  \n首先，我们都知道：`css`是由单独的下载线程异步下载的。  \n然后还有几个现象：\n\n1.  `css`加载不会阻塞`DOM`树解析（异步加载时`dom`照常构建）\n2.  但会阻塞`render`树渲染（渲染时需要等`css`加载完毕，因为`render`树需要`css`信息）\n\n这可能也是浏览器的一种优化机制  \n因为你加载`css`的时候，可能会修改下面`DOM`节点的样式，如果`css`加载不阻塞`render`树渲染的话，那么当`css`加载完之后，`render`树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗  \n所以干脆把`DOM`树的结构先解析完，把可以做的工作做完，然后等`css`加载完之后，在根据最终的样式来渲染`render`树，这种做法确实对性能好一点。\n\n**`WebWorker`,`JS`的多线程？**\n\n前文中有提到`JS`引擎是单线程的，而且`JS`执行时间过长会阻塞页面，那么`JS`就真的对`cpu`密集型计算无能为力么？\n\n所以，后来`HTML5`中支持了`WebWorker`。\n\n这样理解下：\n\n创建`Worker`时，`JS`引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作`DOM`）  \n`JS`引擎线程与`worker`线程间通过特定的方式通信（`postMessage API`，需要通过序列化对象来与线程交互特定的数据）\n\n所以，如果有非常耗时的工作，请单独开一个`Worker`线程，这样里面不管如何翻天覆地都不会影响`JS`引擎主线程，只待计算出结果后，将结果通信给主线程即可，`perfect!`\n\n而且注意下，`JS`引擎是单线程的，这一点的本质仍然未改变，`Worker`可以理解是浏览器给`JS`引擎开的外挂，专门用来解决那些大量计算问题。\n\n**`WebWorker`与`SharedWorker`**\n\n既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）\n\n`WebWorker`只属于某个页面，不会和其他页面的`Render`进程（浏览器内核进程）共享  \n所以`Chrome`在`Render`进程中（每一个`Tab`页就是一个`render`进程）创建一个新的线程来运行`Worker`中的`JavaScript`程序。\n\n`SharedWorker`是浏览器所有页面共享的，不能采用与`Worker`同样的方式实现，因为它不隶属于某个`Render`进程，可以为多个`Render`进程共享使用  \n所以`Chrome`浏览器为`SharedWorker`单独创建一个进程来运行`JavaScript`程序，在浏览器中每个相同的`JavaScript`只存在一个`SharedWorker`进程，不管它被创建多少次。\n\n看到这里，应该就很容易明白了，本质上就是进程和线程的区别。`SharedWorker`由独立的进程管理，`WebWorker`只是属于`render`进程下的一个线程\n\n### 总结浏览器渲染流程\n\n浏览器输入`url`，浏览器主进程接管，开一个下载线程，然后进行`http`请求（略去`DNS`查询，`IP`寻址等等操作），然后等待响应，获取内容，随后将内容通过`RendererHost`接口转交给`Render`进程 -- 浏览器渲染流程开始\n\n浏览器内核拿到内容后，渲染大概可以划分为：\n\n1.  解析`html`建立`dom`要\n2.  解析`css`构建`render`树（将`css`代码解析成树形的数据结构，然后结合`dom`合并成`render`树）\n3.  布局`render`树（`Layout/reflow`）, 负责各元素尺寸，位置的计算\n4.  绘制`render`树（`paint`），绘制页面像素信息\n5.  浏览器会将各层的信息发送给`GPU`，`GPU`会将各层合成（`composite`）, 显示在屏幕上\n\n渲染完毕后就是`load`事件了，之后就是自己的`JS`逻辑处理了，略去了详细步骤。\n\n**`load`事件与`DOMContentLoaded`事件的先后**\n\n上面提到，渲染完毕后会触发`load`事件，那么你能分清楚`load`事件与`DOMContentLoaded`事件的先后么？\n\n很简单，知道它们的定义就可以了：\n\n当 `DOMContentLoaded` 事件触发时，仅当`DOM`加载完成，不包括样式表，图片。  \n（譬如如果有`async`加载的脚本就不一定完成）\n\n当 `onload` 事件触发时，页面上所有的`DOM`，样式表，脚本，图片都已经加载完成了。（渲染完毕了）\n\n所以，顺序是：`DOMContentLoaded` -> `load`\n\n### 普通图层和复合图层\n\n渲染步骤就提到了`composite`概念；浏览器渲染的图层一般包含两大类：普通图层以及复合图层。\n\n1.  普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）\n2.  `absolute`布局（`fixed`也一样），虽然可以脱离文档流，但它仍然属于默认复合层\n3.  可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）\n\n可以简单理解下：`GPU`中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒\n\n**如何变成复合图层（硬件加速）**\n\n将元素变成一个复合图层，就是传说中的硬件加速技术\n\n*   最常用的方式：`translate3d`,`translatez`\n*   `opacity`属性 / 过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）\n*   `will-chang`属性（这个比较偏僻），一般配合`opacity`与`translate`使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）\n*   `<video><iframe><canvas><webgl>`等元素\n*   其它，譬如以前的`flash`插件\n\n**`absolute`和硬件加速的区别**\n\n可以看到，`absolute`虽然可以脱离普通文档流，但是无法脱离默认复合层。\n\n所以，就算`absolute`中信息改变时不会改变普通文档流中`render`树，但是，浏览器最终绘制时，是整个复合层绘制的，所以`absolute`中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，`absolute`带来的绘制信息变化过大，资源消耗是非常严重的）\n\n而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）\n\n**复合图层的作用**\n\n一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。  \n但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。\n\n**硬件加速时请使用`index`**\n\n使用硬件加速时，尽可能的使用 index, 防止浏览器默认给后续的元素创建复合层渲染  \n具体的原理是：  \n`webkit CSS3`中，如果这个元素添加了硬件加速，并且`index`层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且`relective`或`absolute`属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能\n\n简单点理解，可以认为是一个隐式合成的概念：如果 a 是一个复合层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，这点需要特别注意\n\n## 从`Event Loop`谈`JS`的运行机制\n\n到此时，已经是属于浏览器页面初次渲染完毕后的事情，`JS`引擎的一些运行机制分析。主要是结合`Event Loop`来谈`JS`代码是如何执行的。  \n我们已经知道了`JS`引擎是单线程的，知道了`JS`引擎线程，事件触发线程，定时触发器线程。  \n然后还需要知道：\n\n*   `JS`分为同步任务和异步任务\n*   同步任务都在主线程上执行，形成一个执行栈\n*   主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件\n*   一旦执行栈中的所有同步任务执行完毕（此时`JS`引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。\n\n![](https://segmentfault.com/img/bV6WyG?w=716&h=506)\n\n看到这里，应该就可以理解了：为什么有时候`setTimeOut`推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以就必须等待，自然有误差。\n\n![](https://segmentfault.com/img/bV6WOP?w=703&h=509)\n\n主线程在运行时会产生执行栈，栈中的代码调用某些`api`时，它们会在事件队列中添加各种事件（当满足触发条件后，如`ajax`请求完毕）。而当栈中的代码执行完毕，就会去读取事件队列中的事件，去执行那些回调，如此循环。\n\n### 定时器\n\n上面事件循环机制的核心是：`JS`引擎线程和事件触发线程\n\n调用`setTimeout`后，是由定时器线程控制等到特定时间后添加到事件队列的，因为`JS`引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时。\n\n当使用`setTimout`或`setInterval`时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。\n\n如：\n\n```\nsetTimeout(()=>console.log('hello!),1000)\n//等 1000 毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行\n\nsetTimeout(()=>{\n    console.log('hello')\n},0)\nconsole.log('begin')\n\n```\n\n这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行。\n\n注意：\n\n1.  执行结果是：先`begin`，后`hello`\n2.  虽然代码的本意是`0`毫秒就推入事件队列，但是`W3C`在`HTML`标准中规定，规定要求`setTimeout`中低于`4ms`的时间间隔算为`4ms`\n3.  就算不等待`4ms`，就算假设`0`毫秒就推入事件队列，也会先执行`begin`（因为只能可执行栈内空了后才会主动读取事件队列）\n\n**`setInterval`**\n\n用`setTimeout`模拟定期计时和直接用`setInterval`是有区别的：\n\n*   每次`setTimeout`计时到后就会去执行，然后执行一段时间后才会继续`setTimeout`, 中间就多了误差\n*   而`setInterval`则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）\n\n而且`setInterval`有一些比较致命的问题：\n\n*   累积效应，如果`setInterval`代码在`setInterval`再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个`setInterval`的代码执行时间可能会比预期小（因为代码执行需要一定时间）\n*   比如你`ios`的`webview`，或者`safari`等浏览器中都有一人特点，在滚动的时候是不执行`JS`的，如果使用了`setInterval`，会发现在滚动结束后会执行多次由于滚动不执行`JS`积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（`setInterval`自带的优化，如果当前事件队列中有`setInterval`的回调，不会重复添加回调）\n*   而且把浏览器最小化显示等操作时，`setInterval`并不是不执行程序，它会把`setInterval`的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行\n\n所以，至于这么问题，一般认为的最佳方案是：用`setTimeout`模拟`setInterval`或者特殊场合直接用`requestAnimationFrame`\n\n### `Promise`时代的`microtask`与`macrotask`\n\n在`es6`盛行的现在，可以看下这题：\n\n```\nconsole.log('script start');\n\nsetTimeout(()=>{\n    console.log('setTimeout')\n},0);\n\nPromise.resolve()\n.then(()=>console.log('promise1'))\n.then(()=>console.log('promise2'))\n\nconsole.log('script end')\n\n//执行结果：\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n\n```\n\n因为`promise`有一个新的概念`microtask`. 或者可以说`JS`中分为两种任务：`macrotask`和`microtask`;  \n理解如下：\n\n*   `macrotask`（又叫宏任务）, 主代码块，`setTimeout`,`setInterval`等（可以看到，事件队列中的每一个事件都是一个`macrotask`）\n*   可以理解是每次执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）\n*   第一个`macrotask`会从头到尾将这个任务执行完毕，不会执行其它\n*   浏览器为了能够使得`JS`内部`macrotask`与`DOM`任务能够有序的执行，会在一个`macrotask`执行结束后，在下一个`macrotask`执行开始前，对页面进行重新渲染（`task`-> 渲染 ->`task`->...）\n*   `microtask`（又叫微任务），`Promise`,`process.nextTick`等。\n*   可以理解是在当前`macrotask`执行结束后立即执行的任务\n*   也就是说在当前`macrotask`任务后，下一个`macrotask`之前，在渲染之前\n*   所以它的响应速度相比`setTimeout`(`setTimeout`是`macrotask`) 会更快因为无需等待渲染\n*   也就是说，在某一个`macrotask`执行完成后，就会将在它执行期间产生的所有`microtask`都执行完毕（在渲染前）\n\n注意：在`Node`环境下，`process.nextTick`的优先级高于`promise`. 也就是：在宏任务结束后会先执行微任务队列中的`nextTick`部分，然后才会执行微任务中的`promise`部分。\n\n另外，`setImmediate`则是规定：在下一次`Event Loop`（宏任务）时触发（所以它是属于优先级较高的宏任务），（`Node.js`文档中称，`setImmediate`指定的回调函数，总是排在`setTimeout`前面），所以`setImmediate`如果嵌套的话，是需要经过多个`Loop`才能完成的，而不会像`process.nextTick`一样没完没了。\n\n可以理解：\n\n*   `macrotask`中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护。\n*   `microtask`中的所有微任务都是添加到微任务队列中，等待当前`macrotask`执行完后执行，而这个队列由`JS`引擎线程维护。\n\n所以：\n\n*   执行一个宏任务（栈中没有就从事件队列中获取）\n*   执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n*   宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n*   当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染\n*   渲染完毕后，`JS`线程继续接管，开始下一个宏任务（从事件队列中获取）\n\n![](https://segmentfault.com/img/bV6YSS?w=506&h=570)\n\n![](https://segmentfault.com/img/bV7W88?w=479&h=457)\n\n**`new Promise`里的函数是直接执行的算做主程序里，而且`.then`后面的才会放到微任务中。**\n\n**另外，请注意下`Promise`的`polyfill`与官方版本的区别：**\n\n官方版本中，是标准的`microtask`形式  \n`polyfill`，一般都是通过`setTimeout`模拟的，所以是`macrotask`形式  \n请特别注意这两点区别\n\n注意，有一些浏览器执行结果不一样（因为它们可能把`microtask`当成`macrotask`来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）\n\n`Mutation Observer`可以用来实现`microtask`（它属于`microtask`，优先级小于`Promise`，一般是`Promise`不支持时才会这样做）\n\n它是`HTML5`中的新特性，作用是：监听一个`DOM`变动，当`DOM`对象树发生任何变动时，`Mutation Observer`会得到通知\n\n像以前的`Vue`源码中就是利用它来模拟`nextTick`的，具体原理是，创建一个`TextNode`并监听内容变化，然后要`nextTick`的时候去改一下这个节点的文本内容，如下：（`Vue`的源码，未修改）\n\n```\nvar counter=1\nvar observer=newMutationObserver(nextTickHandler)\nvar textNode=document.createTextNode(String(counter))\nobserver.observe(textNode,{characterData:true})\ntimerFunc=()=>{\n    counter=(counter+1)%2\n    textNode.data=String(counter)\n}\n\n```\n\n不过，现在的`Vue（2.5+）`的`nextTick`实现移除了`Mutation Observer`的方式（据说是兼容性原因），取而代之的是使用`MessageChannel`（当然，默认情况仍然是`Promise`，不支持才兼容的）。\n\n`MessageChannel`属于宏任务，优先级是：`setImmediate->MessageChannel->setTimeout`，所以`Vue（2.5+）`内部的`nextTick`与`2.4`及之前的实现是不一样的，需要注意下。","slug":"ReprintBrowserRender","published":1,"updated":"2023-03-02T13:23:34.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychf001b7gh8gvz52p8q","content":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://segmentfault.com/a/1190000014018604\" >https://segmentfault.com/a/1190000014018604 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><p>进程和线程的概念可以这样理解：</p>\n<p>进程是一个工厂，工厂有它的独立资源 – 工厂之间相互独立 – 线程是工厂中的工人，多个工人协作完成任务 – 工厂内有一个或多个工人 – 工人之间共享空间</p>\n<p>工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6ZbY?w=834&h=742\"\n                     \n                ></p>\n<p>进程是<code>cpu</code>资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存）<br>线程是<code>cpu</code>调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）</p>\n<h3 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6RM7?w=864&h=471\"\n                     \n                ></p>\n<p>浏览器是多进程的，每打开一个<code>tab</code>页，就相当于创建了一个独立的浏览器进程。</p>\n<h3 id=\"浏览器包含的进程：\"><a href=\"#浏览器包含的进程：\" class=\"headerlink\" title=\"浏览器包含的进程：\"></a>浏览器包含的进程：</h3><ol>\n<li><p><code>Browser</code>进程：浏览器的主进程（负责协调，主控），只有一个，作用有：</p>\n<ul>\n<li>负责浏览器的界面显示，与用户交互，如前进，后退等</li>\n<li>负责各个页面的管理，创建和销毁其它进程</li>\n<li>将<code>Rendered</code>进程得到的内存中的<code>Bitmap</code>, 绘制到用户界面上</li>\n<li>网络资源的管理，下载</li>\n</ul>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</p>\n</li>\n<li><p><code>GPU</code>进程：最多一个，用于<code>3D</code>绘制等。</p>\n</li>\n<li><p>浏览器渲染进程（浏览器内核）（<code>Render</code>进程，内部是多线程的）：默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为：</p>\n<ul>\n<li>页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ol>\n<p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p>\n<h3 id=\"浏览器多进程的优势\"><a href=\"#浏览器多进程的优势\" class=\"headerlink\" title=\"浏览器多进程的优势\"></a>浏览器多进程的优势</h3><ul>\n<li>避免单个<code>page crash</code>影响整个浏览器</li>\n<li>避免第三方插件<code>crash</code>影响整个浏览器</li>\n<li>多进程充分利用多核优势</li>\n<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>\n</ul>\n<p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器；<br>当然，内存等资源消耗也会更大，像空间换时间一样。</p>\n<h2 id=\"重点是浏览器内核（渲染进程）\"><a href=\"#重点是浏览器内核（渲染进程）\" class=\"headerlink\" title=\"重点是浏览器内核（渲染进程）\"></a>重点是浏览器内核（渲染进程）</h2><p>对于普通的前端操作来说，最重要的<strong>渲染进程</strong>：页面的渲染，<code>js</code>的执行，事件的循环等都在这个进程内执行；<br><strong>浏览器是多进程的，浏览器的渲染进程是多线程的；</strong></p>\n<h3 id=\"GUI渲染线程\"><a href=\"#GUI渲染线程\" class=\"headerlink\" title=\"GUI渲染线程\"></a><code>GUI</code>渲染线程</h3><ul>\n<li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>, 构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li>\n<li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li>\n<li>注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li>\n</ul>\n<h3 id=\"JS引擎线程\"><a href=\"#JS引擎线程\" class=\"headerlink\" title=\"JS引擎线程\"></a><code>JS</code>引擎线程</h3><ul>\n<li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code>引擎）。</li>\n<li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li>\n<li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</li>\n<li>同样注意，<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>\n</ul>\n<h3 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h3><ul>\n<li>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</li>\n<li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li>\n<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li>\n<li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li>\n</ul>\n<h3 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h3><ul>\n<li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li>\n<li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）</li>\n<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li>\n<li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li>\n</ul>\n<h3 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步<code>http</code>请求线程</h3><ul>\n<li>在<code>XMLHttpRequest</code>在连接后是通过浏览器新型一个线程请求</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由<code>JavaScript</code>引擎执行</li>\n</ul>\n<p>总结下来，渲染进程如下：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6ZLo?w=655&h=608\"\n                     \n                ></p>\n<h3 id=\"Browser-主进程和浏览器内核（渲染进程）的通信过程\"><a href=\"#Browser-主进程和浏览器内核（渲染进程）的通信过程\" class=\"headerlink\" title=\"Browser 主进程和浏览器内核（渲染进程）的通信过程\"></a>Browser 主进程和浏览器内核（渲染进程）的通信过程</h3><p>打开一个浏览器，可以看到：任务管理器出现了 2 个进程（一个主进程，一个是打开<code>Tab</code>页的渲染进程）；</p>\n<ul>\n<li><code>Browser</code>主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）, 随后将该任务通过<code>RendererHost</code>接口传递给<code>Render</code>渲染进程</li>\n<li><code>Render</code>渲染进程的<code>Renderer</code>接口收到消息，简单解释后，交给渲染线程<code>GUI</code>，然后开始渲染</li>\n<li><code>GUI</code>渲染线程接收请求，加载网页并渲染网页，这其中可能需要<code>Browser</code>主进程获取资源和需要<code>GPU</code>进程来帮助渲染</li>\n<li>当然可能会有<code>JS</code>线程操作<code>DOM</code>（这可能会造成回流并重绘）</li>\n<li>最后<code>Render</code>渲染进程将结果传递给<code>Browser</code>主进程</li>\n<li><code>Browser</code>主进程接收到结果并将结果绘制出来</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV66KM?w=1034&h=560\"\n                     \n                ></p>\n<h3 id=\"浏览器内核（渲染进程）中线程之间的关系\"><a href=\"#浏览器内核（渲染进程）中线程之间的关系\" class=\"headerlink\" title=\"浏览器内核（渲染进程）中线程之间的关系\"></a>浏览器内核（渲染进程）中线程之间的关系</h3><p><strong>GUI 渲染线程与 JS 引擎线程互斥</strong></p>\n<p>由于<code>JavaScript</code>是可操作<code>DOM</code>的，如果在修改这些元素属性同时渲染界面（即<code>JS</code>线程和<code>GUI</code>线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>\n<p>因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起。<code>GUI</code>更新则会被保存在一个队列中等到<code>JS</code>引擎线程空闲时立即被执行。</p>\n<p><strong>JS 阻塞页面加载</strong></p>\n<p>从上述的互斥关系，可以推导出，<code>JS</code>如果执行时间过长就会阻塞页面。</p>\n<p>譬如，假设<code>JS</code>引擎正在进行巨量的计算，此时就算<code>GUI</code>有更新，也会被保存在队列中，要等到<code>JS</code>引擎空闲后执行。然后由于巨量计算，所以<code>JS</code>引擎可能很久很久才能空闲，肯定就会感觉很卡。</p>\n<p>所以，要尽量避免<code>JS</code>执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>\n<p><strong><code>css</code>加载是否会阻塞<code>dom</code>树渲染</strong></p>\n<p>这里说的是头部引入<code>css</code>的情况<br>首先，我们都知道：<code>css</code>是由单独的下载线程异步下载的。<br>然后还有几个现象：</p>\n<ol>\n<li><code>css</code>加载不会阻塞<code>DOM</code>树解析（异步加载时<code>dom</code>照常构建）</li>\n<li>但会阻塞<code>render</code>树渲染（渲染时需要等<code>css</code>加载完毕，因为<code>render</code>树需要<code>css</code>信息）</li>\n</ol>\n<p>这可能也是浏览器的一种优化机制<br>因为你加载<code>css</code>的时候，可能会修改下面<code>DOM</code>节点的样式，如果<code>css</code>加载不阻塞<code>render</code>树渲染的话，那么当<code>css</code>加载完之后，<code>render</code>树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗<br>所以干脆把<code>DOM</code>树的结构先解析完，把可以做的工作做完，然后等<code>css</code>加载完之后，在根据最终的样式来渲染<code>render</code>树，这种做法确实对性能好一点。</p>\n<p><strong><code>WebWorker</code>,<code>JS</code>的多线程？</strong></p>\n<p>前文中有提到<code>JS</code>引擎是单线程的，而且<code>JS</code>执行时间过长会阻塞页面，那么<code>JS</code>就真的对<code>cpu</code>密集型计算无能为力么？</p>\n<p>所以，后来<code>HTML5</code>中支持了<code>WebWorker</code>。</p>\n<p>这样理解下：</p>\n<p>创建<code>Worker</code>时，<code>JS</code>引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作<code>DOM</code>）<br><code>JS</code>引擎线程与<code>worker</code>线程间通过特定的方式通信（<code>postMessage API</code>，需要通过序列化对象来与线程交互特定的数据）</p>\n<p>所以，如果有非常耗时的工作，请单独开一个<code>Worker</code>线程，这样里面不管如何翻天覆地都不会影响<code>JS</code>引擎主线程，只待计算出结果后，将结果通信给主线程即可，<code>perfect!</code></p>\n<p>而且注意下，<code>JS</code>引擎是单线程的，这一点的本质仍然未改变，<code>Worker</code>可以理解是浏览器给<code>JS</code>引擎开的外挂，专门用来解决那些大量计算问题。</p>\n<p><strong><code>WebWorker</code>与<code>SharedWorker</code></strong></p>\n<p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p>\n<p><code>WebWorker</code>只属于某个页面，不会和其他页面的<code>Render</code>进程（浏览器内核进程）共享<br>所以<code>Chrome</code>在<code>Render</code>进程中（每一个<code>Tab</code>页就是一个<code>render</code>进程）创建一个新的线程来运行<code>Worker</code>中的<code>JavaScript</code>程序。</p>\n<p><code>SharedWorker</code>是浏览器所有页面共享的，不能采用与<code>Worker</code>同样的方式实现，因为它不隶属于某个<code>Render</code>进程，可以为多个<code>Render</code>进程共享使用<br>所以<code>Chrome</code>浏览器为<code>SharedWorker</code>单独创建一个进程来运行<code>JavaScript</code>程序，在浏览器中每个相同的<code>JavaScript</code>只存在一个<code>SharedWorker</code>进程，不管它被创建多少次。</p>\n<p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。<code>SharedWorker</code>由独立的进程管理，<code>WebWorker</code>只是属于<code>render</code>进程下的一个线程</p>\n<h3 id=\"总结浏览器渲染流程\"><a href=\"#总结浏览器渲染流程\" class=\"headerlink\" title=\"总结浏览器渲染流程\"></a>总结浏览器渲染流程</h3><p>浏览器输入<code>url</code>，浏览器主进程接管，开一个下载线程，然后进行<code>http</code>请求（略去<code>DNS</code>查询，<code>IP</code>寻址等等操作），然后等待响应，获取内容，随后将内容通过<code>RendererHost</code>接口转交给<code>Render</code>进程 – 浏览器渲染流程开始</p>\n<p>浏览器内核拿到内容后，渲染大概可以划分为：</p>\n<ol>\n<li>解析<code>html</code>建立<code>dom</code>要</li>\n<li>解析<code>css</code>构建<code>render</code>树（将<code>css</code>代码解析成树形的数据结构，然后结合<code>dom</code>合并成<code>render</code>树）</li>\n<li>布局<code>render</code>树（<code>Layout/reflow</code>）, 负责各元素尺寸，位置的计算</li>\n<li>绘制<code>render</code>树（<code>paint</code>），绘制页面像素信息</li>\n<li>浏览器会将各层的信息发送给<code>GPU</code>，<code>GPU</code>会将各层合成（<code>composite</code>）, 显示在屏幕上</li>\n</ol>\n<p>渲染完毕后就是<code>load</code>事件了，之后就是自己的<code>JS</code>逻辑处理了，略去了详细步骤。</p>\n<p><strong><code>load</code>事件与<code>DOMContentLoaded</code>事件的先后</strong></p>\n<p>上面提到，渲染完毕后会触发<code>load</code>事件，那么你能分清楚<code>load</code>事件与<code>DOMContentLoaded</code>事件的先后么？</p>\n<p>很简单，知道它们的定义就可以了：</p>\n<p>当 <code>DOMContentLoaded</code> 事件触发时，仅当<code>DOM</code>加载完成，不包括样式表，图片。<br>（譬如如果有<code>async</code>加载的脚本就不一定完成）</p>\n<p>当 <code>onload</code> 事件触发时，页面上所有的<code>DOM</code>，样式表，脚本，图片都已经加载完成了。（渲染完毕了）</p>\n<p>所以，顺序是：<code>DOMContentLoaded</code> -&gt; <code>load</code></p>\n<h3 id=\"普通图层和复合图层\"><a href=\"#普通图层和复合图层\" class=\"headerlink\" title=\"普通图层和复合图层\"></a>普通图层和复合图层</h3><p>渲染步骤就提到了<code>composite</code>概念；浏览器渲染的图层一般包含两大类：普通图层以及复合图层。</p>\n<ol>\n<li>普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）</li>\n<li><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离文档流，但它仍然属于默认复合层</li>\n<li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li>\n</ol>\n<p>可以简单理解下：<code>GPU</code>中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p>\n<p><strong>如何变成复合图层（硬件加速）</strong></p>\n<p>将元素变成一个复合图层，就是传说中的硬件加速技术</p>\n<ul>\n<li>最常用的方式：<code>translate3d</code>,<code>translatez</code></li>\n<li><code>opacity</code>属性 &#x2F; 过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li>\n<li><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li>\n<li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li>\n<li>其它，譬如以前的<code>flash</code>插件</li>\n</ul>\n<p><strong><code>absolute</code>和硬件加速的区别</strong></p>\n<p>可以看到，<code>absolute</code>虽然可以脱离普通文档流，但是无法脱离默认复合层。</p>\n<p>所以，就算<code>absolute</code>中信息改变时不会改变普通文档流中<code>render</code>树，但是，浏览器最终绘制时，是整个复合层绘制的，所以<code>absolute</code>中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，<code>absolute</code>带来的绘制信息变化过大，资源消耗是非常严重的）</p>\n<p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p>\n<p><strong>复合图层的作用</strong></p>\n<p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。<br>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p>\n<p><strong>硬件加速时请使用<code>index</code></strong></p>\n<p>使用硬件加速时，尽可能的使用 index, 防止浏览器默认给后续的元素创建复合层渲染<br>具体的原理是：<br><code>webkit CSS3</code>中，如果这个元素添加了硬件加速，并且<code>index</code>层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且<code>relective</code>或<code>absolute</code>属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能</p>\n<p>简单点理解，可以认为是一个隐式合成的概念：如果 a 是一个复合层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，这点需要特别注意</p>\n<h2 id=\"从Event-Loop谈JS的运行机制\"><a href=\"#从Event-Loop谈JS的运行机制\" class=\"headerlink\" title=\"从Event Loop谈JS的运行机制\"></a>从<code>Event Loop</code>谈<code>JS</code>的运行机制</h2><p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，<code>JS</code>引擎的一些运行机制分析。主要是结合<code>Event Loop</code>来谈<code>JS</code>代码是如何执行的。<br>我们已经知道了<code>JS</code>引擎是单线程的，知道了<code>JS</code>引擎线程，事件触发线程，定时触发器线程。<br>然后还需要知道：</p>\n<ul>\n<li><code>JS</code>分为同步任务和异步任务</li>\n<li>同步任务都在主线程上执行，形成一个执行栈</li>\n<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</li>\n<li>一旦执行栈中的所有同步任务执行完毕（此时<code>JS</code>引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6WyG?w=716&h=506\"\n                     \n                ></p>\n<p>看到这里，应该就可以理解了：为什么有时候<code>setTimeOut</code>推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以就必须等待，自然有误差。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6WOP?w=703&h=509\"\n                     \n                ></p>\n<p>主线程在运行时会产生执行栈，栈中的代码调用某些<code>api</code>时，它们会在事件队列中添加各种事件（当满足触发条件后，如<code>ajax</code>请求完毕）。而当栈中的代码执行完毕，就会去读取事件队列中的事件，去执行那些回调，如此循环。</p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>上面事件循环机制的核心是：<code>JS</code>引擎线程和事件触发线程</p>\n<p>调用<code>setTimeout</code>后，是由定时器线程控制等到特定时间后添加到事件队列的，因为<code>JS</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时。</p>\n<p>当使用<code>setTimout</code>或<code>setInterval</code>时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p>\n<p>如：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(()=&gt;console.log(&#x27;hello!),1000)</span><br><span class=\"line\">//等 1000 毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;,0)</span><br><span class=\"line\">console.log(&#x27;begin&#x27;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行。</p>\n<p>注意：</p>\n<ol>\n<li>执行结果是：先<code>begin</code>，后<code>hello</code></li>\n<li>虽然代码的本意是<code>0</code>毫秒就推入事件队列，但是<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code></li>\n<li>就算不等待<code>4ms</code>，就算假设<code>0</code>毫秒就推入事件队列，也会先执行<code>begin</code>（因为只能可执行栈内空了后才会主动读取事件队列）</li>\n</ol>\n<p><strong><code>setInterval</code></strong></p>\n<p>用<code>setTimeout</code>模拟定期计时和直接用<code>setInterval</code>是有区别的：</p>\n<ul>\n<li>每次<code>setTimeout</code>计时到后就会去执行，然后执行一段时间后才会继续<code>setTimeout</code>, 中间就多了误差</li>\n<li>而<code>setInterval</code>则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</li>\n</ul>\n<p>而且<code>setInterval</code>有一些比较致命的问题：</p>\n<ul>\n<li>累积效应，如果<code>setInterval</code>代码在<code>setInterval</code>再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个<code>setInterval</code>的代码执行时间可能会比预期小（因为代码执行需要一定时间）</li>\n<li>比如你<code>ios</code>的<code>webview</code>，或者<code>safari</code>等浏览器中都有一人特点，在滚动的时候是不执行<code>JS</code>的，如果使用了<code>setInterval</code>，会发现在滚动结束后会执行多次由于滚动不执行<code>JS</code>积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（<code>setInterval</code>自带的优化，如果当前事件队列中有<code>setInterval</code>的回调，不会重复添加回调）</li>\n<li>而且把浏览器最小化显示等操作时，<code>setInterval</code>并不是不执行程序，它会把<code>setInterval</code>的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行</li>\n</ul>\n<p>所以，至于这么问题，一般认为的最佳方案是：用<code>setTimeout</code>模拟<code>setInterval</code>或者特殊场合直接用<code>requestAnimationFrame</code></p>\n<h3 id=\"Promise时代的microtask与macrotask\"><a href=\"#Promise时代的microtask与macrotask\" class=\"headerlink\" title=\"Promise时代的microtask与macrotask\"></a><code>Promise</code>时代的<code>microtask</code>与<code>macrotask</code></h3><p>在<code>es6</code>盛行的现在，可以看下这题：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;)</span><br><span class=\"line\">&#125;,0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve()</span><br><span class=\"line\">.then(()=&gt;console.log(&#x27;promise1&#x27;))</span><br><span class=\"line\">.then(()=&gt;console.log(&#x27;promise2&#x27;))</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">//执行结果：</span><br><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>因为<code>promise</code>有一个新的概念<code>microtask</code>. 或者可以说<code>JS</code>中分为两种任务：<code>macrotask</code>和<code>microtask</code>;<br>理解如下：</p>\n<ul>\n<li><code>macrotask</code>（又叫宏任务）, 主代码块，<code>setTimeout</code>,<code>setInterval</code>等（可以看到，事件队列中的每一个事件都是一个<code>macrotask</code>）</li>\n<li>可以理解是每次执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li>\n<li>第一个<code>macrotask</code>会从头到尾将这个任务执行完毕，不会执行其它</li>\n<li>浏览器为了能够使得<code>JS</code>内部<code>macrotask</code>与<code>DOM</code>任务能够有序的执行，会在一个<code>macrotask</code>执行结束后，在下一个<code>macrotask</code>执行开始前，对页面进行重新渲染（<code>task</code>-&gt; 渲染 -&gt;<code>task</code>-&gt;…）</li>\n<li><code>microtask</code>（又叫微任务），<code>Promise</code>,<code>process.nextTick</code>等。</li>\n<li>可以理解是在当前<code>macrotask</code>执行结束后立即执行的任务</li>\n<li>也就是说在当前<code>macrotask</code>任务后，下一个<code>macrotask</code>之前，在渲染之前</li>\n<li>所以它的响应速度相比<code>setTimeout</code>(<code>setTimeout</code>是<code>macrotask</code>) 会更快因为无需等待渲染</li>\n<li>也就是说，在某一个<code>macrotask</code>执行完成后，就会将在它执行期间产生的所有<code>microtask</code>都执行完毕（在渲染前）</li>\n</ul>\n<p>注意：在<code>Node</code>环境下，<code>process.nextTick</code>的优先级高于<code>promise</code>. 也就是：在宏任务结束后会先执行微任务队列中的<code>nextTick</code>部分，然后才会执行微任务中的<code>promise</code>部分。</p>\n<p>另外，<code>setImmediate</code>则是规定：在下一次<code>Event Loop</code>（宏任务）时触发（所以它是属于优先级较高的宏任务），（<code>Node.js</code>文档中称，<code>setImmediate</code>指定的回调函数，总是排在<code>setTimeout</code>前面），所以<code>setImmediate</code>如果嵌套的话，是需要经过多个<code>Loop</code>才能完成的，而不会像<code>process.nextTick</code>一样没完没了。</p>\n<p>可以理解：</p>\n<ul>\n<li><code>macrotask</code>中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护。</li>\n<li><code>microtask</code>中的所有微任务都是添加到微任务队列中，等待当前<code>macrotask</code>执行完后执行，而这个队列由<code>JS</code>引擎线程维护。</li>\n</ul>\n<p>所以：</p>\n<ul>\n<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>\n<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li>\n<li>渲染完毕后，<code>JS</code>线程继续接管，开始下一个宏任务（从事件队列中获取）</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6YSS?w=506&h=570\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV7W88?w=479&h=457\"\n                     \n                ></p>\n<p><strong><code>new Promise</code>里的函数是直接执行的算做主程序里，而且<code>.then</code>后面的才会放到微任务中。</strong></p>\n<p><strong>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</strong></p>\n<p>官方版本中，是标准的<code>microtask</code>形式<br><code>polyfill</code>，一般都是通过<code>setTimeout</code>模拟的，所以是<code>macrotask</code>形式<br>请特别注意这两点区别</p>\n<p>注意，有一些浏览器执行结果不一样（因为它们可能把<code>microtask</code>当成<code>macrotask</code>来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p>\n<p><code>Mutation Observer</code>可以用来实现<code>microtask</code>（它属于<code>microtask</code>，优先级小于<code>Promise</code>，一般是<code>Promise</code>不支持时才会这样做）</p>\n<p>它是<code>HTML5</code>中的新特性，作用是：监听一个<code>DOM</code>变动，当<code>DOM</code>对象树发生任何变动时，<code>Mutation Observer</code>会得到通知</p>\n<p>像以前的<code>Vue</code>源码中就是利用它来模拟<code>nextTick</code>的，具体原理是，创建一个<code>TextNode</code>并监听内容变化，然后要<code>nextTick</code>的时候去改一下这个节点的文本内容，如下：（<code>Vue</code>的源码，未修改）</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var counter=1</span><br><span class=\"line\">var observer=newMutationObserver(nextTickHandler)</span><br><span class=\"line\">var textNode=document.createTextNode(String(counter))</span><br><span class=\"line\">observer.observe(textNode,&#123;characterData:true&#125;)</span><br><span class=\"line\">timerFunc=()=&gt;&#123;</span><br><span class=\"line\">    counter=(counter+1)%2</span><br><span class=\"line\">    textNode.data=String(counter)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>不过，现在的<code>Vue（2.5+）</code>的<code>nextTick</code>实现移除了<code>Mutation Observer</code>的方式（据说是兼容性原因），取而代之的是使用<code>MessageChannel</code>（当然，默认情况仍然是<code>Promise</code>，不支持才兼容的）。</p>\n<p><code>MessageChannel</code>属于宏任务，优先级是：<code>setImmediate-&gt;MessageChannel-&gt;setTimeout</code>，所以<code>Vue（2.5+）</code>内部的<code>nextTick</code>与<code>2.4</code>及之前的实现是不一样的，需要注意下。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://segmentfault.com/a/1190000014018604\" >https://segmentfault.com/a/1190000014018604 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><p>进程和线程的概念可以这样理解：</p>\n<p>进程是一个工厂，工厂有它的独立资源 – 工厂之间相互独立 – 线程是工厂中的工人，多个工人协作完成任务 – 工厂内有一个或多个工人 – 工人之间共享空间</p>\n<p>工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6ZbY?w=834&h=742\"\n                     \n                ></p>\n<p>进程是<code>cpu</code>资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存）<br>线程是<code>cpu</code>调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）</p>\n<h3 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6RM7?w=864&h=471\"\n                     \n                ></p>\n<p>浏览器是多进程的，每打开一个<code>tab</code>页，就相当于创建了一个独立的浏览器进程。</p>\n<h3 id=\"浏览器包含的进程：\"><a href=\"#浏览器包含的进程：\" class=\"headerlink\" title=\"浏览器包含的进程：\"></a>浏览器包含的进程：</h3><ol>\n<li><p><code>Browser</code>进程：浏览器的主进程（负责协调，主控），只有一个，作用有：</p>\n<ul>\n<li>负责浏览器的界面显示，与用户交互，如前进，后退等</li>\n<li>负责各个页面的管理，创建和销毁其它进程</li>\n<li>将<code>Rendered</code>进程得到的内存中的<code>Bitmap</code>, 绘制到用户界面上</li>\n<li>网络资源的管理，下载</li>\n</ul>\n</li>\n<li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</p>\n</li>\n<li><p><code>GPU</code>进程：最多一个，用于<code>3D</code>绘制等。</p>\n</li>\n<li><p>浏览器渲染进程（浏览器内核）（<code>Render</code>进程，内部是多线程的）：默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为：</p>\n<ul>\n<li>页面渲染，脚本执行，事件处理等</li>\n</ul>\n</li>\n</ol>\n<p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p>\n<h3 id=\"浏览器多进程的优势\"><a href=\"#浏览器多进程的优势\" class=\"headerlink\" title=\"浏览器多进程的优势\"></a>浏览器多进程的优势</h3><ul>\n<li>避免单个<code>page crash</code>影响整个浏览器</li>\n<li>避免第三方插件<code>crash</code>影响整个浏览器</li>\n<li>多进程充分利用多核优势</li>\n<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>\n</ul>\n<p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器；<br>当然，内存等资源消耗也会更大，像空间换时间一样。</p>\n<h2 id=\"重点是浏览器内核（渲染进程）\"><a href=\"#重点是浏览器内核（渲染进程）\" class=\"headerlink\" title=\"重点是浏览器内核（渲染进程）\"></a>重点是浏览器内核（渲染进程）</h2><p>对于普通的前端操作来说，最重要的<strong>渲染进程</strong>：页面的渲染，<code>js</code>的执行，事件的循环等都在这个进程内执行；<br><strong>浏览器是多进程的，浏览器的渲染进程是多线程的；</strong></p>\n<h3 id=\"GUI渲染线程\"><a href=\"#GUI渲染线程\" class=\"headerlink\" title=\"GUI渲染线程\"></a><code>GUI</code>渲染线程</h3><ul>\n<li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>, 构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li>\n<li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li>\n<li>注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li>\n</ul>\n<h3 id=\"JS引擎线程\"><a href=\"#JS引擎线程\" class=\"headerlink\" title=\"JS引擎线程\"></a><code>JS</code>引擎线程</h3><ul>\n<li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code>引擎）。</li>\n<li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li>\n<li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</li>\n<li>同样注意，<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>\n</ul>\n<h3 id=\"事件触发线程\"><a href=\"#事件触发线程\" class=\"headerlink\" title=\"事件触发线程\"></a>事件触发线程</h3><ul>\n<li>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</li>\n<li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li>\n<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li>\n<li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li>\n</ul>\n<h3 id=\"定时触发器线程\"><a href=\"#定时触发器线程\" class=\"headerlink\" title=\"定时触发器线程\"></a>定时触发器线程</h3><ul>\n<li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li>\n<li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）</li>\n<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li>\n<li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li>\n</ul>\n<h3 id=\"异步http请求线程\"><a href=\"#异步http请求线程\" class=\"headerlink\" title=\"异步http请求线程\"></a>异步<code>http</code>请求线程</h3><ul>\n<li>在<code>XMLHttpRequest</code>在连接后是通过浏览器新型一个线程请求</li>\n<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由<code>JavaScript</code>引擎执行</li>\n</ul>\n<p>总结下来，渲染进程如下：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6ZLo?w=655&h=608\"\n                     \n                ></p>\n<h3 id=\"Browser-主进程和浏览器内核（渲染进程）的通信过程\"><a href=\"#Browser-主进程和浏览器内核（渲染进程）的通信过程\" class=\"headerlink\" title=\"Browser 主进程和浏览器内核（渲染进程）的通信过程\"></a>Browser 主进程和浏览器内核（渲染进程）的通信过程</h3><p>打开一个浏览器，可以看到：任务管理器出现了 2 个进程（一个主进程，一个是打开<code>Tab</code>页的渲染进程）；</p>\n<ul>\n<li><code>Browser</code>主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）, 随后将该任务通过<code>RendererHost</code>接口传递给<code>Render</code>渲染进程</li>\n<li><code>Render</code>渲染进程的<code>Renderer</code>接口收到消息，简单解释后，交给渲染线程<code>GUI</code>，然后开始渲染</li>\n<li><code>GUI</code>渲染线程接收请求，加载网页并渲染网页，这其中可能需要<code>Browser</code>主进程获取资源和需要<code>GPU</code>进程来帮助渲染</li>\n<li>当然可能会有<code>JS</code>线程操作<code>DOM</code>（这可能会造成回流并重绘）</li>\n<li>最后<code>Render</code>渲染进程将结果传递给<code>Browser</code>主进程</li>\n<li><code>Browser</code>主进程接收到结果并将结果绘制出来</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV66KM?w=1034&h=560\"\n                     \n                ></p>\n<h3 id=\"浏览器内核（渲染进程）中线程之间的关系\"><a href=\"#浏览器内核（渲染进程）中线程之间的关系\" class=\"headerlink\" title=\"浏览器内核（渲染进程）中线程之间的关系\"></a>浏览器内核（渲染进程）中线程之间的关系</h3><p><strong>GUI 渲染线程与 JS 引擎线程互斥</strong></p>\n<p>由于<code>JavaScript</code>是可操作<code>DOM</code>的，如果在修改这些元素属性同时渲染界面（即<code>JS</code>线程和<code>GUI</code>线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>\n<p>因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起。<code>GUI</code>更新则会被保存在一个队列中等到<code>JS</code>引擎线程空闲时立即被执行。</p>\n<p><strong>JS 阻塞页面加载</strong></p>\n<p>从上述的互斥关系，可以推导出，<code>JS</code>如果执行时间过长就会阻塞页面。</p>\n<p>譬如，假设<code>JS</code>引擎正在进行巨量的计算，此时就算<code>GUI</code>有更新，也会被保存在队列中，要等到<code>JS</code>引擎空闲后执行。然后由于巨量计算，所以<code>JS</code>引擎可能很久很久才能空闲，肯定就会感觉很卡。</p>\n<p>所以，要尽量避免<code>JS</code>执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>\n<p><strong><code>css</code>加载是否会阻塞<code>dom</code>树渲染</strong></p>\n<p>这里说的是头部引入<code>css</code>的情况<br>首先，我们都知道：<code>css</code>是由单独的下载线程异步下载的。<br>然后还有几个现象：</p>\n<ol>\n<li><code>css</code>加载不会阻塞<code>DOM</code>树解析（异步加载时<code>dom</code>照常构建）</li>\n<li>但会阻塞<code>render</code>树渲染（渲染时需要等<code>css</code>加载完毕，因为<code>render</code>树需要<code>css</code>信息）</li>\n</ol>\n<p>这可能也是浏览器的一种优化机制<br>因为你加载<code>css</code>的时候，可能会修改下面<code>DOM</code>节点的样式，如果<code>css</code>加载不阻塞<code>render</code>树渲染的话，那么当<code>css</code>加载完之后，<code>render</code>树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗<br>所以干脆把<code>DOM</code>树的结构先解析完，把可以做的工作做完，然后等<code>css</code>加载完之后，在根据最终的样式来渲染<code>render</code>树，这种做法确实对性能好一点。</p>\n<p><strong><code>WebWorker</code>,<code>JS</code>的多线程？</strong></p>\n<p>前文中有提到<code>JS</code>引擎是单线程的，而且<code>JS</code>执行时间过长会阻塞页面，那么<code>JS</code>就真的对<code>cpu</code>密集型计算无能为力么？</p>\n<p>所以，后来<code>HTML5</code>中支持了<code>WebWorker</code>。</p>\n<p>这样理解下：</p>\n<p>创建<code>Worker</code>时，<code>JS</code>引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作<code>DOM</code>）<br><code>JS</code>引擎线程与<code>worker</code>线程间通过特定的方式通信（<code>postMessage API</code>，需要通过序列化对象来与线程交互特定的数据）</p>\n<p>所以，如果有非常耗时的工作，请单独开一个<code>Worker</code>线程，这样里面不管如何翻天覆地都不会影响<code>JS</code>引擎主线程，只待计算出结果后，将结果通信给主线程即可，<code>perfect!</code></p>\n<p>而且注意下，<code>JS</code>引擎是单线程的，这一点的本质仍然未改变，<code>Worker</code>可以理解是浏览器给<code>JS</code>引擎开的外挂，专门用来解决那些大量计算问题。</p>\n<p><strong><code>WebWorker</code>与<code>SharedWorker</code></strong></p>\n<p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p>\n<p><code>WebWorker</code>只属于某个页面，不会和其他页面的<code>Render</code>进程（浏览器内核进程）共享<br>所以<code>Chrome</code>在<code>Render</code>进程中（每一个<code>Tab</code>页就是一个<code>render</code>进程）创建一个新的线程来运行<code>Worker</code>中的<code>JavaScript</code>程序。</p>\n<p><code>SharedWorker</code>是浏览器所有页面共享的，不能采用与<code>Worker</code>同样的方式实现，因为它不隶属于某个<code>Render</code>进程，可以为多个<code>Render</code>进程共享使用<br>所以<code>Chrome</code>浏览器为<code>SharedWorker</code>单独创建一个进程来运行<code>JavaScript</code>程序，在浏览器中每个相同的<code>JavaScript</code>只存在一个<code>SharedWorker</code>进程，不管它被创建多少次。</p>\n<p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。<code>SharedWorker</code>由独立的进程管理，<code>WebWorker</code>只是属于<code>render</code>进程下的一个线程</p>\n<h3 id=\"总结浏览器渲染流程\"><a href=\"#总结浏览器渲染流程\" class=\"headerlink\" title=\"总结浏览器渲染流程\"></a>总结浏览器渲染流程</h3><p>浏览器输入<code>url</code>，浏览器主进程接管，开一个下载线程，然后进行<code>http</code>请求（略去<code>DNS</code>查询，<code>IP</code>寻址等等操作），然后等待响应，获取内容，随后将内容通过<code>RendererHost</code>接口转交给<code>Render</code>进程 – 浏览器渲染流程开始</p>\n<p>浏览器内核拿到内容后，渲染大概可以划分为：</p>\n<ol>\n<li>解析<code>html</code>建立<code>dom</code>要</li>\n<li>解析<code>css</code>构建<code>render</code>树（将<code>css</code>代码解析成树形的数据结构，然后结合<code>dom</code>合并成<code>render</code>树）</li>\n<li>布局<code>render</code>树（<code>Layout/reflow</code>）, 负责各元素尺寸，位置的计算</li>\n<li>绘制<code>render</code>树（<code>paint</code>），绘制页面像素信息</li>\n<li>浏览器会将各层的信息发送给<code>GPU</code>，<code>GPU</code>会将各层合成（<code>composite</code>）, 显示在屏幕上</li>\n</ol>\n<p>渲染完毕后就是<code>load</code>事件了，之后就是自己的<code>JS</code>逻辑处理了，略去了详细步骤。</p>\n<p><strong><code>load</code>事件与<code>DOMContentLoaded</code>事件的先后</strong></p>\n<p>上面提到，渲染完毕后会触发<code>load</code>事件，那么你能分清楚<code>load</code>事件与<code>DOMContentLoaded</code>事件的先后么？</p>\n<p>很简单，知道它们的定义就可以了：</p>\n<p>当 <code>DOMContentLoaded</code> 事件触发时，仅当<code>DOM</code>加载完成，不包括样式表，图片。<br>（譬如如果有<code>async</code>加载的脚本就不一定完成）</p>\n<p>当 <code>onload</code> 事件触发时，页面上所有的<code>DOM</code>，样式表，脚本，图片都已经加载完成了。（渲染完毕了）</p>\n<p>所以，顺序是：<code>DOMContentLoaded</code> -&gt; <code>load</code></p>\n<h3 id=\"普通图层和复合图层\"><a href=\"#普通图层和复合图层\" class=\"headerlink\" title=\"普通图层和复合图层\"></a>普通图层和复合图层</h3><p>渲染步骤就提到了<code>composite</code>概念；浏览器渲染的图层一般包含两大类：普通图层以及复合图层。</p>\n<ol>\n<li>普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）</li>\n<li><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离文档流，但它仍然属于默认复合层</li>\n<li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li>\n</ol>\n<p>可以简单理解下：<code>GPU</code>中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p>\n<p><strong>如何变成复合图层（硬件加速）</strong></p>\n<p>将元素变成一个复合图层，就是传说中的硬件加速技术</p>\n<ul>\n<li>最常用的方式：<code>translate3d</code>,<code>translatez</code></li>\n<li><code>opacity</code>属性 &#x2F; 过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li>\n<li><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li>\n<li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li>\n<li>其它，譬如以前的<code>flash</code>插件</li>\n</ul>\n<p><strong><code>absolute</code>和硬件加速的区别</strong></p>\n<p>可以看到，<code>absolute</code>虽然可以脱离普通文档流，但是无法脱离默认复合层。</p>\n<p>所以，就算<code>absolute</code>中信息改变时不会改变普通文档流中<code>render</code>树，但是，浏览器最终绘制时，是整个复合层绘制的，所以<code>absolute</code>中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，<code>absolute</code>带来的绘制信息变化过大，资源消耗是非常严重的）</p>\n<p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p>\n<p><strong>复合图层的作用</strong></p>\n<p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。<br>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p>\n<p><strong>硬件加速时请使用<code>index</code></strong></p>\n<p>使用硬件加速时，尽可能的使用 index, 防止浏览器默认给后续的元素创建复合层渲染<br>具体的原理是：<br><code>webkit CSS3</code>中，如果这个元素添加了硬件加速，并且<code>index</code>层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且<code>relective</code>或<code>absolute</code>属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能</p>\n<p>简单点理解，可以认为是一个隐式合成的概念：如果 a 是一个复合层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，这点需要特别注意</p>\n<h2 id=\"从Event-Loop谈JS的运行机制\"><a href=\"#从Event-Loop谈JS的运行机制\" class=\"headerlink\" title=\"从Event Loop谈JS的运行机制\"></a>从<code>Event Loop</code>谈<code>JS</code>的运行机制</h2><p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，<code>JS</code>引擎的一些运行机制分析。主要是结合<code>Event Loop</code>来谈<code>JS</code>代码是如何执行的。<br>我们已经知道了<code>JS</code>引擎是单线程的，知道了<code>JS</code>引擎线程，事件触发线程，定时触发器线程。<br>然后还需要知道：</p>\n<ul>\n<li><code>JS</code>分为同步任务和异步任务</li>\n<li>同步任务都在主线程上执行，形成一个执行栈</li>\n<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</li>\n<li>一旦执行栈中的所有同步任务执行完毕（此时<code>JS</code>引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6WyG?w=716&h=506\"\n                     \n                ></p>\n<p>看到这里，应该就可以理解了：为什么有时候<code>setTimeOut</code>推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以就必须等待，自然有误差。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6WOP?w=703&h=509\"\n                     \n                ></p>\n<p>主线程在运行时会产生执行栈，栈中的代码调用某些<code>api</code>时，它们会在事件队列中添加各种事件（当满足触发条件后，如<code>ajax</code>请求完毕）。而当栈中的代码执行完毕，就会去读取事件队列中的事件，去执行那些回调，如此循环。</p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>上面事件循环机制的核心是：<code>JS</code>引擎线程和事件触发线程</p>\n<p>调用<code>setTimeout</code>后，是由定时器线程控制等到特定时间后添加到事件队列的，因为<code>JS</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时。</p>\n<p>当使用<code>setTimout</code>或<code>setInterval</code>时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(()=&gt;console.log(&#x27;hello!),1000)</span><br><span class=\"line\">//等 1000 毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;hello&#x27;)</span><br><span class=\"line\">&#125;,0)</span><br><span class=\"line\">console.log(&#x27;begin&#x27;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行。</p>\n<p>注意：</p>\n<ol>\n<li>执行结果是：先<code>begin</code>，后<code>hello</code></li>\n<li>虽然代码的本意是<code>0</code>毫秒就推入事件队列，但是<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code></li>\n<li>就算不等待<code>4ms</code>，就算假设<code>0</code>毫秒就推入事件队列，也会先执行<code>begin</code>（因为只能可执行栈内空了后才会主动读取事件队列）</li>\n</ol>\n<p><strong><code>setInterval</code></strong></p>\n<p>用<code>setTimeout</code>模拟定期计时和直接用<code>setInterval</code>是有区别的：</p>\n<ul>\n<li>每次<code>setTimeout</code>计时到后就会去执行，然后执行一段时间后才会继续<code>setTimeout</code>, 中间就多了误差</li>\n<li>而<code>setInterval</code>则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</li>\n</ul>\n<p>而且<code>setInterval</code>有一些比较致命的问题：</p>\n<ul>\n<li>累积效应，如果<code>setInterval</code>代码在<code>setInterval</code>再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个<code>setInterval</code>的代码执行时间可能会比预期小（因为代码执行需要一定时间）</li>\n<li>比如你<code>ios</code>的<code>webview</code>，或者<code>safari</code>等浏览器中都有一人特点，在滚动的时候是不执行<code>JS</code>的，如果使用了<code>setInterval</code>，会发现在滚动结束后会执行多次由于滚动不执行<code>JS</code>积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（<code>setInterval</code>自带的优化，如果当前事件队列中有<code>setInterval</code>的回调，不会重复添加回调）</li>\n<li>而且把浏览器最小化显示等操作时，<code>setInterval</code>并不是不执行程序，它会把<code>setInterval</code>的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行</li>\n</ul>\n<p>所以，至于这么问题，一般认为的最佳方案是：用<code>setTimeout</code>模拟<code>setInterval</code>或者特殊场合直接用<code>requestAnimationFrame</code></p>\n<h3 id=\"Promise时代的microtask与macrotask\"><a href=\"#Promise时代的microtask与macrotask\" class=\"headerlink\" title=\"Promise时代的microtask与macrotask\"></a><code>Promise</code>时代的<code>microtask</code>与<code>macrotask</code></h3><p>在<code>es6</code>盛行的现在，可以看下这题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#x27;script start&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&#x27;setTimeout&#x27;)</span><br><span class=\"line\">&#125;,0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve()</span><br><span class=\"line\">.then(()=&gt;console.log(&#x27;promise1&#x27;))</span><br><span class=\"line\">.then(()=&gt;console.log(&#x27;promise2&#x27;))</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#x27;script end&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">//执行结果：</span><br><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>因为<code>promise</code>有一个新的概念<code>microtask</code>. 或者可以说<code>JS</code>中分为两种任务：<code>macrotask</code>和<code>microtask</code>;<br>理解如下：</p>\n<ul>\n<li><code>macrotask</code>（又叫宏任务）, 主代码块，<code>setTimeout</code>,<code>setInterval</code>等（可以看到，事件队列中的每一个事件都是一个<code>macrotask</code>）</li>\n<li>可以理解是每次执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li>\n<li>第一个<code>macrotask</code>会从头到尾将这个任务执行完毕，不会执行其它</li>\n<li>浏览器为了能够使得<code>JS</code>内部<code>macrotask</code>与<code>DOM</code>任务能够有序的执行，会在一个<code>macrotask</code>执行结束后，在下一个<code>macrotask</code>执行开始前，对页面进行重新渲染（<code>task</code>-&gt; 渲染 -&gt;<code>task</code>-&gt;…）</li>\n<li><code>microtask</code>（又叫微任务），<code>Promise</code>,<code>process.nextTick</code>等。</li>\n<li>可以理解是在当前<code>macrotask</code>执行结束后立即执行的任务</li>\n<li>也就是说在当前<code>macrotask</code>任务后，下一个<code>macrotask</code>之前，在渲染之前</li>\n<li>所以它的响应速度相比<code>setTimeout</code>(<code>setTimeout</code>是<code>macrotask</code>) 会更快因为无需等待渲染</li>\n<li>也就是说，在某一个<code>macrotask</code>执行完成后，就会将在它执行期间产生的所有<code>microtask</code>都执行完毕（在渲染前）</li>\n</ul>\n<p>注意：在<code>Node</code>环境下，<code>process.nextTick</code>的优先级高于<code>promise</code>. 也就是：在宏任务结束后会先执行微任务队列中的<code>nextTick</code>部分，然后才会执行微任务中的<code>promise</code>部分。</p>\n<p>另外，<code>setImmediate</code>则是规定：在下一次<code>Event Loop</code>（宏任务）时触发（所以它是属于优先级较高的宏任务），（<code>Node.js</code>文档中称，<code>setImmediate</code>指定的回调函数，总是排在<code>setTimeout</code>前面），所以<code>setImmediate</code>如果嵌套的话，是需要经过多个<code>Loop</code>才能完成的，而不会像<code>process.nextTick</code>一样没完没了。</p>\n<p>可以理解：</p>\n<ul>\n<li><code>macrotask</code>中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护。</li>\n<li><code>microtask</code>中的所有微任务都是添加到微任务队列中，等待当前<code>macrotask</code>执行完后执行，而这个队列由<code>JS</code>引擎线程维护。</li>\n</ul>\n<p>所以：</p>\n<ul>\n<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>\n<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>\n<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li>\n<li>渲染完毕后，<code>JS</code>线程继续接管，开始下一个宏任务（从事件队列中获取）</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV6YSS?w=506&h=570\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://segmentfault.com/img/bV7W88?w=479&h=457\"\n                     \n                ></p>\n<p><strong><code>new Promise</code>里的函数是直接执行的算做主程序里，而且<code>.then</code>后面的才会放到微任务中。</strong></p>\n<p><strong>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</strong></p>\n<p>官方版本中，是标准的<code>microtask</code>形式<br><code>polyfill</code>，一般都是通过<code>setTimeout</code>模拟的，所以是<code>macrotask</code>形式<br>请特别注意这两点区别</p>\n<p>注意，有一些浏览器执行结果不一样（因为它们可能把<code>microtask</code>当成<code>macrotask</code>来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p>\n<p><code>Mutation Observer</code>可以用来实现<code>microtask</code>（它属于<code>microtask</code>，优先级小于<code>Promise</code>，一般是<code>Promise</code>不支持时才会这样做）</p>\n<p>它是<code>HTML5</code>中的新特性，作用是：监听一个<code>DOM</code>变动，当<code>DOM</code>对象树发生任何变动时，<code>Mutation Observer</code>会得到通知</p>\n<p>像以前的<code>Vue</code>源码中就是利用它来模拟<code>nextTick</code>的，具体原理是，创建一个<code>TextNode</code>并监听内容变化，然后要<code>nextTick</code>的时候去改一下这个节点的文本内容，如下：（<code>Vue</code>的源码，未修改）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var counter=1</span><br><span class=\"line\">var observer=newMutationObserver(nextTickHandler)</span><br><span class=\"line\">var textNode=document.createTextNode(String(counter))</span><br><span class=\"line\">observer.observe(textNode,&#123;characterData:true&#125;)</span><br><span class=\"line\">timerFunc=()=&gt;&#123;</span><br><span class=\"line\">    counter=(counter+1)%2</span><br><span class=\"line\">    textNode.data=String(counter)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>不过，现在的<code>Vue（2.5+）</code>的<code>nextTick</code>实现移除了<code>Mutation Observer</code>的方式（据说是兼容性原因），取而代之的是使用<code>MessageChannel</code>（当然，默认情况仍然是<code>Promise</code>，不支持才兼容的）。</p>\n<p><code>MessageChannel</code>属于宏任务，优先级是：<code>setImmediate-&gt;MessageChannel-&gt;setTimeout</code>，所以<code>Vue（2.5+）</code>内部的<code>nextTick</code>与<code>2.4</code>及之前的实现是不一样的，需要注意下。</p>\n"},{"url":"https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/","title":"【转载】TypeScript 装饰器完全指南 _ Disenchanted","date":"2022-11-02T12:34:17.000Z","_content":"> 原文转自：https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/\n\n\n装饰器让 TypeScript 的世界更好。 我们使用的许多库都基于这一强大特性构建，例如 [Angular](https://angular.io/) 和 [Nestjs](https://nestjs.com/)。 在这篇博客中我将介绍装饰器和它的许多细节。 我希望在读完这篇文章后，你可以理解何时和如何使用这一强的的特性。\n\n装饰器本质上是一种特殊的函数被应用在于：\n\n1.  类\n2.  类属性\n3.  类方法\n4.  类访问器\n5.  类方法的参数\n\n所以应用装饰器其实很像是组合一系列函数，类似于高阶函数和类。 通过装饰器我们可以轻松实现 [代理模式](https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F) 来使代码更简洁以及实现其它一些更有趣的能力。\n\n装饰器的语法十分简单，只需要在想使用的装饰器前加上`@`符号，装饰器就会被应用到目标上：\n\n```\nfunction simpleDecorator() {\n  console.log('---hi I am a decorator---')\n}\n\n@simpleDecorator\nclass A {}\n\n```\n\n一共有 5 种装饰器可被我们使用：\n\n1.  类装饰器\n2.  属性装饰器\n3.  方法装饰器\n4.  访问器装饰器\n5.  参数装饰器\n\n让我们来快速认识一下这五种装饰器：\n\n```\n@classDecorator\nclass Bird {\n\n  \n  @propertyDecorator\n  name: string;\n  \n  @methodDecorator\n  fly(\n    \n    @parameterDecorator\n      meters: number\n  ) {}\n  \n  @accessorDecorator\n  get egg() {}\n}\n\n```\n\n## 时机\n\n装饰器只在解释执行时应用一次，例如：\n\n```\nfunction f(C) {\n  console.log('apply decorator')\n  return C\n}\n\n@f\nclass A {}\n\n```\n\n这里的代码会在终端中打印`apply decorator`，即便我们其实并没有使用类 A。\n\n## 执行顺序\n\n不同类型的装饰器的执行顺序是明确定义的：\n\n1.  实例成员：\n\n参数装饰器 -> 方法 / 访问器 / 属性 装饰器 2. 静态成员：\n参数装饰器 -> 方法 / 访问器 / 属性 装饰器 3. 构造器：参数装饰器 4. 类装饰器\n\n例如，考虑以下代码：\n\n```\nfunction f(key: string): any {\n  console.log(\"evaluate: \", key);\n  return function () {\n    console.log(\"call: \", key);\n  };\n}\n\n@f(\"Class Decorator\")\nclass C {\n  @f(\"Static Property\")\n  static prop?: number;\n\n  @f(\"Static Method\")\n  static method(@f(\"Static Method Parameter\") foo) {}\n\n  constructor(@f(\"Constructor Parameter\") foo) {}\n\n  @f(\"Instance Method\")\n  method(@f(\"Instance Method Parameter\") foo) {}\n\n  @f(\"Instance Property\")\n  prop?: number;\n}\n\n```\n\n它将会打印出以下信息：\n\n```\nevaluate:  Instance Method\nevaluate:  Instance Method Parameter\ncall:  Instance Method Parameter\ncall:  Instance Method\nevaluate:  Instance Property\ncall:  Instance Property\nevaluate:  Static Property\ncall:  Static Property\nevaluate:  Static Method\nevaluate:  Static Method Parameter\ncall:  Static Method Parameter\ncall:  Static Method\nevaluate:  Class Decorator\nevaluate:  Constructor Parameter\ncall:  Constructor Parameter\ncall:  Class Decorator\n\n```\n\n你也许会注意到执行实例属性`prop`晚于实例方法`method` 然而执行静态属性`static prop`早于静态方法`static method`。 这是因为对于属性 / 方法 / 访问器装饰器而言，执行顺序取决于声明它们的顺序。\n\n然而，同一方法中不同参数的装饰器的执行顺序是相反的， 最后一个参数的装饰器会最先被执行：\n\n```\nfunction f(key: string): any {\n  console.log(\"evaluate: \", key);\n  return function () {\n    console.log(\"call: \", key);\n  };\n}\n\nclass C {\n  method(\n    @f(\"Parameter Foo\") foo,\n    @f(\"Parameter Bar\") bar\n  ) {}\n}\n\n```\n\n这里的代码打印出的结果为：\n\n```\nevaluate:  Parameter Foo\nevaluate:  Parameter Bar\ncall:  Parameter Bar\ncall:  Parameter Foo\n\n```\n\n## 多个装饰器的组合\n\n你可以对同一目标应用多个装饰器。它们的组合顺序为：\n\n1.  求值外层装饰器\n2.  求值内层装饰器\n3.  调用内层装饰器\n4.  调用外层装饰器\n\n例如：\n```\nfunction f(key: string) {\n  console.log(\"evaluate: \", key);\n  return function () {\n    console.log(\"call: \", key);\n  };\n}\n\nclass C {\n  @f(\"Outer Method\")\n  @f(\"Inner Method\")\n  method() {}\n}\n\n```\n\n这里的代码打印出的结果为：\n\n```\nevaluate: Outer Method\nevaluate: Inner Method\ncall: Inner Method\ncall: Outer Method\n\n```\n\n## 类装饰器\n\n类型声明：\n\n```\ntype ClassDecorator = <TFunction extends Function>\n  (target: TFunction) => TFunction | void;\n\n```\n\n*   @参数：\n    1.  `target`: 类的构造器。\n*   @返回：\n    如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。\n\n因此，类装饰器适合用于继承一个现有类并添加一些属性和方法。\n\n例如我们可以添加一个`toString`方法给所有的类来覆盖它原有的`toString`方法。\n\n```\ntype Consturctor = { new (...args: any[]): any };\n\nfunction toString<T extends Consturctor>(BaseClass: T) {\n  return class extends BaseClass {\n    toString() {\n      return JSON.stringify(this);\n    }\n  };\n}\n\n@toString\nclass C {\n  public foo = \"foo\";\n  public num = 24;\n}\n\nconsole.log(new C().toString())\n\n```\n\n遗憾的是装饰器并没有类型保护，这意味着：\n\n```\ndeclare function Blah<T>(target: T): T & {foo: number}\n\n@Blah\nclass Foo {\n  bar() {\n    return this.foo; \n  }\n}\n\nnew Foo().foo; \n\n```\n\n这是 [一个 TypeScript 的已知的缺陷](https://github.com/microsoft/TypeScript/issues/4881)。 目前我们能做的只有额外提供一个类用于提供类型信息：\n\n```\ndeclare function Blah<T>(target: T): T & {foo: number}\n\nclass Base {\n  foo: number;\n}\n\n@Blah\nclass Foo extends Base {\n  bar() {\n    return this.foo;\n  }\n}\n\nnew Foo().foo;\n\n```\n\n## 属性装饰器\n\n类型声明：\n\n```\ntype PropertyDecorator =\n  (target: Object, propertyKey: string | symbol) => void;\n\n```\n\n*   @参数：\n    1.  `target`: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。\n    2.  `propertyKey`: 属性的名称。\n*   @返回：\n    返回的结果将被忽略。\n\n除了用于收集信息外，属性装饰器也可以用来给类添加额外的方法和属性。 例如我们可以写一个装饰器来给某些属性添加监听器。\n\n```\nfunction capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction observable(target: any, key: string): any {\n  \n  const targetKey = \"on\" + capitalizeFirstLetter(key) + \"Change\";\n\n  target[targetKey] =\n    function (fn: (prev: any, next: any) => void) {\n      let prev = this[key];\n      Reflect.defineProperty(this, key, {\n        set(next) {\n          fn(prev, next);\n          prev = next;\n        }\n      })\n    };\n}\n\nclass C {\n  @observable\n  foo = -1;\n\n  @observable\n  bar = \"bar\";\n}\n\nconst c = new C();\n\nc.onFooChange((prev, next) => console.log(`prev: ${prev}, next: ${next}`))\nc.onBarChange((prev, next) => console.log(`prev: ${prev}, next: ${next}`))\n\nc.foo = 100; \nc.foo = -3.14; \nc.bar = \"baz\"; \nc.bar = \"sing\"; \n\n```\n\n## 方法装饰器\n\n类型声明：\n\n```\ntype MethodDecorator = <T>(\n  target: Object,\n  propertyKey: string | symbol,\n  descriptor: TypedPropertyDescriptor<T>\n) => TypedPropertyDescriptor<T> | void;\n\n```\n\n*   @参数：\n    1.  `target`: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。\n    2.  `propertyKey`: 属性的名称。\n    3.  `descriptor`: 属性的 [描述器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)。\n*   @返回： 如果返回了值，它会被用于替代属性的描述器。\n\n方法装饰器不同于属性装饰器的地方在于`descriptor`参数。 通过这个参数我们可以修改方法原本的实现，添加一些共用逻辑。 例如我们可以给一些方法添加打印输入与输出的能力：\n\n```\nfunction logger(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n\n  descriptor.value = function (...args) {\n    console.log('params: ', ...args);\n    const result = original.call(this, ...args);\n    console.log('result: ', result);\n    return result;\n  }\n}\n\nclass C {\n  @logger\n  add(x: number, y:number ) {\n    return x + y;\n  }\n}\n\nconst c = new C();\nc.add(1, 2);\n\n```\n\n## 访问器装饰器\n\n访问器装饰器总体上讲和方法装饰器很接近，唯一的区别在于描述器中有的 key 不同：\n\n方法装饰器的描述器的 key 为：\n\n*   `value`\n*   `writable`\n*   `enumerable`\n*   `configurable`\n\n访问器装饰器的描述器的 key 为：\n\n*   `get`\n*   `set`\n*   `enumerable`\n*   `configurable`\n\n例如，我们可以将某个属性设为不可变值：\n\n```\nfunction immutable(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.set;\n\n  descriptor.set = function (value: any) {\n    return original.call(this, { ...value })\n  }\n}\n\nclass C {\n  private _point = { x: 0, y: 0 }\n\n  @immutable\n  set point(value: { x: number, y: number }) {\n    this._point = value;\n  }\n\n  get point() {\n    return this._point;\n  }\n}\n\nconst c = new C();\nconst point = { x: 1, y: 1 }\nc.point = point;\n\nconsole.log(c.point === point)\n\n```\n\n## 参数装饰器\n\n类型声明：\n\n```\ntype ParameterDecorator = (\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number\n) => void;\n\n```\n\n*   @参数：\n    1.  `target`: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。\n    2.  `propertyKey`: 属性的名称 （注意是方法的名称，而不是参数的名称）。\n    3.  `parameterIndex`: 参数在方法中所处的位置的下标。\n*   @返回：  \n    返回的值将会被忽略。\n\n单独的参数装饰器能做的事情很有限，它一般都被用于记录可被其它装饰器使用的信息。\n\n对于一些复杂场景， 我们可能需要结合使用不同的装饰器。 例如如果我们不仅想给我们的接口添加静态检查，还想加上运行时检查的能力。\n\n我们可以用 3 个步骤来实现这个功能：\n\n1.  标记需要检查的参数 （因为参数装饰器先于方法装饰器执行）。\n2.  改变方法的`descriptor`的`value`的值，先运行参数检查器，如果失败就抛出异常。\n3.  运行原有的接口实现。\n\n以下是代码：\n```\ntype Validator = (x: any) => boolean;\n\nconst validateMap: Record<string, Validator[]> = {};\n\nfunction typedDecoratorFactory(validator: Validator): ParameterDecorator {\n  return (_, key, index) => {\n    const target = validateMap[key as string] ?? [];\n    target[index] = validator;\n    validateMap[key as string] = target;\n  }\n}\n\nfunction validate(_: Object, key: string, descriptor: PropertyDescriptor) {\n  const originalFn = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n\n    \n    const validatorList = validateMap[key];\n    if (validatorList) {\n      args.forEach((arg, index) => {\n        const validator = validatorList[index];\n\n        if (!validator) return;\n\n        const result = validator(arg);\n\n        if (!result) {\n          throw new Error(\n            `Failed for parameter: ${arg} of the index: ${index}`\n          );\n        }\n      });\n    }\n\n    \n    return originalFn.call(this, ...args);\n  }\n}\n\nconst isInt = typedDecoratorFactory((x) => Number.isInteger(x));\nconst isString = typedDecoratorFactory((x) => typeof x === 'string');\n\nclass C {\n  @validate\n  sayRepeat(@isString word: string, @isInt x: number) {\n    return Array(x).fill(word).join('');\n  }\n}\n\nconst c = new C();\nc.sayRepeat('hello', 2); \nc.sayRepeat('', 'lol' as any); \n\n```\n\n正如例子中展示的， 对我们来说同时理解不同种类装饰器的执行顺序和职责都很重要。\n\n严格地说，元数据和装饰器是 EcmaScript 中两个独立的部分。 然而，如果你想实现像是 [反射](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)) 这样的能力，你总是同时需要它们。\n\n如果我们回顾上一个例子，如果我们不想写各种不同的检查器呢？ 或者说，能否只写一个检查器能够通过我们编写的 TS 类型声明来自动运行类型检查？\n\n有了 [reflect-metadata](https://github.com/rbuckton/reflect-metadata) 的帮助， 我们可以获取编译期的类型。\n\n```\nimport 'reflect-metadata';\n\nfunction validate(\n  target: Object,\n  key: string,\n  descriptor: PropertyDescriptor\n) {\n  const originalFn = descriptor.value;\n\n  \n  const designParamTypes = Reflect\n    .getMetadata('design:paramtypes', target, key);\n\n  descriptor.value = function (...args: any[]) {\n    args.forEach((arg, index) => {\n\n      const paramType = designParamTypes[index];\n\n      const result = arg.constructor === paramType\n        || arg instanceof paramType;\n\n      if (!result) {\n        throw new Error(\n          `Failed for validating parameter: ${arg} of the index: ${index}`\n        );\n      }\n    });\n\n    return originalFn.call(this, ...args);\n  }\n}\n\nclass C {\n  @validate\n  sayRepeat(word: string, x: number) {\n    return Array(x).fill(word).join('');\n  }\n}\n\nconst c = new C();\nc.sayRepeat('hello', 2); \nc.sayRepeat('', 'lol' as any); \n\n```\n\n目前为止一共有三种编译期类型可以拿到：\n\n*   `design:type`: 属性的类型。\n*   `desin:paramtypes`: 方法的参数的类型。\n*   `design:returntype`: 方法的返回值的类型。\n\n这三种方式拿到的结果都是构造函数（例如`String`和`Number`）。规则是：\n\n*   number -> `Number`\n*   string -> `String`\n*   boolean -> `Boolean`\n*   void/null/never -> `undefined`\n*   Array/Tuple -> `Array`\n*   Class -> 类的构造函数\n*   Enum -> 如果是纯数字枚举则为`Number`, 否则是 `Object`\n*   Function -> `Function`\n*   其余都是`Object`\n\n现在我们可以对于何时使用装饰器得出结论， 在阅读上面的代码中你可能也有所感觉。\n\n我将例举一些常用的使用场景：\n\n*   Before/After 钩子。\n*   监听属性改变或者方法调用。\n*   对方法的参数做转换。\n*   添加额外的方法和属性。\n*   运行时类型检查。\n*   自动编解码。\n*   依赖注入。\n\n我希望读完这篇文章后，你可以找到装饰器的更多使用场景，并且用它来简化你的代码。","source":"_posts/ReprintTypscriptDecorator.md","raw":"---\nurl: https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/\ntitle: 【转载】TypeScript 装饰器完全指南 _ Disenchanted\ndate: 2022-11-02 20:34:17\ntags: [typescript]\ncategories: [转载]\n---\n> 原文转自：https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/\n\n\n装饰器让 TypeScript 的世界更好。 我们使用的许多库都基于这一强大特性构建，例如 [Angular](https://angular.io/) 和 [Nestjs](https://nestjs.com/)。 在这篇博客中我将介绍装饰器和它的许多细节。 我希望在读完这篇文章后，你可以理解何时和如何使用这一强的的特性。\n\n装饰器本质上是一种特殊的函数被应用在于：\n\n1.  类\n2.  类属性\n3.  类方法\n4.  类访问器\n5.  类方法的参数\n\n所以应用装饰器其实很像是组合一系列函数，类似于高阶函数和类。 通过装饰器我们可以轻松实现 [代理模式](https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F) 来使代码更简洁以及实现其它一些更有趣的能力。\n\n装饰器的语法十分简单，只需要在想使用的装饰器前加上`@`符号，装饰器就会被应用到目标上：\n\n```\nfunction simpleDecorator() {\n  console.log('---hi I am a decorator---')\n}\n\n@simpleDecorator\nclass A {}\n\n```\n\n一共有 5 种装饰器可被我们使用：\n\n1.  类装饰器\n2.  属性装饰器\n3.  方法装饰器\n4.  访问器装饰器\n5.  参数装饰器\n\n让我们来快速认识一下这五种装饰器：\n\n```\n@classDecorator\nclass Bird {\n\n  \n  @propertyDecorator\n  name: string;\n  \n  @methodDecorator\n  fly(\n    \n    @parameterDecorator\n      meters: number\n  ) {}\n  \n  @accessorDecorator\n  get egg() {}\n}\n\n```\n\n## 时机\n\n装饰器只在解释执行时应用一次，例如：\n\n```\nfunction f(C) {\n  console.log('apply decorator')\n  return C\n}\n\n@f\nclass A {}\n\n```\n\n这里的代码会在终端中打印`apply decorator`，即便我们其实并没有使用类 A。\n\n## 执行顺序\n\n不同类型的装饰器的执行顺序是明确定义的：\n\n1.  实例成员：\n\n参数装饰器 -> 方法 / 访问器 / 属性 装饰器 2. 静态成员：\n参数装饰器 -> 方法 / 访问器 / 属性 装饰器 3. 构造器：参数装饰器 4. 类装饰器\n\n例如，考虑以下代码：\n\n```\nfunction f(key: string): any {\n  console.log(\"evaluate: \", key);\n  return function () {\n    console.log(\"call: \", key);\n  };\n}\n\n@f(\"Class Decorator\")\nclass C {\n  @f(\"Static Property\")\n  static prop?: number;\n\n  @f(\"Static Method\")\n  static method(@f(\"Static Method Parameter\") foo) {}\n\n  constructor(@f(\"Constructor Parameter\") foo) {}\n\n  @f(\"Instance Method\")\n  method(@f(\"Instance Method Parameter\") foo) {}\n\n  @f(\"Instance Property\")\n  prop?: number;\n}\n\n```\n\n它将会打印出以下信息：\n\n```\nevaluate:  Instance Method\nevaluate:  Instance Method Parameter\ncall:  Instance Method Parameter\ncall:  Instance Method\nevaluate:  Instance Property\ncall:  Instance Property\nevaluate:  Static Property\ncall:  Static Property\nevaluate:  Static Method\nevaluate:  Static Method Parameter\ncall:  Static Method Parameter\ncall:  Static Method\nevaluate:  Class Decorator\nevaluate:  Constructor Parameter\ncall:  Constructor Parameter\ncall:  Class Decorator\n\n```\n\n你也许会注意到执行实例属性`prop`晚于实例方法`method` 然而执行静态属性`static prop`早于静态方法`static method`。 这是因为对于属性 / 方法 / 访问器装饰器而言，执行顺序取决于声明它们的顺序。\n\n然而，同一方法中不同参数的装饰器的执行顺序是相反的， 最后一个参数的装饰器会最先被执行：\n\n```\nfunction f(key: string): any {\n  console.log(\"evaluate: \", key);\n  return function () {\n    console.log(\"call: \", key);\n  };\n}\n\nclass C {\n  method(\n    @f(\"Parameter Foo\") foo,\n    @f(\"Parameter Bar\") bar\n  ) {}\n}\n\n```\n\n这里的代码打印出的结果为：\n\n```\nevaluate:  Parameter Foo\nevaluate:  Parameter Bar\ncall:  Parameter Bar\ncall:  Parameter Foo\n\n```\n\n## 多个装饰器的组合\n\n你可以对同一目标应用多个装饰器。它们的组合顺序为：\n\n1.  求值外层装饰器\n2.  求值内层装饰器\n3.  调用内层装饰器\n4.  调用外层装饰器\n\n例如：\n```\nfunction f(key: string) {\n  console.log(\"evaluate: \", key);\n  return function () {\n    console.log(\"call: \", key);\n  };\n}\n\nclass C {\n  @f(\"Outer Method\")\n  @f(\"Inner Method\")\n  method() {}\n}\n\n```\n\n这里的代码打印出的结果为：\n\n```\nevaluate: Outer Method\nevaluate: Inner Method\ncall: Inner Method\ncall: Outer Method\n\n```\n\n## 类装饰器\n\n类型声明：\n\n```\ntype ClassDecorator = <TFunction extends Function>\n  (target: TFunction) => TFunction | void;\n\n```\n\n*   @参数：\n    1.  `target`: 类的构造器。\n*   @返回：\n    如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。\n\n因此，类装饰器适合用于继承一个现有类并添加一些属性和方法。\n\n例如我们可以添加一个`toString`方法给所有的类来覆盖它原有的`toString`方法。\n\n```\ntype Consturctor = { new (...args: any[]): any };\n\nfunction toString<T extends Consturctor>(BaseClass: T) {\n  return class extends BaseClass {\n    toString() {\n      return JSON.stringify(this);\n    }\n  };\n}\n\n@toString\nclass C {\n  public foo = \"foo\";\n  public num = 24;\n}\n\nconsole.log(new C().toString())\n\n```\n\n遗憾的是装饰器并没有类型保护，这意味着：\n\n```\ndeclare function Blah<T>(target: T): T & {foo: number}\n\n@Blah\nclass Foo {\n  bar() {\n    return this.foo; \n  }\n}\n\nnew Foo().foo; \n\n```\n\n这是 [一个 TypeScript 的已知的缺陷](https://github.com/microsoft/TypeScript/issues/4881)。 目前我们能做的只有额外提供一个类用于提供类型信息：\n\n```\ndeclare function Blah<T>(target: T): T & {foo: number}\n\nclass Base {\n  foo: number;\n}\n\n@Blah\nclass Foo extends Base {\n  bar() {\n    return this.foo;\n  }\n}\n\nnew Foo().foo;\n\n```\n\n## 属性装饰器\n\n类型声明：\n\n```\ntype PropertyDecorator =\n  (target: Object, propertyKey: string | symbol) => void;\n\n```\n\n*   @参数：\n    1.  `target`: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。\n    2.  `propertyKey`: 属性的名称。\n*   @返回：\n    返回的结果将被忽略。\n\n除了用于收集信息外，属性装饰器也可以用来给类添加额外的方法和属性。 例如我们可以写一个装饰器来给某些属性添加监听器。\n\n```\nfunction capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction observable(target: any, key: string): any {\n  \n  const targetKey = \"on\" + capitalizeFirstLetter(key) + \"Change\";\n\n  target[targetKey] =\n    function (fn: (prev: any, next: any) => void) {\n      let prev = this[key];\n      Reflect.defineProperty(this, key, {\n        set(next) {\n          fn(prev, next);\n          prev = next;\n        }\n      })\n    };\n}\n\nclass C {\n  @observable\n  foo = -1;\n\n  @observable\n  bar = \"bar\";\n}\n\nconst c = new C();\n\nc.onFooChange((prev, next) => console.log(`prev: ${prev}, next: ${next}`))\nc.onBarChange((prev, next) => console.log(`prev: ${prev}, next: ${next}`))\n\nc.foo = 100; \nc.foo = -3.14; \nc.bar = \"baz\"; \nc.bar = \"sing\"; \n\n```\n\n## 方法装饰器\n\n类型声明：\n\n```\ntype MethodDecorator = <T>(\n  target: Object,\n  propertyKey: string | symbol,\n  descriptor: TypedPropertyDescriptor<T>\n) => TypedPropertyDescriptor<T> | void;\n\n```\n\n*   @参数：\n    1.  `target`: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。\n    2.  `propertyKey`: 属性的名称。\n    3.  `descriptor`: 属性的 [描述器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)。\n*   @返回： 如果返回了值，它会被用于替代属性的描述器。\n\n方法装饰器不同于属性装饰器的地方在于`descriptor`参数。 通过这个参数我们可以修改方法原本的实现，添加一些共用逻辑。 例如我们可以给一些方法添加打印输入与输出的能力：\n\n```\nfunction logger(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.value;\n\n  descriptor.value = function (...args) {\n    console.log('params: ', ...args);\n    const result = original.call(this, ...args);\n    console.log('result: ', result);\n    return result;\n  }\n}\n\nclass C {\n  @logger\n  add(x: number, y:number ) {\n    return x + y;\n  }\n}\n\nconst c = new C();\nc.add(1, 2);\n\n```\n\n## 访问器装饰器\n\n访问器装饰器总体上讲和方法装饰器很接近，唯一的区别在于描述器中有的 key 不同：\n\n方法装饰器的描述器的 key 为：\n\n*   `value`\n*   `writable`\n*   `enumerable`\n*   `configurable`\n\n访问器装饰器的描述器的 key 为：\n\n*   `get`\n*   `set`\n*   `enumerable`\n*   `configurable`\n\n例如，我们可以将某个属性设为不可变值：\n\n```\nfunction immutable(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const original = descriptor.set;\n\n  descriptor.set = function (value: any) {\n    return original.call(this, { ...value })\n  }\n}\n\nclass C {\n  private _point = { x: 0, y: 0 }\n\n  @immutable\n  set point(value: { x: number, y: number }) {\n    this._point = value;\n  }\n\n  get point() {\n    return this._point;\n  }\n}\n\nconst c = new C();\nconst point = { x: 1, y: 1 }\nc.point = point;\n\nconsole.log(c.point === point)\n\n```\n\n## 参数装饰器\n\n类型声明：\n\n```\ntype ParameterDecorator = (\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number\n) => void;\n\n```\n\n*   @参数：\n    1.  `target`: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。\n    2.  `propertyKey`: 属性的名称 （注意是方法的名称，而不是参数的名称）。\n    3.  `parameterIndex`: 参数在方法中所处的位置的下标。\n*   @返回：  \n    返回的值将会被忽略。\n\n单独的参数装饰器能做的事情很有限，它一般都被用于记录可被其它装饰器使用的信息。\n\n对于一些复杂场景， 我们可能需要结合使用不同的装饰器。 例如如果我们不仅想给我们的接口添加静态检查，还想加上运行时检查的能力。\n\n我们可以用 3 个步骤来实现这个功能：\n\n1.  标记需要检查的参数 （因为参数装饰器先于方法装饰器执行）。\n2.  改变方法的`descriptor`的`value`的值，先运行参数检查器，如果失败就抛出异常。\n3.  运行原有的接口实现。\n\n以下是代码：\n```\ntype Validator = (x: any) => boolean;\n\nconst validateMap: Record<string, Validator[]> = {};\n\nfunction typedDecoratorFactory(validator: Validator): ParameterDecorator {\n  return (_, key, index) => {\n    const target = validateMap[key as string] ?? [];\n    target[index] = validator;\n    validateMap[key as string] = target;\n  }\n}\n\nfunction validate(_: Object, key: string, descriptor: PropertyDescriptor) {\n  const originalFn = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n\n    \n    const validatorList = validateMap[key];\n    if (validatorList) {\n      args.forEach((arg, index) => {\n        const validator = validatorList[index];\n\n        if (!validator) return;\n\n        const result = validator(arg);\n\n        if (!result) {\n          throw new Error(\n            `Failed for parameter: ${arg} of the index: ${index}`\n          );\n        }\n      });\n    }\n\n    \n    return originalFn.call(this, ...args);\n  }\n}\n\nconst isInt = typedDecoratorFactory((x) => Number.isInteger(x));\nconst isString = typedDecoratorFactory((x) => typeof x === 'string');\n\nclass C {\n  @validate\n  sayRepeat(@isString word: string, @isInt x: number) {\n    return Array(x).fill(word).join('');\n  }\n}\n\nconst c = new C();\nc.sayRepeat('hello', 2); \nc.sayRepeat('', 'lol' as any); \n\n```\n\n正如例子中展示的， 对我们来说同时理解不同种类装饰器的执行顺序和职责都很重要。\n\n严格地说，元数据和装饰器是 EcmaScript 中两个独立的部分。 然而，如果你想实现像是 [反射](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)) 这样的能力，你总是同时需要它们。\n\n如果我们回顾上一个例子，如果我们不想写各种不同的检查器呢？ 或者说，能否只写一个检查器能够通过我们编写的 TS 类型声明来自动运行类型检查？\n\n有了 [reflect-metadata](https://github.com/rbuckton/reflect-metadata) 的帮助， 我们可以获取编译期的类型。\n\n```\nimport 'reflect-metadata';\n\nfunction validate(\n  target: Object,\n  key: string,\n  descriptor: PropertyDescriptor\n) {\n  const originalFn = descriptor.value;\n\n  \n  const designParamTypes = Reflect\n    .getMetadata('design:paramtypes', target, key);\n\n  descriptor.value = function (...args: any[]) {\n    args.forEach((arg, index) => {\n\n      const paramType = designParamTypes[index];\n\n      const result = arg.constructor === paramType\n        || arg instanceof paramType;\n\n      if (!result) {\n        throw new Error(\n          `Failed for validating parameter: ${arg} of the index: ${index}`\n        );\n      }\n    });\n\n    return originalFn.call(this, ...args);\n  }\n}\n\nclass C {\n  @validate\n  sayRepeat(word: string, x: number) {\n    return Array(x).fill(word).join('');\n  }\n}\n\nconst c = new C();\nc.sayRepeat('hello', 2); \nc.sayRepeat('', 'lol' as any); \n\n```\n\n目前为止一共有三种编译期类型可以拿到：\n\n*   `design:type`: 属性的类型。\n*   `desin:paramtypes`: 方法的参数的类型。\n*   `design:returntype`: 方法的返回值的类型。\n\n这三种方式拿到的结果都是构造函数（例如`String`和`Number`）。规则是：\n\n*   number -> `Number`\n*   string -> `String`\n*   boolean -> `Boolean`\n*   void/null/never -> `undefined`\n*   Array/Tuple -> `Array`\n*   Class -> 类的构造函数\n*   Enum -> 如果是纯数字枚举则为`Number`, 否则是 `Object`\n*   Function -> `Function`\n*   其余都是`Object`\n\n现在我们可以对于何时使用装饰器得出结论， 在阅读上面的代码中你可能也有所感觉。\n\n我将例举一些常用的使用场景：\n\n*   Before/After 钩子。\n*   监听属性改变或者方法调用。\n*   对方法的参数做转换。\n*   添加额外的方法和属性。\n*   运行时类型检查。\n*   自动编解码。\n*   依赖注入。\n\n我希望读完这篇文章后，你可以找到装饰器的更多使用场景，并且用它来简化你的代码。","slug":"ReprintTypscriptDecorator","published":1,"updated":"2023-03-02T12:41:23.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychg001f7gh87c6i3l57","content":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/\" >https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<p>装饰器让 TypeScript 的世界更好。 我们使用的许多库都基于这一强大特性构建，例如 <a class=\"link\"   href=\"https://angular.io/\" >Angular <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 和 <a class=\"link\"   href=\"https://nestjs.com/\" >Nestjs <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。 在这篇博客中我将介绍装饰器和它的许多细节。 我希望在读完这篇文章后，你可以理解何时和如何使用这一强的的特性。</p>\n<p>装饰器本质上是一种特殊的函数被应用在于：</p>\n<ol>\n<li>类</li>\n<li>类属性</li>\n<li>类方法</li>\n<li>类访问器</li>\n<li>类方法的参数</li>\n</ol>\n<p>所以应用装饰器其实很像是组合一系列函数，类似于高阶函数和类。 通过装饰器我们可以轻松实现 <a class=\"link\"   href=\"https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\" >代理模式 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 来使代码更简洁以及实现其它一些更有趣的能力。</p>\n<p>装饰器的语法十分简单，只需要在想使用的装饰器前加上<code>@</code>符号，装饰器就会被应用到目标上：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function simpleDecorator() &#123;</span><br><span class=\"line\">  console.log(&#x27;---hi I am a decorator---&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@simpleDecorator</span><br><span class=\"line\">class A &#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>一共有 5 种装饰器可被我们使用：</p>\n<ol>\n<li>类装饰器</li>\n<li>属性装饰器</li>\n<li>方法装饰器</li>\n<li>访问器装饰器</li>\n<li>参数装饰器</li>\n</ol>\n<p>让我们来快速认识一下这五种装饰器：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@classDecorator</span><br><span class=\"line\">class Bird &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  @propertyDecorator</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">  </span><br><span class=\"line\">  @methodDecorator</span><br><span class=\"line\">  fly(</span><br><span class=\"line\">    </span><br><span class=\"line\">    @parameterDecorator</span><br><span class=\"line\">      meters: number</span><br><span class=\"line\">  ) &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  @accessorDecorator</span><br><span class=\"line\">  get egg() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"时机\"><a href=\"#时机\" class=\"headerlink\" title=\"时机\"></a>时机</h2><p>装饰器只在解释执行时应用一次，例如：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(C) &#123;</span><br><span class=\"line\">  console.log(&#x27;apply decorator&#x27;)</span><br><span class=\"line\">  return C</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@f</span><br><span class=\"line\">class A &#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>这里的代码会在终端中打印<code>apply decorator</code>，即便我们其实并没有使用类 A。</p>\n<h2 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h2><p>不同类型的装饰器的执行顺序是明确定义的：</p>\n<ol>\n<li>实例成员：</li>\n</ol>\n<p>参数装饰器 -&gt; 方法 &#x2F; 访问器 &#x2F; 属性 装饰器 2. 静态成员：<br>参数装饰器 -&gt; 方法 &#x2F; 访问器 &#x2F; 属性 装饰器 3. 构造器：参数装饰器 4. 类装饰器</p>\n<p>例如，考虑以下代码：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(key: string): any &#123;</span><br><span class=\"line\">  console.log(&quot;evaluate: &quot;, key);</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(&quot;call: &quot;, key);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@f(&quot;Class Decorator&quot;)</span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @f(&quot;Static Property&quot;)</span><br><span class=\"line\">  static prop?: number;</span><br><span class=\"line\"></span><br><span class=\"line\">  @f(&quot;Static Method&quot;)</span><br><span class=\"line\">  static method(@f(&quot;Static Method Parameter&quot;) foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(@f(&quot;Constructor Parameter&quot;) foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @f(&quot;Instance Method&quot;)</span><br><span class=\"line\">  method(@f(&quot;Instance Method Parameter&quot;) foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @f(&quot;Instance Property&quot;)</span><br><span class=\"line\">  prop?: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>它将会打印出以下信息：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate:  Instance Method</span><br><span class=\"line\">evaluate:  Instance Method Parameter</span><br><span class=\"line\">call:  Instance Method Parameter</span><br><span class=\"line\">call:  Instance Method</span><br><span class=\"line\">evaluate:  Instance Property</span><br><span class=\"line\">call:  Instance Property</span><br><span class=\"line\">evaluate:  Static Property</span><br><span class=\"line\">call:  Static Property</span><br><span class=\"line\">evaluate:  Static Method</span><br><span class=\"line\">evaluate:  Static Method Parameter</span><br><span class=\"line\">call:  Static Method Parameter</span><br><span class=\"line\">call:  Static Method</span><br><span class=\"line\">evaluate:  Class Decorator</span><br><span class=\"line\">evaluate:  Constructor Parameter</span><br><span class=\"line\">call:  Constructor Parameter</span><br><span class=\"line\">call:  Class Decorator</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>你也许会注意到执行实例属性<code>prop</code>晚于实例方法<code>method</code> 然而执行静态属性<code>static prop</code>早于静态方法<code>static method</code>。 这是因为对于属性 &#x2F; 方法 &#x2F; 访问器装饰器而言，执行顺序取决于声明它们的顺序。</p>\n<p>然而，同一方法中不同参数的装饰器的执行顺序是相反的， 最后一个参数的装饰器会最先被执行：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(key: string): any &#123;</span><br><span class=\"line\">  console.log(&quot;evaluate: &quot;, key);</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(&quot;call: &quot;, key);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  method(</span><br><span class=\"line\">    @f(&quot;Parameter Foo&quot;) foo,</span><br><span class=\"line\">    @f(&quot;Parameter Bar&quot;) bar</span><br><span class=\"line\">  ) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>这里的代码打印出的结果为：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate:  Parameter Foo</span><br><span class=\"line\">evaluate:  Parameter Bar</span><br><span class=\"line\">call:  Parameter Bar</span><br><span class=\"line\">call:  Parameter Foo</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"多个装饰器的组合\"><a href=\"#多个装饰器的组合\" class=\"headerlink\" title=\"多个装饰器的组合\"></a>多个装饰器的组合</h2><p>你可以对同一目标应用多个装饰器。它们的组合顺序为：</p>\n<ol>\n<li>求值外层装饰器</li>\n<li>求值内层装饰器</li>\n<li>调用内层装饰器</li>\n<li>调用外层装饰器</li>\n</ol>\n<p>例如：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(key: string) &#123;</span><br><span class=\"line\">  console.log(&quot;evaluate: &quot;, key);</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(&quot;call: &quot;, key);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @f(&quot;Outer Method&quot;)</span><br><span class=\"line\">  @f(&quot;Inner Method&quot;)</span><br><span class=\"line\">  method() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>这里的代码打印出的结果为：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate: Outer Method</span><br><span class=\"line\">evaluate: Inner Method</span><br><span class=\"line\">call: Inner Method</span><br><span class=\"line\">call: Outer Method</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"类装饰器\"><a href=\"#类装饰器\" class=\"headerlink\" title=\"类装饰器\"></a>类装饰器</h2><p>类型声明：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ClassDecorator = &lt;TFunction extends Function&gt;</span><br><span class=\"line\">  (target: TFunction) =&gt; TFunction | void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 类的构造器。</li>\n</ol>\n</li>\n<li>@返回：<br>如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。</li>\n</ul>\n<p>因此，类装饰器适合用于继承一个现有类并添加一些属性和方法。</p>\n<p>例如我们可以添加一个<code>toString</code>方法给所有的类来覆盖它原有的<code>toString</code>方法。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Consturctor = &#123; new (...args: any[]): any &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function toString&lt;T extends Consturctor&gt;(BaseClass: T) &#123;</span><br><span class=\"line\">  return class extends BaseClass &#123;</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">      return JSON.stringify(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@toString</span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  public foo = &quot;foo&quot;;</span><br><span class=\"line\">  public num = 24;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new C().toString())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>遗憾的是装饰器并没有类型保护，这意味着：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare function Blah&lt;T&gt;(target: T): T &amp; &#123;foo: number&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Blah</span><br><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">  bar() &#123;</span><br><span class=\"line\">    return this.foo; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Foo().foo; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>这是 <a class=\"link\"   href=\"https://github.com/microsoft/TypeScript/issues/4881\" >一个 TypeScript 的已知的缺陷 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。 目前我们能做的只有额外提供一个类用于提供类型信息：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare function Blah&lt;T&gt;(target: T): T &amp; &#123;foo: number&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Base &#123;</span><br><span class=\"line\">  foo: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Blah</span><br><span class=\"line\">class Foo extends Base &#123;</span><br><span class=\"line\">  bar() &#123;</span><br><span class=\"line\">    return this.foo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Foo().foo;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h2><p>类型声明：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type PropertyDecorator =</span><br><span class=\"line\">  (target: Object, propertyKey: string | symbol) =&gt; void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>\n<li><code>propertyKey</code>: 属性的名称。</li>\n</ol>\n</li>\n<li>@返回：<br>返回的结果将被忽略。</li>\n</ul>\n<p>除了用于收集信息外，属性装饰器也可以用来给类添加额外的方法和属性。 例如我们可以写一个装饰器来给某些属性添加监听器。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function capitalizeFirstLetter(str: string) &#123;</span><br><span class=\"line\">  return str.charAt(0).toUpperCase() + str.slice(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function observable(target: any, key: string): any &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const targetKey = &quot;on&quot; + capitalizeFirstLetter(key) + &quot;Change&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">  target[targetKey] =</span><br><span class=\"line\">    function (fn: (prev: any, next: any) =&gt; void) &#123;</span><br><span class=\"line\">      let prev = this[key];</span><br><span class=\"line\">      Reflect.defineProperty(this, key, &#123;</span><br><span class=\"line\">        set(next) &#123;</span><br><span class=\"line\">          fn(prev, next);</span><br><span class=\"line\">          prev = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @observable</span><br><span class=\"line\">  foo = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  @observable</span><br><span class=\"line\">  bar = &quot;bar&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\"></span><br><span class=\"line\">c.onFooChange((prev, next) =&gt; console.log(`prev: $&#123;prev&#125;, next: $&#123;next&#125;`))</span><br><span class=\"line\">c.onBarChange((prev, next) =&gt; console.log(`prev: $&#123;prev&#125;, next: $&#123;next&#125;`))</span><br><span class=\"line\"></span><br><span class=\"line\">c.foo = 100; </span><br><span class=\"line\">c.foo = -3.14; </span><br><span class=\"line\">c.bar = &quot;baz&quot;; </span><br><span class=\"line\">c.bar = &quot;sing&quot;; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"方法装饰器\"><a href=\"#方法装饰器\" class=\"headerlink\" title=\"方法装饰器\"></a>方法装饰器</h2><p>类型声明：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type MethodDecorator = &lt;T&gt;(</span><br><span class=\"line\">  target: Object,</span><br><span class=\"line\">  propertyKey: string | symbol,</span><br><span class=\"line\">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span><br><span class=\"line\">) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>\n<li><code>propertyKey</code>: 属性的名称。</li>\n<li><code>descriptor</code>: 属性的 <a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\" >描述器 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。</li>\n</ol>\n</li>\n<li>@返回： 如果返回了值，它会被用于替代属性的描述器。</li>\n</ul>\n<p>方法装饰器不同于属性装饰器的地方在于<code>descriptor</code>参数。 通过这个参数我们可以修改方法原本的实现，添加一些共用逻辑。 例如我们可以给一些方法添加打印输入与输出的能力：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logger(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">  const original = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.value = function (...args) &#123;</span><br><span class=\"line\">    console.log(&#x27;params: &#x27;, ...args);</span><br><span class=\"line\">    const result = original.call(this, ...args);</span><br><span class=\"line\">    console.log(&#x27;result: &#x27;, result);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @logger</span><br><span class=\"line\">  add(x: number, y:number ) &#123;</span><br><span class=\"line\">    return x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">c.add(1, 2);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"访问器装饰器\"><a href=\"#访问器装饰器\" class=\"headerlink\" title=\"访问器装饰器\"></a>访问器装饰器</h2><p>访问器装饰器总体上讲和方法装饰器很接近，唯一的区别在于描述器中有的 key 不同：</p>\n<p>方法装饰器的描述器的 key 为：</p>\n<ul>\n<li><code>value</code></li>\n<li><code>writable</code></li>\n<li><code>enumerable</code></li>\n<li><code>configurable</code></li>\n</ul>\n<p>访问器装饰器的描述器的 key 为：</p>\n<ul>\n<li><code>get</code></li>\n<li><code>set</code></li>\n<li><code>enumerable</code></li>\n<li><code>configurable</code></li>\n</ul>\n<p>例如，我们可以将某个属性设为不可变值：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function immutable(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">  const original = descriptor.set;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.set = function (value: any) &#123;</span><br><span class=\"line\">    return original.call(this, &#123; ...value &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  private _point = &#123; x: 0, y: 0 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @immutable</span><br><span class=\"line\">  set point(value: &#123; x: number, y: number &#125;) &#123;</span><br><span class=\"line\">    this._point = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get point() &#123;</span><br><span class=\"line\">    return this._point;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">const point = &#123; x: 1, y: 1 &#125;</span><br><span class=\"line\">c.point = point;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c.point === point)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h2><p>类型声明：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ParameterDecorator = (</span><br><span class=\"line\">  target: Object,</span><br><span class=\"line\">  propertyKey: string | symbol,</span><br><span class=\"line\">  parameterIndex: number</span><br><span class=\"line\">) =&gt; void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>\n<li><code>propertyKey</code>: 属性的名称 （注意是方法的名称，而不是参数的名称）。</li>\n<li><code>parameterIndex</code>: 参数在方法中所处的位置的下标。</li>\n</ol>\n</li>\n<li>@返回：<br>返回的值将会被忽略。</li>\n</ul>\n<p>单独的参数装饰器能做的事情很有限，它一般都被用于记录可被其它装饰器使用的信息。</p>\n<p>对于一些复杂场景， 我们可能需要结合使用不同的装饰器。 例如如果我们不仅想给我们的接口添加静态检查，还想加上运行时检查的能力。</p>\n<p>我们可以用 3 个步骤来实现这个功能：</p>\n<ol>\n<li>标记需要检查的参数 （因为参数装饰器先于方法装饰器执行）。</li>\n<li>改变方法的<code>descriptor</code>的<code>value</code>的值，先运行参数检查器，如果失败就抛出异常。</li>\n<li>运行原有的接口实现。</li>\n</ol>\n<p>以下是代码：</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Validator = (x: any) =&gt; boolean;</span><br><span class=\"line\"></span><br><span class=\"line\">const validateMap: Record&lt;string, Validator[]&gt; = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function typedDecoratorFactory(validator: Validator): ParameterDecorator &#123;</span><br><span class=\"line\">  return (_, key, index) =&gt; &#123;</span><br><span class=\"line\">    const target = validateMap[key as string] ?? [];</span><br><span class=\"line\">    target[index] = validator;</span><br><span class=\"line\">    validateMap[key as string] = target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function validate(_: Object, key: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">  const originalFn = descriptor.value;</span><br><span class=\"line\">  descriptor.value = function(...args: any[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    const validatorList = validateMap[key];</span><br><span class=\"line\">    if (validatorList) &#123;</span><br><span class=\"line\">      args.forEach((arg, index) =&gt; &#123;</span><br><span class=\"line\">        const validator = validatorList[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!validator) return;</span><br><span class=\"line\"></span><br><span class=\"line\">        const result = validator(arg);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!result) &#123;</span><br><span class=\"line\">          throw new Error(</span><br><span class=\"line\">            `Failed for parameter: $&#123;arg&#125; of the index: $&#123;index&#125;`</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    return originalFn.call(this, ...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const isInt = typedDecoratorFactory((x) =&gt; Number.isInteger(x));</span><br><span class=\"line\">const isString = typedDecoratorFactory((x) =&gt; typeof x === &#x27;string&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @validate</span><br><span class=\"line\">  sayRepeat(@isString word: string, @isInt x: number) &#123;</span><br><span class=\"line\">    return Array(x).fill(word).join(&#x27;&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">c.sayRepeat(&#x27;hello&#x27;, 2); </span><br><span class=\"line\">c.sayRepeat(&#x27;&#x27;, &#x27;lol&#x27; as any); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>正如例子中展示的， 对我们来说同时理解不同种类装饰器的执行顺序和职责都很重要。</p>\n<p>严格地说，元数据和装饰器是 EcmaScript 中两个独立的部分。 然而，如果你想实现像是 <a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\" >反射 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 这样的能力，你总是同时需要它们。</p>\n<p>如果我们回顾上一个例子，如果我们不想写各种不同的检查器呢？ 或者说，能否只写一个检查器能够通过我们编写的 TS 类型声明来自动运行类型检查？</p>\n<p>有了 <a class=\"link\"   href=\"https://github.com/rbuckton/reflect-metadata\" >reflect-metadata <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 的帮助， 我们可以获取编译期的类型。</p>\n<div class=\"highlight-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x27;reflect-metadata&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function validate(</span><br><span class=\"line\">  target: Object,</span><br><span class=\"line\">  key: string,</span><br><span class=\"line\">  descriptor: PropertyDescriptor</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  const originalFn = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  const designParamTypes = Reflect</span><br><span class=\"line\">    .getMetadata(&#x27;design:paramtypes&#x27;, target, key);</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.value = function (...args: any[]) &#123;</span><br><span class=\"line\">    args.forEach((arg, index) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      const paramType = designParamTypes[index];</span><br><span class=\"line\"></span><br><span class=\"line\">      const result = arg.constructor === paramType</span><br><span class=\"line\">        || arg instanceof paramType;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (!result) &#123;</span><br><span class=\"line\">        throw new Error(</span><br><span class=\"line\">          `Failed for validating parameter: $&#123;arg&#125; of the index: $&#123;index&#125;`</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return originalFn.call(this, ...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @validate</span><br><span class=\"line\">  sayRepeat(word: string, x: number) &#123;</span><br><span class=\"line\">    return Array(x).fill(word).join(&#x27;&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">c.sayRepeat(&#x27;hello&#x27;, 2); </span><br><span class=\"line\">c.sayRepeat(&#x27;&#x27;, &#x27;lol&#x27; as any); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>目前为止一共有三种编译期类型可以拿到：</p>\n<ul>\n<li><code>design:type</code>: 属性的类型。</li>\n<li><code>desin:paramtypes</code>: 方法的参数的类型。</li>\n<li><code>design:returntype</code>: 方法的返回值的类型。</li>\n</ul>\n<p>这三种方式拿到的结果都是构造函数（例如<code>String</code>和<code>Number</code>）。规则是：</p>\n<ul>\n<li>number -&gt; <code>Number</code></li>\n<li>string -&gt; <code>String</code></li>\n<li>boolean -&gt; <code>Boolean</code></li>\n<li>void&#x2F;null&#x2F;never -&gt; <code>undefined</code></li>\n<li>Array&#x2F;Tuple -&gt; <code>Array</code></li>\n<li>Class -&gt; 类的构造函数</li>\n<li>Enum -&gt; 如果是纯数字枚举则为<code>Number</code>, 否则是 <code>Object</code></li>\n<li>Function -&gt; <code>Function</code></li>\n<li>其余都是<code>Object</code></li>\n</ul>\n<p>现在我们可以对于何时使用装饰器得出结论， 在阅读上面的代码中你可能也有所感觉。</p>\n<p>我将例举一些常用的使用场景：</p>\n<ul>\n<li>Before&#x2F;After 钩子。</li>\n<li>监听属性改变或者方法调用。</li>\n<li>对方法的参数做转换。</li>\n<li>添加额外的方法和属性。</li>\n<li>运行时类型检查。</li>\n<li>自动编解码。</li>\n<li>依赖注入。</li>\n</ul>\n<p>我希望读完这篇文章后，你可以找到装饰器的更多使用场景，并且用它来简化你的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文转自：<a class=\"link\"   href=\"https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/\" >https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/ <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n<p>装饰器让 TypeScript 的世界更好。 我们使用的许多库都基于这一强大特性构建，例如 <a class=\"link\"   href=\"https://angular.io/\" >Angular <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 和 <a class=\"link\"   href=\"https://nestjs.com/\" >Nestjs <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。 在这篇博客中我将介绍装饰器和它的许多细节。 我希望在读完这篇文章后，你可以理解何时和如何使用这一强的的特性。</p>\n<p>装饰器本质上是一种特殊的函数被应用在于：</p>\n<ol>\n<li>类</li>\n<li>类属性</li>\n<li>类方法</li>\n<li>类访问器</li>\n<li>类方法的参数</li>\n</ol>\n<p>所以应用装饰器其实很像是组合一系列函数，类似于高阶函数和类。 通过装饰器我们可以轻松实现 <a class=\"link\"   href=\"https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\" >代理模式 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 来使代码更简洁以及实现其它一些更有趣的能力。</p>\n<p>装饰器的语法十分简单，只需要在想使用的装饰器前加上<code>@</code>符号，装饰器就会被应用到目标上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function simpleDecorator() &#123;</span><br><span class=\"line\">  console.log(&#x27;---hi I am a decorator---&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@simpleDecorator</span><br><span class=\"line\">class A &#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>一共有 5 种装饰器可被我们使用：</p>\n<ol>\n<li>类装饰器</li>\n<li>属性装饰器</li>\n<li>方法装饰器</li>\n<li>访问器装饰器</li>\n<li>参数装饰器</li>\n</ol>\n<p>让我们来快速认识一下这五种装饰器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@classDecorator</span><br><span class=\"line\">class Bird &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  @propertyDecorator</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">  </span><br><span class=\"line\">  @methodDecorator</span><br><span class=\"line\">  fly(</span><br><span class=\"line\">    </span><br><span class=\"line\">    @parameterDecorator</span><br><span class=\"line\">      meters: number</span><br><span class=\"line\">  ) &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  @accessorDecorator</span><br><span class=\"line\">  get egg() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时机\"><a href=\"#时机\" class=\"headerlink\" title=\"时机\"></a>时机</h2><p>装饰器只在解释执行时应用一次，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(C) &#123;</span><br><span class=\"line\">  console.log(&#x27;apply decorator&#x27;)</span><br><span class=\"line\">  return C</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@f</span><br><span class=\"line\">class A &#123;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的代码会在终端中打印<code>apply decorator</code>，即便我们其实并没有使用类 A。</p>\n<h2 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h2><p>不同类型的装饰器的执行顺序是明确定义的：</p>\n<ol>\n<li>实例成员：</li>\n</ol>\n<p>参数装饰器 -&gt; 方法 &#x2F; 访问器 &#x2F; 属性 装饰器 2. 静态成员：<br>参数装饰器 -&gt; 方法 &#x2F; 访问器 &#x2F; 属性 装饰器 3. 构造器：参数装饰器 4. 类装饰器</p>\n<p>例如，考虑以下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(key: string): any &#123;</span><br><span class=\"line\">  console.log(&quot;evaluate: &quot;, key);</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(&quot;call: &quot;, key);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@f(&quot;Class Decorator&quot;)</span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @f(&quot;Static Property&quot;)</span><br><span class=\"line\">  static prop?: number;</span><br><span class=\"line\"></span><br><span class=\"line\">  @f(&quot;Static Method&quot;)</span><br><span class=\"line\">  static method(@f(&quot;Static Method Parameter&quot;) foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(@f(&quot;Constructor Parameter&quot;) foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @f(&quot;Instance Method&quot;)</span><br><span class=\"line\">  method(@f(&quot;Instance Method Parameter&quot;) foo) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @f(&quot;Instance Property&quot;)</span><br><span class=\"line\">  prop?: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>它将会打印出以下信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate:  Instance Method</span><br><span class=\"line\">evaluate:  Instance Method Parameter</span><br><span class=\"line\">call:  Instance Method Parameter</span><br><span class=\"line\">call:  Instance Method</span><br><span class=\"line\">evaluate:  Instance Property</span><br><span class=\"line\">call:  Instance Property</span><br><span class=\"line\">evaluate:  Static Property</span><br><span class=\"line\">call:  Static Property</span><br><span class=\"line\">evaluate:  Static Method</span><br><span class=\"line\">evaluate:  Static Method Parameter</span><br><span class=\"line\">call:  Static Method Parameter</span><br><span class=\"line\">call:  Static Method</span><br><span class=\"line\">evaluate:  Class Decorator</span><br><span class=\"line\">evaluate:  Constructor Parameter</span><br><span class=\"line\">call:  Constructor Parameter</span><br><span class=\"line\">call:  Class Decorator</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>你也许会注意到执行实例属性<code>prop</code>晚于实例方法<code>method</code> 然而执行静态属性<code>static prop</code>早于静态方法<code>static method</code>。 这是因为对于属性 &#x2F; 方法 &#x2F; 访问器装饰器而言，执行顺序取决于声明它们的顺序。</p>\n<p>然而，同一方法中不同参数的装饰器的执行顺序是相反的， 最后一个参数的装饰器会最先被执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(key: string): any &#123;</span><br><span class=\"line\">  console.log(&quot;evaluate: &quot;, key);</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(&quot;call: &quot;, key);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  method(</span><br><span class=\"line\">    @f(&quot;Parameter Foo&quot;) foo,</span><br><span class=\"line\">    @f(&quot;Parameter Bar&quot;) bar</span><br><span class=\"line\">  ) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的代码打印出的结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate:  Parameter Foo</span><br><span class=\"line\">evaluate:  Parameter Bar</span><br><span class=\"line\">call:  Parameter Bar</span><br><span class=\"line\">call:  Parameter Foo</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多个装饰器的组合\"><a href=\"#多个装饰器的组合\" class=\"headerlink\" title=\"多个装饰器的组合\"></a>多个装饰器的组合</h2><p>你可以对同一目标应用多个装饰器。它们的组合顺序为：</p>\n<ol>\n<li>求值外层装饰器</li>\n<li>求值内层装饰器</li>\n<li>调用内层装饰器</li>\n<li>调用外层装饰器</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(key: string) &#123;</span><br><span class=\"line\">  console.log(&quot;evaluate: &quot;, key);</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(&quot;call: &quot;, key);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @f(&quot;Outer Method&quot;)</span><br><span class=\"line\">  @f(&quot;Inner Method&quot;)</span><br><span class=\"line\">  method() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的代码打印出的结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate: Outer Method</span><br><span class=\"line\">evaluate: Inner Method</span><br><span class=\"line\">call: Inner Method</span><br><span class=\"line\">call: Outer Method</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类装饰器\"><a href=\"#类装饰器\" class=\"headerlink\" title=\"类装饰器\"></a>类装饰器</h2><p>类型声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ClassDecorator = &lt;TFunction extends Function&gt;</span><br><span class=\"line\">  (target: TFunction) =&gt; TFunction | void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 类的构造器。</li>\n</ol>\n</li>\n<li>@返回：<br>如果类装饰器返回了一个值，她将会被用来代替原有的类构造器的声明。</li>\n</ul>\n<p>因此，类装饰器适合用于继承一个现有类并添加一些属性和方法。</p>\n<p>例如我们可以添加一个<code>toString</code>方法给所有的类来覆盖它原有的<code>toString</code>方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Consturctor = &#123; new (...args: any[]): any &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function toString&lt;T extends Consturctor&gt;(BaseClass: T) &#123;</span><br><span class=\"line\">  return class extends BaseClass &#123;</span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">      return JSON.stringify(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@toString</span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  public foo = &quot;foo&quot;;</span><br><span class=\"line\">  public num = 24;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new C().toString())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>遗憾的是装饰器并没有类型保护，这意味着：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare function Blah&lt;T&gt;(target: T): T &amp; &#123;foo: number&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Blah</span><br><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">  bar() &#123;</span><br><span class=\"line\">    return this.foo; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Foo().foo; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这是 <a class=\"link\"   href=\"https://github.com/microsoft/TypeScript/issues/4881\" >一个 TypeScript 的已知的缺陷 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。 目前我们能做的只有额外提供一个类用于提供类型信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare function Blah&lt;T&gt;(target: T): T &amp; &#123;foo: number&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Base &#123;</span><br><span class=\"line\">  foo: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Blah</span><br><span class=\"line\">class Foo extends Base &#123;</span><br><span class=\"line\">  bar() &#123;</span><br><span class=\"line\">    return this.foo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Foo().foo;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h2><p>类型声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type PropertyDecorator =</span><br><span class=\"line\">  (target: Object, propertyKey: string | symbol) =&gt; void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>\n<li><code>propertyKey</code>: 属性的名称。</li>\n</ol>\n</li>\n<li>@返回：<br>返回的结果将被忽略。</li>\n</ul>\n<p>除了用于收集信息外，属性装饰器也可以用来给类添加额外的方法和属性。 例如我们可以写一个装饰器来给某些属性添加监听器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function capitalizeFirstLetter(str: string) &#123;</span><br><span class=\"line\">  return str.charAt(0).toUpperCase() + str.slice(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function observable(target: any, key: string): any &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  const targetKey = &quot;on&quot; + capitalizeFirstLetter(key) + &quot;Change&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">  target[targetKey] =</span><br><span class=\"line\">    function (fn: (prev: any, next: any) =&gt; void) &#123;</span><br><span class=\"line\">      let prev = this[key];</span><br><span class=\"line\">      Reflect.defineProperty(this, key, &#123;</span><br><span class=\"line\">        set(next) &#123;</span><br><span class=\"line\">          fn(prev, next);</span><br><span class=\"line\">          prev = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @observable</span><br><span class=\"line\">  foo = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">  @observable</span><br><span class=\"line\">  bar = &quot;bar&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\"></span><br><span class=\"line\">c.onFooChange((prev, next) =&gt; console.log(`prev: $&#123;prev&#125;, next: $&#123;next&#125;`))</span><br><span class=\"line\">c.onBarChange((prev, next) =&gt; console.log(`prev: $&#123;prev&#125;, next: $&#123;next&#125;`))</span><br><span class=\"line\"></span><br><span class=\"line\">c.foo = 100; </span><br><span class=\"line\">c.foo = -3.14; </span><br><span class=\"line\">c.bar = &quot;baz&quot;; </span><br><span class=\"line\">c.bar = &quot;sing&quot;; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法装饰器\"><a href=\"#方法装饰器\" class=\"headerlink\" title=\"方法装饰器\"></a>方法装饰器</h2><p>类型声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type MethodDecorator = &lt;T&gt;(</span><br><span class=\"line\">  target: Object,</span><br><span class=\"line\">  propertyKey: string | symbol,</span><br><span class=\"line\">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span><br><span class=\"line\">) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>\n<li><code>propertyKey</code>: 属性的名称。</li>\n<li><code>descriptor</code>: 属性的 <a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\" >描述器 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>。</li>\n</ol>\n</li>\n<li>@返回： 如果返回了值，它会被用于替代属性的描述器。</li>\n</ul>\n<p>方法装饰器不同于属性装饰器的地方在于<code>descriptor</code>参数。 通过这个参数我们可以修改方法原本的实现，添加一些共用逻辑。 例如我们可以给一些方法添加打印输入与输出的能力：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logger(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">  const original = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.value = function (...args) &#123;</span><br><span class=\"line\">    console.log(&#x27;params: &#x27;, ...args);</span><br><span class=\"line\">    const result = original.call(this, ...args);</span><br><span class=\"line\">    console.log(&#x27;result: &#x27;, result);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @logger</span><br><span class=\"line\">  add(x: number, y:number ) &#123;</span><br><span class=\"line\">    return x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">c.add(1, 2);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"访问器装饰器\"><a href=\"#访问器装饰器\" class=\"headerlink\" title=\"访问器装饰器\"></a>访问器装饰器</h2><p>访问器装饰器总体上讲和方法装饰器很接近，唯一的区别在于描述器中有的 key 不同：</p>\n<p>方法装饰器的描述器的 key 为：</p>\n<ul>\n<li><code>value</code></li>\n<li><code>writable</code></li>\n<li><code>enumerable</code></li>\n<li><code>configurable</code></li>\n</ul>\n<p>访问器装饰器的描述器的 key 为：</p>\n<ul>\n<li><code>get</code></li>\n<li><code>set</code></li>\n<li><code>enumerable</code></li>\n<li><code>configurable</code></li>\n</ul>\n<p>例如，我们可以将某个属性设为不可变值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function immutable(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">  const original = descriptor.set;</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.set = function (value: any) &#123;</span><br><span class=\"line\">    return original.call(this, &#123; ...value &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  private _point = &#123; x: 0, y: 0 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  @immutable</span><br><span class=\"line\">  set point(value: &#123; x: number, y: number &#125;) &#123;</span><br><span class=\"line\">    this._point = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get point() &#123;</span><br><span class=\"line\">    return this._point;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">const point = &#123; x: 1, y: 1 &#125;</span><br><span class=\"line\">c.point = point;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(c.point === point)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数装饰器\"><a href=\"#参数装饰器\" class=\"headerlink\" title=\"参数装饰器\"></a>参数装饰器</h2><p>类型声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ParameterDecorator = (</span><br><span class=\"line\">  target: Object,</span><br><span class=\"line\">  propertyKey: string | symbol,</span><br><span class=\"line\">  parameterIndex: number</span><br><span class=\"line\">) =&gt; void;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@参数：<ol>\n<li><code>target</code>: 对于静态成员来说是类的构造器，对于实例成员来说是类的原型链。</li>\n<li><code>propertyKey</code>: 属性的名称 （注意是方法的名称，而不是参数的名称）。</li>\n<li><code>parameterIndex</code>: 参数在方法中所处的位置的下标。</li>\n</ol>\n</li>\n<li>@返回：<br>返回的值将会被忽略。</li>\n</ul>\n<p>单独的参数装饰器能做的事情很有限，它一般都被用于记录可被其它装饰器使用的信息。</p>\n<p>对于一些复杂场景， 我们可能需要结合使用不同的装饰器。 例如如果我们不仅想给我们的接口添加静态检查，还想加上运行时检查的能力。</p>\n<p>我们可以用 3 个步骤来实现这个功能：</p>\n<ol>\n<li>标记需要检查的参数 （因为参数装饰器先于方法装饰器执行）。</li>\n<li>改变方法的<code>descriptor</code>的<code>value</code>的值，先运行参数检查器，如果失败就抛出异常。</li>\n<li>运行原有的接口实现。</li>\n</ol>\n<p>以下是代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Validator = (x: any) =&gt; boolean;</span><br><span class=\"line\"></span><br><span class=\"line\">const validateMap: Record&lt;string, Validator[]&gt; = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function typedDecoratorFactory(validator: Validator): ParameterDecorator &#123;</span><br><span class=\"line\">  return (_, key, index) =&gt; &#123;</span><br><span class=\"line\">    const target = validateMap[key as string] ?? [];</span><br><span class=\"line\">    target[index] = validator;</span><br><span class=\"line\">    validateMap[key as string] = target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function validate(_: Object, key: string, descriptor: PropertyDescriptor) &#123;</span><br><span class=\"line\">  const originalFn = descriptor.value;</span><br><span class=\"line\">  descriptor.value = function(...args: any[]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    const validatorList = validateMap[key];</span><br><span class=\"line\">    if (validatorList) &#123;</span><br><span class=\"line\">      args.forEach((arg, index) =&gt; &#123;</span><br><span class=\"line\">        const validator = validatorList[index];</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!validator) return;</span><br><span class=\"line\"></span><br><span class=\"line\">        const result = validator(arg);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!result) &#123;</span><br><span class=\"line\">          throw new Error(</span><br><span class=\"line\">            `Failed for parameter: $&#123;arg&#125; of the index: $&#123;index&#125;`</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    return originalFn.call(this, ...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const isInt = typedDecoratorFactory((x) =&gt; Number.isInteger(x));</span><br><span class=\"line\">const isString = typedDecoratorFactory((x) =&gt; typeof x === &#x27;string&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @validate</span><br><span class=\"line\">  sayRepeat(@isString word: string, @isInt x: number) &#123;</span><br><span class=\"line\">    return Array(x).fill(word).join(&#x27;&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">c.sayRepeat(&#x27;hello&#x27;, 2); </span><br><span class=\"line\">c.sayRepeat(&#x27;&#x27;, &#x27;lol&#x27; as any); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>正如例子中展示的， 对我们来说同时理解不同种类装饰器的执行顺序和职责都很重要。</p>\n<p>严格地说，元数据和装饰器是 EcmaScript 中两个独立的部分。 然而，如果你想实现像是 <a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\" >反射 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 这样的能力，你总是同时需要它们。</p>\n<p>如果我们回顾上一个例子，如果我们不想写各种不同的检查器呢？ 或者说，能否只写一个检查器能够通过我们编写的 TS 类型声明来自动运行类型检查？</p>\n<p>有了 <a class=\"link\"   href=\"https://github.com/rbuckton/reflect-metadata\" >reflect-metadata <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a> 的帮助， 我们可以获取编译期的类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#x27;reflect-metadata&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">function validate(</span><br><span class=\"line\">  target: Object,</span><br><span class=\"line\">  key: string,</span><br><span class=\"line\">  descriptor: PropertyDescriptor</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  const originalFn = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  const designParamTypes = Reflect</span><br><span class=\"line\">    .getMetadata(&#x27;design:paramtypes&#x27;, target, key);</span><br><span class=\"line\"></span><br><span class=\"line\">  descriptor.value = function (...args: any[]) &#123;</span><br><span class=\"line\">    args.forEach((arg, index) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      const paramType = designParamTypes[index];</span><br><span class=\"line\"></span><br><span class=\"line\">      const result = arg.constructor === paramType</span><br><span class=\"line\">        || arg instanceof paramType;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (!result) &#123;</span><br><span class=\"line\">        throw new Error(</span><br><span class=\"line\">          `Failed for validating parameter: $&#123;arg&#125; of the index: $&#123;index&#125;`</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return originalFn.call(this, ...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class C &#123;</span><br><span class=\"line\">  @validate</span><br><span class=\"line\">  sayRepeat(word: string, x: number) &#123;</span><br><span class=\"line\">    return Array(x).fill(word).join(&#x27;&#x27;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const c = new C();</span><br><span class=\"line\">c.sayRepeat(&#x27;hello&#x27;, 2); </span><br><span class=\"line\">c.sayRepeat(&#x27;&#x27;, &#x27;lol&#x27; as any); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>目前为止一共有三种编译期类型可以拿到：</p>\n<ul>\n<li><code>design:type</code>: 属性的类型。</li>\n<li><code>desin:paramtypes</code>: 方法的参数的类型。</li>\n<li><code>design:returntype</code>: 方法的返回值的类型。</li>\n</ul>\n<p>这三种方式拿到的结果都是构造函数（例如<code>String</code>和<code>Number</code>）。规则是：</p>\n<ul>\n<li>number -&gt; <code>Number</code></li>\n<li>string -&gt; <code>String</code></li>\n<li>boolean -&gt; <code>Boolean</code></li>\n<li>void&#x2F;null&#x2F;never -&gt; <code>undefined</code></li>\n<li>Array&#x2F;Tuple -&gt; <code>Array</code></li>\n<li>Class -&gt; 类的构造函数</li>\n<li>Enum -&gt; 如果是纯数字枚举则为<code>Number</code>, 否则是 <code>Object</code></li>\n<li>Function -&gt; <code>Function</code></li>\n<li>其余都是<code>Object</code></li>\n</ul>\n<p>现在我们可以对于何时使用装饰器得出结论， 在阅读上面的代码中你可能也有所感觉。</p>\n<p>我将例举一些常用的使用场景：</p>\n<ul>\n<li>Before&#x2F;After 钩子。</li>\n<li>监听属性改变或者方法调用。</li>\n<li>对方法的参数做转换。</li>\n<li>添加额外的方法和属性。</li>\n<li>运行时类型检查。</li>\n<li>自动编解码。</li>\n<li>依赖注入。</li>\n</ul>\n<p>我希望读完这篇文章后，你可以找到装饰器的更多使用场景，并且用它来简化你的代码。</p>\n"},{"title":"【一些有趣的问题】01，作用域与闭包","date":"2021-02-23T01:30:54.000Z","_content":"\n## 问题 1\n`以下语句会如何输出？`\n```javascript\nfor(var i=0;i<5;i++){\n    console.log('i',i)\n    setTimeout(function(){\n        console.log(i);\n    },1000)\n}\n```\n`结果`：![结果](./someInterestingQuestions01/q1.png)\n\n`原因`：异步代码会在同步代码执行完毕后执行\n\n`分析`：在执行 setTimeout 中的 console.log 打印变量 i 时，对标识符 i 进行 RHS 查询，因为在当前作用域找不到对应标识符，所以向上前往父级作用域寻找。所以打印的其实是 for 循环中声明的变量 i，而此时已经经过循环赋值变成了 5\n\n**解决方案一：**\n```javascript\nfor(var i=0;i<5;i++){\n    (function(i){\n        setTimeout(function(){\n            console.log(i);\n        },1000)\n    })(i)\n}\n```\n` 结果`：1 秒后连续打印 0 1 2 3 4 \n\n`原因`：IIFE 使得对打印的标识符 i 的查询终止于当前作用域，不用向上继续查询 分析：console.log 打印变量 i 时，发现该标识符对应当前作用域中的形参，其值为传入的实参。所以每次执行 console.log 语句，变量 i 的值都会被覆盖，第一次为 0，第二次为 1，依次类推打印 0 1 2 3 4，而 for 循环中声明的变量 i，其值为 5\n\n**解决方案二：**\n```javascript\nfor(let i=0;i<5;i++){\n  setTimeourt(function(){\n    console.log(i);\n  },1000)\n}\n```\n`结果`：1 秒后连续打印 0 1 2 3 4\n\n`原因`：let 声明不会产生变量提升，并且会绑定当前作用域。for 循环头部的 let 声明会有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n\n---\n\n## 问题 2\n```javascript\nfunction Foo() {\n    var i = 0;\n    return function() {\n        console.log(i++);\n    }\n}\n\nvar f1 = Foo(),\n    f2 = Foo();\nf1();\nf2();\n```\n`结果`：![结果](./someInterestingQuestions01/q2.png)\n\n`原因`：\n\n第一次调用函数 f1()：打印 0，创建闭包，此时局部变量 i=1；\n\n第二次调用函数 f1()：打印 1，创建闭包，此时局部变量 i=2；\n\n第一次调用函数 f2()：打印 0，因为函数 f1、f2 指向不同对象。\n\n--- \n## 问题 3\n```javascript\nfunction Foo() {\n  // 类变量 a\n  Foo.a = function () {\n    console.log(1);\n  }\n  // 实例变量 a，每个实例都有一个\n  this.a = function () {\n    console.log(2);\n  }\n}\n// 实例变量 a，所有实例共享一个\nFoo.prototype.a = function () {\n  console.log(3);\n}\n// 类变量 a\nFoo.a = function () {\n  console.log(4);\n}\n\nFoo.a();\nlet obj = new Foo();\nobj.a();\nFoo.a();\n```\n`结果`：![结果](./someInterestingQuestions01/q3.png)\n\n`原因`：\n\n打印 4：一开始 Foo 方法并未调用，输出的是函数体外的变量 a，此时可以把 Foo 当作对象，Foo.a 为其对象属性。\n\n打印 2：使用 new 操作符实例化 Foo 后，obj.a 首先查找 obj 上的标识符 a，如果找不到的话沿着原型链向上查找，也找不到的话返回 undefined。\n\n打印 1：此时 Foo 方法已经调用，方法体内的类变量 a 覆盖原来已经赋值的类变量 a。\n","source":"_posts/someInterestingQuestions01.md","raw":"---\ntitle: 【一些有趣的问题】01，作用域与闭包\ndate: 2021-02-23 9:30:54\ntags: [JS]\ncategories: [一些有趣的问题]\n---\n\n## 问题 1\n`以下语句会如何输出？`\n```javascript\nfor(var i=0;i<5;i++){\n    console.log('i',i)\n    setTimeout(function(){\n        console.log(i);\n    },1000)\n}\n```\n`结果`：![结果](./someInterestingQuestions01/q1.png)\n\n`原因`：异步代码会在同步代码执行完毕后执行\n\n`分析`：在执行 setTimeout 中的 console.log 打印变量 i 时，对标识符 i 进行 RHS 查询，因为在当前作用域找不到对应标识符，所以向上前往父级作用域寻找。所以打印的其实是 for 循环中声明的变量 i，而此时已经经过循环赋值变成了 5\n\n**解决方案一：**\n```javascript\nfor(var i=0;i<5;i++){\n    (function(i){\n        setTimeout(function(){\n            console.log(i);\n        },1000)\n    })(i)\n}\n```\n` 结果`：1 秒后连续打印 0 1 2 3 4 \n\n`原因`：IIFE 使得对打印的标识符 i 的查询终止于当前作用域，不用向上继续查询 分析：console.log 打印变量 i 时，发现该标识符对应当前作用域中的形参，其值为传入的实参。所以每次执行 console.log 语句，变量 i 的值都会被覆盖，第一次为 0，第二次为 1，依次类推打印 0 1 2 3 4，而 for 循环中声明的变量 i，其值为 5\n\n**解决方案二：**\n```javascript\nfor(let i=0;i<5;i++){\n  setTimeourt(function(){\n    console.log(i);\n  },1000)\n}\n```\n`结果`：1 秒后连续打印 0 1 2 3 4\n\n`原因`：let 声明不会产生变量提升，并且会绑定当前作用域。for 循环头部的 let 声明会有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n\n---\n\n## 问题 2\n```javascript\nfunction Foo() {\n    var i = 0;\n    return function() {\n        console.log(i++);\n    }\n}\n\nvar f1 = Foo(),\n    f2 = Foo();\nf1();\nf2();\n```\n`结果`：![结果](./someInterestingQuestions01/q2.png)\n\n`原因`：\n\n第一次调用函数 f1()：打印 0，创建闭包，此时局部变量 i=1；\n\n第二次调用函数 f1()：打印 1，创建闭包，此时局部变量 i=2；\n\n第一次调用函数 f2()：打印 0，因为函数 f1、f2 指向不同对象。\n\n--- \n## 问题 3\n```javascript\nfunction Foo() {\n  // 类变量 a\n  Foo.a = function () {\n    console.log(1);\n  }\n  // 实例变量 a，每个实例都有一个\n  this.a = function () {\n    console.log(2);\n  }\n}\n// 实例变量 a，所有实例共享一个\nFoo.prototype.a = function () {\n  console.log(3);\n}\n// 类变量 a\nFoo.a = function () {\n  console.log(4);\n}\n\nFoo.a();\nlet obj = new Foo();\nobj.a();\nFoo.a();\n```\n`结果`：![结果](./someInterestingQuestions01/q3.png)\n\n`原因`：\n\n打印 4：一开始 Foo 方法并未调用，输出的是函数体外的变量 a，此时可以把 Foo 当作对象，Foo.a 为其对象属性。\n\n打印 2：使用 new 操作符实例化 Foo 后，obj.a 首先查找 obj 上的标识符 a，如果找不到的话沿着原型链向上查找，也找不到的话返回 undefined。\n\n打印 1：此时 Foo 方法已经调用，方法体内的类变量 a 覆盖原来已经赋值的类变量 a。\n","slug":"someInterestingQuestions01","published":1,"updated":"2023-11-22T14:42:34.176Z","_id":"clf92ychi001i7gh89g3s1apj","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题 1\"></a>问题 1</h2><p><code>以下语句会如何输出？</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;i&#x27;</span>,i)</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><code>结果</code>：<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2021/02/23/someInterestingQuestions01/q1.png\"\n                      class=\"\" title=\"结果\"\n                ></p>\n<p><code>原因</code>：异步代码会在同步代码执行完毕后执行</p>\n<p><code>分析</code>：在执行 setTimeout 中的 console.log 打印变量 i 时，对标识符 i 进行 RHS 查询，因为在当前作用域找不到对应标识符，所以向上前往父级作用域寻找。所以打印的其实是 for 循环中声明的变量 i，而此时已经经过循环赋值变成了 5</p>\n<p><strong>解决方案一：</strong></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">    (<span class=\"keyword\">function</span>(<span class=\"params\">i</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><code> 结果</code>：1 秒后连续打印 0 1 2 3 4 </p>\n<p><code>原因</code>：IIFE 使得对打印的标识符 i 的查询终止于当前作用域，不用向上继续查询 分析：console.log 打印变量 i 时，发现该标识符对应当前作用域中的形参，其值为传入的实参。所以每次执行 console.log 语句，变量 i 的值都会被覆盖，第一次为 0，第二次为 1，依次类推打印 0 1 2 3 4，而 for 循环中声明的变量 i，其值为 5</p>\n<p><strong>解决方案二：</strong></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">  <span class=\"title function_\">setTimeourt</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p><code>结果</code>：1 秒后连续打印 0 1 2 3 4</p>\n<p><code>原因</code>：let 声明不会产生变量提升，并且会绑定当前作用域。for 循环头部的 let 声明会有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>\n<hr>\n<h2 id=\"问题-2\"><a href=\"#问题-2\" class=\"headerlink\" title=\"问题 2\"></a>问题 2</h2><div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"title class_\">Foo</span>(),</span><br><span class=\"line\">    f2 = <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\"><span class=\"title function_\">f1</span>();</span><br><span class=\"line\"><span class=\"title function_\">f2</span>();</span><br></pre></td></tr></table></figure></div>\n<p><code>结果</code>：<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2021/02/23/someInterestingQuestions01/q2.png\"\n                      class=\"\" title=\"结果\"\n                ></p>\n<p><code>原因</code>：</p>\n<p>第一次调用函数 f1()：打印 0，创建闭包，此时局部变量 i&#x3D;1；</p>\n<p>第二次调用函数 f1()：打印 1，创建闭包，此时局部变量 i&#x3D;2；</p>\n<p>第一次调用函数 f2()：打印 0，因为函数 f1、f2 指向不同对象。</p>\n<hr>\n<h2 id=\"问题-3\"><a href=\"#问题-3\" class=\"headerlink\" title=\"问题 3\"></a>问题 3</h2><div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 类变量 a</span></span><br><span class=\"line\">  <span class=\"title class_\">Foo</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 实例变量 a，每个实例都有一个</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 实例变量 a，所有实例共享一个</span></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 类变量 a</span></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"title function_\">a</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\">obj.<span class=\"title function_\">a</span>();</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"title function_\">a</span>();</span><br></pre></td></tr></table></figure></div>\n<p><code>结果</code>：<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2021/02/23/someInterestingQuestions01/q3.png\"\n                      class=\"\" title=\"结果\"\n                ></p>\n<p><code>原因</code>：</p>\n<p>打印 4：一开始 Foo 方法并未调用，输出的是函数体外的变量 a，此时可以把 Foo 当作对象，Foo.a 为其对象属性。</p>\n<p>打印 2：使用 new 操作符实例化 Foo 后，obj.a 首先查找 obj 上的标识符 a，如果找不到的话沿着原型链向上查找，也找不到的话返回 undefined。</p>\n<p>打印 1：此时 Foo 方法已经调用，方法体内的类变量 a 覆盖原来已经赋值的类变量 a。</p>\n","excerpt":"","more":"<h2 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题 1\"></a>问题 1</h2><p><code>以下语句会如何输出？</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;i&#x27;</span>,i)</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>结果</code>：<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2021/02/23/someInterestingQuestions01/q1.png\"\n                      class=\"\" title=\"结果\"\n                ></p>\n<p><code>原因</code>：异步代码会在同步代码执行完毕后执行</p>\n<p><code>分析</code>：在执行 setTimeout 中的 console.log 打印变量 i 时，对标识符 i 进行 RHS 查询，因为在当前作用域找不到对应标识符，所以向上前往父级作用域寻找。所以打印的其实是 for 循环中声明的变量 i，而此时已经经过循环赋值变成了 5</p>\n<p><strong>解决方案一：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">    (<span class=\"keyword\">function</span>(<span class=\"params\">i</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code> 结果</code>：1 秒后连续打印 0 1 2 3 4 </p>\n<p><code>原因</code>：IIFE 使得对打印的标识符 i 的查询终止于当前作用域，不用向上继续查询 分析：console.log 打印变量 i 时，发现该标识符对应当前作用域中的形参，其值为传入的实参。所以每次执行 console.log 语句，变量 i 的值都会被覆盖，第一次为 0，第二次为 1，依次类推打印 0 1 2 3 4，而 for 循环中声明的变量 i，其值为 5</p>\n<p><strong>解决方案二：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">  <span class=\"title function_\">setTimeourt</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>结果</code>：1 秒后连续打印 0 1 2 3 4</p>\n<p><code>原因</code>：let 声明不会产生变量提升，并且会绑定当前作用域。for 循环头部的 let 声明会有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>\n<hr>\n<h2 id=\"问题-2\"><a href=\"#问题-2\" class=\"headerlink\" title=\"问题 2\"></a>问题 2</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"title class_\">Foo</span>(),</span><br><span class=\"line\">    f2 = <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\"><span class=\"title function_\">f1</span>();</span><br><span class=\"line\"><span class=\"title function_\">f2</span>();</span><br></pre></td></tr></table></figure>\n<p><code>结果</code>：<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2021/02/23/someInterestingQuestions01/q2.png\"\n                      class=\"\" title=\"结果\"\n                ></p>\n<p><code>原因</code>：</p>\n<p>第一次调用函数 f1()：打印 0，创建闭包，此时局部变量 i&#x3D;1；</p>\n<p>第二次调用函数 f1()：打印 1，创建闭包，此时局部变量 i&#x3D;2；</p>\n<p>第一次调用函数 f2()：打印 0，因为函数 f1、f2 指向不同对象。</p>\n<hr>\n<h2 id=\"问题-3\"><a href=\"#问题-3\" class=\"headerlink\" title=\"问题 3\"></a>问题 3</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 类变量 a</span></span><br><span class=\"line\">  <span class=\"title class_\">Foo</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 实例变量 a，每个实例都有一个</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 实例变量 a，所有实例共享一个</span></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 类变量 a</span></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\">a</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"title function_\">a</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\">obj.<span class=\"title function_\">a</span>();</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"title function_\">a</span>();</span><br></pre></td></tr></table></figure>\n<p><code>结果</code>：<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2021/02/23/someInterestingQuestions01/q3.png\"\n                      class=\"\" title=\"结果\"\n                ></p>\n<p><code>原因</code>：</p>\n<p>打印 4：一开始 Foo 方法并未调用，输出的是函数体外的变量 a，此时可以把 Foo 当作对象，Foo.a 为其对象属性。</p>\n<p>打印 2：使用 new 操作符实例化 Foo 后，obj.a 首先查找 obj 上的标识符 a，如果找不到的话沿着原型链向上查找，也找不到的话返回 undefined。</p>\n<p>打印 1：此时 Foo 方法已经调用，方法体内的类变量 a 覆盖原来已经赋值的类变量 a。</p>\n"},{"title":"【一些有趣的问题】02，事件循环","date":"2021-02-25T02:15:54.000Z","_content":"\n`以下语句会如何输出？`\n```javascript\nconsole.log('start')\n\nsetTimeout(() => {\n  console.log('setTimeout')\n}, 0)\n\nnew Promise((resolve) => {\n  console.log('promise')\n  resolve()\n})\n  .then(() => {\n    console.log('then1')\n  })\n  .then(() => {\n    console.log('then2')\n  })\n\nconsole.log('end')\n```\n\n结果：打印 start promise end then1 then2 setTimeout\n\n原因：简单来说，JS 代码的执行顺序为：同步代码-->异步代码（微任务-->宏任务）\n\n分析：\n\n1. 打印 start\n\n2. setTimeout 加入消息队列\n\n3. new Promise 的同步部分执行，打印 promise，then 部分加入消息队列\n\n4. 打印 end\n\n5. 消息队列中先处理微任务 then 的部分，打印 then1，then2\n\n6. 消息队列处理宏任务 setTimeout，打印 setTimeout\n\n## `参考资料`\n> [并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)\n>\n> [深入理解 js 事件循环机制（浏览器篇）](http://lynnelv.github.io/js-event-loop-browser)\n","source":"_posts/someInterestingQuestions02.md","raw":"---\ntitle: 【一些有趣的问题】02，事件循环\ndate: 2021-02-25 10:15:54\ntags: [JS]\ncategories: [一些有趣的问题]\n---\n\n`以下语句会如何输出？`\n```javascript\nconsole.log('start')\n\nsetTimeout(() => {\n  console.log('setTimeout')\n}, 0)\n\nnew Promise((resolve) => {\n  console.log('promise')\n  resolve()\n})\n  .then(() => {\n    console.log('then1')\n  })\n  .then(() => {\n    console.log('then2')\n  })\n\nconsole.log('end')\n```\n\n结果：打印 start promise end then1 then2 setTimeout\n\n原因：简单来说，JS 代码的执行顺序为：同步代码-->异步代码（微任务-->宏任务）\n\n分析：\n\n1. 打印 start\n\n2. setTimeout 加入消息队列\n\n3. new Promise 的同步部分执行，打印 promise，then 部分加入消息队列\n\n4. 打印 end\n\n5. 消息队列中先处理微任务 then 的部分，打印 then1，then2\n\n6. 消息队列处理宏任务 setTimeout，打印 setTimeout\n\n## `参考资料`\n> [并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)\n>\n> [深入理解 js 事件循环机制（浏览器篇）](http://lynnelv.github.io/js-event-loop-browser)\n","slug":"someInterestingQuestions02","published":1,"updated":"2023-11-22T14:42:34.686Z","_id":"clf92ychj001l7gh8euoe5tgf","comments":1,"layout":"post","photos":[],"content":"<p><code>以下语句会如何输出？</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;start&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;setTimeout&#x27;</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;promise&#x27;</span>)</span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;then1&#x27;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;then2&#x27;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure></div>\n\n<p>结果：打印 start promise end then1 then2 setTimeout</p>\n<p>原因：简单来说，JS 代码的执行顺序为：同步代码–&gt;异步代码（微任务–&gt;宏任务）</p>\n<p>分析：</p>\n<ol>\n<li><p>打印 start</p>\n</li>\n<li><p>setTimeout 加入消息队列</p>\n</li>\n<li><p>new Promise 的同步部分执行，打印 promise，then 部分加入消息队列</p>\n</li>\n<li><p>打印 end</p>\n</li>\n<li><p>消息队列中先处理微任务 then 的部分，打印 then1，then2</p>\n</li>\n<li><p>消息队列处理宏任务 setTimeout，打印 setTimeout</p>\n</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2><blockquote>\n<p><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" >并发模型与事件循环 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"http://lynnelv.github.io/js-event-loop-browser\" >深入理解 js 事件循环机制（浏览器篇） <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n","excerpt":"","more":"<p><code>以下语句会如何输出？</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;start&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;setTimeout&#x27;</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;promise&#x27;</span>)</span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;then1&#x27;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;then2&#x27;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>结果：打印 start promise end then1 then2 setTimeout</p>\n<p>原因：简单来说，JS 代码的执行顺序为：同步代码–&gt;异步代码（微任务–&gt;宏任务）</p>\n<p>分析：</p>\n<ol>\n<li><p>打印 start</p>\n</li>\n<li><p>setTimeout 加入消息队列</p>\n</li>\n<li><p>new Promise 的同步部分执行，打印 promise，then 部分加入消息队列</p>\n</li>\n<li><p>打印 end</p>\n</li>\n<li><p>消息队列中先处理微任务 then 的部分，打印 then1，then2</p>\n</li>\n<li><p>消息队列处理宏任务 setTimeout，打印 setTimeout</p>\n</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2><blockquote>\n<p><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" >并发模型与事件循环 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p><a class=\"link\"   href=\"http://lynnelv.github.io/js-event-loop-browser\" >深入理解 js 事件循环机制（浏览器篇） <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n</blockquote>\n"},{"title":"【一些有趣的问题】03，浮点数","date":"2021-03-06T07:15:54.000Z","_content":"\n`以下语句会如何输出？`\n```javascript\n0.1 + 0.2 == 0.3；\n// false\n\n1 - 0.9 == 0.1;\n// false\n```\n在 JS 中只有一种数值类型，以 64 位表示的双精度浮点类型\n\n`解决方法`\n```javascript\n(0.1 + 0.2).toFixed(10) == 0.3;\n// true\n\n(1 - 0.9).toFixed(10) == 0.1;\n// true\n```\n\n`可以把运算封装成方法`\n```javascript\n//加法函数，用来得到精确的加法结果\n//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n//调用：accAdd(arg1,arg2)\n//返回值：arg1 加上 arg2 的精确结果\nfunction accAdd(arg1,arg2){\n  var r1,r2,m;\n  try{r1=arg1.toString().split(\".\")[1].length}catch(e){r1=0}\n  try{r2=arg2.toString().split(\".\")[1].length}catch(e){r2=0}\n  m=Math.pow(10,Math.max(r1,r2))\n  return (arg1*m+arg2*m)/m\n}\n//给 Number 类型增加一个 add 方法，调用起来更加方便。\nNumber.prototype.add = function (arg){\n  return accAdd(arg,this);\n}\n \n//减法函数，用来得到精确的减法结果\n//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的减法结果。\n//调用：accSub(arg1,arg2)\n//返回值：arg1 减去 arg2 的精确结果\nfunction accSub(arg1,arg2){\n  var r1,r2,m,n;\n  try{r1=arg1.toString().split(\".\")[1].length}catch(e){r1=0}\n  try{r2=arg2.toString().split(\".\")[1].length}catch(e){r2=0}\n  m=Math.pow(10,Math.max(r1,r2));\n  //last modify by deeka\n  //动态控制精度长度\n  n=(r1>=r2)?r1:r2;\n  return ((arg1*m-arg2*m)/m).toFixed(n);\n}\n \n//除法函数，用来得到精确的除法结果\n//说明：javascript 的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。\n//调用：accDiv(arg1,arg2)\n//返回值：arg1 除以 arg2 的精确结果\nfunction accDiv(arg1,arg2){\n  var t1=0,t2=0,r1,r2;\n  try{t1=arg1.toString().split(\".\")[1].length}catch(e){}\n  try{t2=arg2.toString().split(\".\")[1].length}catch(e){}\n  with(Math){\n    r1=Number(arg1.toString().replace(\".\",\"\"))\n    r2=Number(arg2.toString().replace(\".\",\"\"))\n    return (r1/r2)*pow(10,t2-t1);\n  }\n}\n//给 Number 类型增加一个 div 方法，调用起来更加方便。\nNumber.prototype.div = function (arg){\n  return accDiv(this, arg);\n}\n \n//乘法函数，用来得到精确的乘法结果\n//说明：javascript 的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。\n//调用：accMul(arg1,arg2)\n//返回值：arg1 乘以 arg2 的精确结果\nfunction accMul(arg1,arg2) {\n  var m=0,s1=arg1.toString(),s2=arg2.toString();\n  try{m+=s1.split(\".\")[1].length}catch(e){}\n  try{m+=s2.split(\".\")[1].length}catch(e){}\n  return  Number(s1.replace(\".\",\"\"))*Number(s2.replace(\".\",\"\"))/Math.pow(10,m)\n}\n//给 Number 类型增加一个 mul 方法，调用起来更加方便。\nNumber.prototype.mul = function (arg){\n  return accMul(arg, this);\n}\n<br>//验证一下：\nconsole.log(accAdd(1.79, 0.12));  //1.91\nconsole.log(accSub(2.01, 0.12));  //1.89\nconsole.log(accDiv(0.69, 10));    //0.069<br>console.log(accMul(1.01, 1.3));   //1.313　　\n```\n\n## `参考资料`\n- [浅谈 JavaScript 浮点数及其运算](https://www.cnblogs.com/ppforever/p/5011660.html)\n- [JavaScript 数字\n](https://www.w3school.com.cn/js/js_numbers.asp)","source":"_posts/someInterestingQuestions03.md","raw":"---\ntitle: 【一些有趣的问题】03，浮点数\ndate: 2021-03-06 15:15:54\ntags: [JS]\ncategories: [一些有趣的问题]\n---\n\n`以下语句会如何输出？`\n```javascript\n0.1 + 0.2 == 0.3；\n// false\n\n1 - 0.9 == 0.1;\n// false\n```\n在 JS 中只有一种数值类型，以 64 位表示的双精度浮点类型\n\n`解决方法`\n```javascript\n(0.1 + 0.2).toFixed(10) == 0.3;\n// true\n\n(1 - 0.9).toFixed(10) == 0.1;\n// true\n```\n\n`可以把运算封装成方法`\n```javascript\n//加法函数，用来得到精确的加法结果\n//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。\n//调用：accAdd(arg1,arg2)\n//返回值：arg1 加上 arg2 的精确结果\nfunction accAdd(arg1,arg2){\n  var r1,r2,m;\n  try{r1=arg1.toString().split(\".\")[1].length}catch(e){r1=0}\n  try{r2=arg2.toString().split(\".\")[1].length}catch(e){r2=0}\n  m=Math.pow(10,Math.max(r1,r2))\n  return (arg1*m+arg2*m)/m\n}\n//给 Number 类型增加一个 add 方法，调用起来更加方便。\nNumber.prototype.add = function (arg){\n  return accAdd(arg,this);\n}\n \n//减法函数，用来得到精确的减法结果\n//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的减法结果。\n//调用：accSub(arg1,arg2)\n//返回值：arg1 减去 arg2 的精确结果\nfunction accSub(arg1,arg2){\n  var r1,r2,m,n;\n  try{r1=arg1.toString().split(\".\")[1].length}catch(e){r1=0}\n  try{r2=arg2.toString().split(\".\")[1].length}catch(e){r2=0}\n  m=Math.pow(10,Math.max(r1,r2));\n  //last modify by deeka\n  //动态控制精度长度\n  n=(r1>=r2)?r1:r2;\n  return ((arg1*m-arg2*m)/m).toFixed(n);\n}\n \n//除法函数，用来得到精确的除法结果\n//说明：javascript 的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。\n//调用：accDiv(arg1,arg2)\n//返回值：arg1 除以 arg2 的精确结果\nfunction accDiv(arg1,arg2){\n  var t1=0,t2=0,r1,r2;\n  try{t1=arg1.toString().split(\".\")[1].length}catch(e){}\n  try{t2=arg2.toString().split(\".\")[1].length}catch(e){}\n  with(Math){\n    r1=Number(arg1.toString().replace(\".\",\"\"))\n    r2=Number(arg2.toString().replace(\".\",\"\"))\n    return (r1/r2)*pow(10,t2-t1);\n  }\n}\n//给 Number 类型增加一个 div 方法，调用起来更加方便。\nNumber.prototype.div = function (arg){\n  return accDiv(this, arg);\n}\n \n//乘法函数，用来得到精确的乘法结果\n//说明：javascript 的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。\n//调用：accMul(arg1,arg2)\n//返回值：arg1 乘以 arg2 的精确结果\nfunction accMul(arg1,arg2) {\n  var m=0,s1=arg1.toString(),s2=arg2.toString();\n  try{m+=s1.split(\".\")[1].length}catch(e){}\n  try{m+=s2.split(\".\")[1].length}catch(e){}\n  return  Number(s1.replace(\".\",\"\"))*Number(s2.replace(\".\",\"\"))/Math.pow(10,m)\n}\n//给 Number 类型增加一个 mul 方法，调用起来更加方便。\nNumber.prototype.mul = function (arg){\n  return accMul(arg, this);\n}\n<br>//验证一下：\nconsole.log(accAdd(1.79, 0.12));  //1.91\nconsole.log(accSub(2.01, 0.12));  //1.89\nconsole.log(accDiv(0.69, 10));    //0.069<br>console.log(accMul(1.01, 1.3));   //1.313　　\n```\n\n## `参考资料`\n- [浅谈 JavaScript 浮点数及其运算](https://www.cnblogs.com/ppforever/p/5011660.html)\n- [JavaScript 数字\n](https://www.w3school.com.cn/js/js_numbers.asp)","slug":"someInterestingQuestions03","published":1,"updated":"2023-11-22T14:42:35.232Z","_id":"clf92ychk001n7gh84drg6dxk","comments":1,"layout":"post","photos":[],"content":"<p><code>以下语句会如何输出？</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> == <span class=\"number\">0.3</span>；</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"number\">0.9</span> == <span class=\"number\">0.1</span>;</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></div>\n<p>在 JS 中只有一种数值类型，以 64 位表示的双精度浮点类型</p>\n<p><code>解决方法</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">10</span>) == <span class=\"number\">0.3</span>;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span> - <span class=\"number\">0.9</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">10</span>) == <span class=\"number\">0.1</span>;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></div>\n\n<p><code>可以把运算封装成方法</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加法函数，用来得到精确的加法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accAdd(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 加上 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accAdd</span>(<span class=\"params\">arg1,arg2</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r1,r2,m;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r1=arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r1=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r2=arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r2=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  m=<span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,<span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(r1,r2))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (arg1*m+arg2*m)/m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给 Number 类型增加一个 add 方法，调用起来更加方便。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">add</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">accAdd</span>(arg,<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//减法函数，用来得到精确的减法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的减法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accSub(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 减去 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accSub</span>(<span class=\"params\">arg1,arg2</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r1,r2,m,n;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r1=arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r1=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r2=arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r2=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  m=<span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,<span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(r1,r2));</span><br><span class=\"line\">  <span class=\"comment\">//last modify by deeka</span></span><br><span class=\"line\">  <span class=\"comment\">//动态控制精度长度</span></span><br><span class=\"line\">  n=(r1&gt;=r2)?<span class=\"attr\">r1</span>:r2;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((arg1*m-arg2*m)/m).<span class=\"title function_\">toFixed</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//除法函数，用来得到精确的除法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accDiv(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 除以 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accDiv</span>(<span class=\"params\">arg1,arg2</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t1=<span class=\"number\">0</span>,t2=<span class=\"number\">0</span>,r1,r2;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;t1=arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;t2=arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"title function_\">with</span>(<span class=\"params\"><span class=\"built_in\">Math</span></span>)&#123;</span><br><span class=\"line\">    r1=<span class=\"title class_\">Number</span>(arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    r2=<span class=\"title class_\">Number</span>(arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (r1/r2)*<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,t2-t1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给 Number 类型增加一个 div 方法，调用起来更加方便。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">div</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">accDiv</span>(<span class=\"variable language_\">this</span>, arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//乘法函数，用来得到精确的乘法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accMul(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 乘以 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accMul</span>(<span class=\"params\">arg1,arg2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m=<span class=\"number\">0</span>,s1=arg1.<span class=\"title function_\">toString</span>(),s2=arg2.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;m+=s1.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;m+=s2.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>  <span class=\"title class_\">Number</span>(s1.<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))*<span class=\"title class_\">Number</span>(s2.<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))/<span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给 Number 类型增加一个 mul 方法，调用起来更加方便。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">mul</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">accMul</span>(arg, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;br&gt;<span class=\"comment\">//验证一下：</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">accAdd</span>(<span class=\"number\">1.79</span>, <span class=\"number\">0.12</span>));  <span class=\"comment\">//1.91</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">accSub</span>(<span class=\"number\">2.01</span>, <span class=\"number\">0.12</span>));  <span class=\"comment\">//1.89</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">accDiv</span>(<span class=\"number\">0.69</span>, <span class=\"number\">10</span>));    <span class=\"comment\">//0.069&lt;br&gt;console.log(accMul(1.01, 1.3));   //1.313　　</span></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2><ul>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/ppforever/p/5011660.html\" >浅谈 JavaScript 浮点数及其运算 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.w3school.com.cn/js/js_numbers.asp\" >JavaScript 数字\n <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n","excerpt":"","more":"<p><code>以下语句会如何输出？</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> == <span class=\"number\">0.3</span>；</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> - <span class=\"number\">0.9</span> == <span class=\"number\">0.1</span>;</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>在 JS 中只有一种数值类型，以 64 位表示的双精度浮点类型</p>\n<p><code>解决方法</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">10</span>) == <span class=\"number\">0.3</span>;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span> - <span class=\"number\">0.9</span>).<span class=\"title function_\">toFixed</span>(<span class=\"number\">10</span>) == <span class=\"number\">0.1</span>;</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>可以把运算封装成方法</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加法函数，用来得到精确的加法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accAdd(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 加上 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accAdd</span>(<span class=\"params\">arg1,arg2</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r1,r2,m;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r1=arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r1=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r2=arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r2=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  m=<span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,<span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(r1,r2))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (arg1*m+arg2*m)/m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给 Number 类型增加一个 add 方法，调用起来更加方便。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">add</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">accAdd</span>(arg,<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//减法函数，用来得到精确的减法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的减法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accSub(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 减去 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accSub</span>(<span class=\"params\">arg1,arg2</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> r1,r2,m,n;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r1=arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r1=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;r2=arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;r2=<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  m=<span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,<span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(r1,r2));</span><br><span class=\"line\">  <span class=\"comment\">//last modify by deeka</span></span><br><span class=\"line\">  <span class=\"comment\">//动态控制精度长度</span></span><br><span class=\"line\">  n=(r1&gt;=r2)?<span class=\"attr\">r1</span>:r2;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((arg1*m-arg2*m)/m).<span class=\"title function_\">toFixed</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//除法函数，用来得到精确的除法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accDiv(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 除以 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accDiv</span>(<span class=\"params\">arg1,arg2</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t1=<span class=\"number\">0</span>,t2=<span class=\"number\">0</span>,r1,r2;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;t1=arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;t2=arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"title function_\">with</span>(<span class=\"params\"><span class=\"built_in\">Math</span></span>)&#123;</span><br><span class=\"line\">    r1=<span class=\"title class_\">Number</span>(arg1.<span class=\"title function_\">toString</span>().<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    r2=<span class=\"title class_\">Number</span>(arg2.<span class=\"title function_\">toString</span>().<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (r1/r2)*<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,t2-t1);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给 Number 类型增加一个 div 方法，调用起来更加方便。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">div</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">accDiv</span>(<span class=\"variable language_\">this</span>, arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//乘法函数，用来得到精确的乘法结果</span></span><br><span class=\"line\"><span class=\"comment\">//说明：javascript 的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。</span></span><br><span class=\"line\"><span class=\"comment\">//调用：accMul(arg1,arg2)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值：arg1 乘以 arg2 的精确结果</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">accMul</span>(<span class=\"params\">arg1,arg2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m=<span class=\"number\">0</span>,s1=arg1.<span class=\"title function_\">toString</span>(),s2=arg2.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;m+=s1.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;m+=s2.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>)[<span class=\"number\">1</span>].<span class=\"property\">length</span>&#125;<span class=\"keyword\">catch</span>(e)&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>  <span class=\"title class_\">Number</span>(s1.<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))*<span class=\"title class_\">Number</span>(s2.<span class=\"title function_\">replace</span>(<span class=\"string\">&quot;.&quot;</span>,<span class=\"string\">&quot;&quot;</span>))/<span class=\"title class_\">Math</span>.<span class=\"title function_\">pow</span>(<span class=\"number\">10</span>,m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//给 Number 类型增加一个 mul 方法，调用起来更加方便。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">mul</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">accMul</span>(arg, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;br&gt;<span class=\"comment\">//验证一下：</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">accAdd</span>(<span class=\"number\">1.79</span>, <span class=\"number\">0.12</span>));  <span class=\"comment\">//1.91</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">accSub</span>(<span class=\"number\">2.01</span>, <span class=\"number\">0.12</span>));  <span class=\"comment\">//1.89</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">accDiv</span>(<span class=\"number\">0.69</span>, <span class=\"number\">10</span>));    <span class=\"comment\">//0.069&lt;br&gt;console.log(accMul(1.01, 1.3));   //1.313　　</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2><ul>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/ppforever/p/5011660.html\" >浅谈 JavaScript 浮点数及其运算 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.w3school.com.cn/js/js_numbers.asp\" >JavaScript 数字\n <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></li>\n</ul>\n"},{"title":"【一些有趣的问题】04，逗号运算符","date":"2021-03-14T14:15:54.000Z","_content":"\n<!-- YCTODO -->\n\n`以下语句会如何输出？`\n```javascript\nfor(let i=0,j=0;i<6,j<5,i++,j++){\n  console.log(i,j);\n}\n```\n在\n## `参考资料`\n","source":"_posts/someInterestingQuestions04.md","raw":"---\ntitle: 【一些有趣的问题】04，逗号运算符\ndate: 2021-03-14 22:15:54\ntags: [JS]\ncategories: [一些有趣的问题]\n---\n\n<!-- YCTODO -->\n\n`以下语句会如何输出？`\n```javascript\nfor(let i=0,j=0;i<6,j<5,i++,j++){\n  console.log(i,j);\n}\n```\n在\n## `参考资料`\n","slug":"someInterestingQuestions04","published":1,"updated":"2023-11-22T14:42:37.672Z","_id":"clf92ychl001s7gh8c07k12p3","comments":1,"layout":"post","photos":[],"content":"<!-- YCTODO -->\n\n<p><code>以下语句会如何输出？</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>,j&lt;<span class=\"number\">5</span>,i++,j++)&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i,j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>在</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2>","excerpt":"","more":"<!-- YCTODO -->\n\n<p><code>以下语句会如何输出？</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>,j&lt;<span class=\"number\">5</span>,i++,j++)&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i,j);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><code>参考资料</code></h2>"},{"title":"【一些有趣的问题】05，for..in 与 for..of","date":"2021-03-20T03:15:54.000Z","_content":"\n`以下语句会如何输出？`\n```javascript\nlet arr = [3, 5, 7];\narr.foo = \"hello\";\n// 此时 arr 对象的结构：[3,5,7,foo: 'hello']\n\nfor (let i in arr) {\n  console.log(i); // 输出 \"0\", \"1\", \"2\", \"foo\"\n}\n\nfor (let i of arr) {\n  console.log(i); // 输出 \"3\", \"5\", \"7\"\n}\n\n// 注意 for...of 的输出没有出现 \"hello\"\n\n```\n`for...in `\n- 循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。\n- 深入一点\n\n`for...of `\n- 在可迭代对象（包括 Array、Map、Set、arguments 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。\n- 首先会在向访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。\n\n`Symbol.iterator`\n-  为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。\n- 可以通过 Symbol.iterator 来访问可迭代对象的@@iterator 属性\n```javascript\nvar myArray = [1,2,3];\nvar it = myArray[Symbol.iterator]();\n```\n","source":"_posts/someInterestingQuestions05.md","raw":"---\ntitle: 【一些有趣的问题】05，for..in 与 for..of\ndate: 2021-03-20 11:15:54\ntags: [JS]\ncategories: [一些有趣的问题]\n---\n\n`以下语句会如何输出？`\n```javascript\nlet arr = [3, 5, 7];\narr.foo = \"hello\";\n// 此时 arr 对象的结构：[3,5,7,foo: 'hello']\n\nfor (let i in arr) {\n  console.log(i); // 输出 \"0\", \"1\", \"2\", \"foo\"\n}\n\nfor (let i of arr) {\n  console.log(i); // 输出 \"3\", \"5\", \"7\"\n}\n\n// 注意 for...of 的输出没有出现 \"hello\"\n\n```\n`for...in `\n- 循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。\n- 深入一点\n\n`for...of `\n- 在可迭代对象（包括 Array、Map、Set、arguments 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。\n- 首先会在向访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。\n\n`Symbol.iterator`\n-  为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用。\n- 可以通过 Symbol.iterator 来访问可迭代对象的@@iterator 属性\n```javascript\nvar myArray = [1,2,3];\nvar it = myArray[Symbol.iterator]();\n```\n","slug":"someInterestingQuestions05","published":1,"updated":"2023-03-02T13:23:29.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychm001v7gh8ebp2503p","content":"<p><code>以下语句会如何输出？</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\">arr.<span class=\"property\">foo</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 此时 arr 对象的结构：[3,5,7,foo: &#x27;hello&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意 for...of 的输出没有出现 &quot;hello&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<p><code>for...in </code></p>\n<ul>\n<li>循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。</li>\n<li>深入一点</li>\n</ul>\n<p><code>for...of </code></p>\n<ul>\n<li>在可迭代对象（包括 Array、Map、Set、arguments 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。</li>\n<li>首先会在向访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。</li>\n</ul>\n<p><code>Symbol.iterator</code></p>\n<ul>\n<li>为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用。</li>\n<li>可以通过 Symbol.iterator 来访问可迭代对象的@@iterator 属性<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> it = myArray[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]();</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><code>以下语句会如何输出？</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\">arr.<span class=\"property\">foo</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 此时 arr 对象的结构：[3,5,7,foo: &#x27;hello&#x27;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注意 for...of 的输出没有出现 &quot;hello&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>for...in </code></p>\n<ul>\n<li>循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。</li>\n<li>深入一点</li>\n</ul>\n<p><code>for...of </code></p>\n<ul>\n<li>在可迭代对象（包括 Array、Map、Set、arguments 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。</li>\n<li>首先会在向访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。</li>\n</ul>\n<p><code>Symbol.iterator</code></p>\n<ul>\n<li>为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用。</li>\n<li>可以通过 Symbol.iterator 来访问可迭代对象的@@iterator 属性<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> it = myArray[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]();</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"【一些有趣的问题】06，进制转换","date":"2021-03-27T06:15:54.000Z","_content":"\n`以下语句会如何输出？`\n```javascript\n022 - 017\n// 3，18 - 15 = 3\n\n018 - 045\n// -19，18 - 37 = -19\n```\n在 JS 中，在 Number 类型前加 0 会转换为 8 进制，如果原来的值位上有大于 8 的数，则不会进行转换。\n\n在 JS 中，有几种方法来进行进制转换，但只能通过 10 进制中转，即 10 进制转其他进制或者其他进制转 10 进制。\n```javascript\n// 0x 表示十六进制，但是 js 会强制转换为十进制来运算，0xa == 10\nvar a = 0xa;\n// 0 开头表示八进制，同样强制转换为十进制来运算 010 = 8\nvar b = 010;\n\n// Number.parseInt 方法把字符串（只能由字母和数字组成）由低进制转高进制，如二进制转八进制，但是八进制不能转二进制，radix 表示进制，取值 2~36，返回一个字符串。\nNumber.parseInt(string,radix)\nNumber.parseInt('0101',2) // 5\nNumber.parseInt('0101',8) // 65\n\n// Number.toString 方法将十进制数字转换为任意进制的字符串形式，同样，radix 表示进制，取值 2~36\nNumber.toString(radix)\n(10).toString(2) //\"1010\" 转 2 进制\n(10).toString(8) //\"12\" 转 8 进制\n(10).toString(16) //\"a\" 转 16 进制\n(1000).toString(36) //\"rs\" 转 36 进制\n```","source":"_posts/someInterestingQuestions06.md","raw":"---\ntitle: 【一些有趣的问题】06，进制转换\ndate: 2021-03-27 14:15:54\ntags: [JS]\ncategories: [一些有趣的问题]\n---\n\n`以下语句会如何输出？`\n```javascript\n022 - 017\n// 3，18 - 15 = 3\n\n018 - 045\n// -19，18 - 37 = -19\n```\n在 JS 中，在 Number 类型前加 0 会转换为 8 进制，如果原来的值位上有大于 8 的数，则不会进行转换。\n\n在 JS 中，有几种方法来进行进制转换，但只能通过 10 进制中转，即 10 进制转其他进制或者其他进制转 10 进制。\n```javascript\n// 0x 表示十六进制，但是 js 会强制转换为十进制来运算，0xa == 10\nvar a = 0xa;\n// 0 开头表示八进制，同样强制转换为十进制来运算 010 = 8\nvar b = 010;\n\n// Number.parseInt 方法把字符串（只能由字母和数字组成）由低进制转高进制，如二进制转八进制，但是八进制不能转二进制，radix 表示进制，取值 2~36，返回一个字符串。\nNumber.parseInt(string,radix)\nNumber.parseInt('0101',2) // 5\nNumber.parseInt('0101',8) // 65\n\n// Number.toString 方法将十进制数字转换为任意进制的字符串形式，同样，radix 表示进制，取值 2~36\nNumber.toString(radix)\n(10).toString(2) //\"1010\" 转 2 进制\n(10).toString(8) //\"12\" 转 8 进制\n(10).toString(16) //\"a\" 转 16 进制\n(1000).toString(36) //\"rs\" 转 36 进制\n```","slug":"someInterestingQuestions06","published":1,"updated":"2023-11-22T14:42:40.229Z","_id":"clf92ychn001z7gh8e1fwdcqb","comments":1,"layout":"post","photos":[],"content":"<p><code>以下语句会如何输出？</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">022</span> - <span class=\"number\">017</span></span><br><span class=\"line\"><span class=\"comment\">// 3，18 - 15 = 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">018</span> - <span class=\"number\">045</span></span><br><span class=\"line\"><span class=\"comment\">// -19，18 - 37 = -19</span></span><br></pre></td></tr></table></figure></div>\n<p>在 JS 中，在 Number 类型前加 0 会转换为 8 进制，如果原来的值位上有大于 8 的数，则不会进行转换。</p>\n<p>在 JS 中，有几种方法来进行进制转换，但只能通过 10 进制中转，即 10 进制转其他进制或者其他进制转 10 进制。</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0x 表示十六进制，但是 js 会强制转换为十进制来运算，0xa == 10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0xa</span>;</span><br><span class=\"line\"><span class=\"comment\">// 0 开头表示八进制，同样强制转换为十进制来运算 010 = 8</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Number.parseInt 方法把字符串（只能由字母和数字组成）由低进制转高进制，如二进制转八进制，但是八进制不能转二进制，radix 表示进制，取值 2~36，返回一个字符串。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(string,radix)</span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0101&#x27;</span>,<span class=\"number\">2</span>) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0101&#x27;</span>,<span class=\"number\">8</span>) <span class=\"comment\">// 65</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Number.toString 方法将十进制数字转换为任意进制的字符串形式，同样，radix 表示进制，取值 2~36</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"title function_\">toString</span>(radix)</span><br><span class=\"line\">(<span class=\"number\">10</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">2</span>) <span class=\"comment\">//&quot;1010&quot; 转 2 进制</span></span><br><span class=\"line\">(<span class=\"number\">10</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">8</span>) <span class=\"comment\">//&quot;12&quot; 转 8 进制</span></span><br><span class=\"line\">(<span class=\"number\">10</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>) <span class=\"comment\">//&quot;a&quot; 转 16 进制</span></span><br><span class=\"line\">(<span class=\"number\">1000</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">36</span>) <span class=\"comment\">//&quot;rs&quot; 转 36 进制</span></span><br></pre></td></tr></table></figure></div>","excerpt":"","more":"<p><code>以下语句会如何输出？</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">022</span> - <span class=\"number\">017</span></span><br><span class=\"line\"><span class=\"comment\">// 3，18 - 15 = 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">018</span> - <span class=\"number\">045</span></span><br><span class=\"line\"><span class=\"comment\">// -19，18 - 37 = -19</span></span><br></pre></td></tr></table></figure>\n<p>在 JS 中，在 Number 类型前加 0 会转换为 8 进制，如果原来的值位上有大于 8 的数，则不会进行转换。</p>\n<p>在 JS 中，有几种方法来进行进制转换，但只能通过 10 进制中转，即 10 进制转其他进制或者其他进制转 10 进制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0x 表示十六进制，但是 js 会强制转换为十进制来运算，0xa == 10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">0xa</span>;</span><br><span class=\"line\"><span class=\"comment\">// 0 开头表示八进制，同样强制转换为十进制来运算 010 = 8</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Number.parseInt 方法把字符串（只能由字母和数字组成）由低进制转高进制，如二进制转八进制，但是八进制不能转二进制，radix 表示进制，取值 2~36，返回一个字符串。</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(string,radix)</span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0101&#x27;</span>,<span class=\"number\">2</span>) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"built_in\">parseInt</span>(<span class=\"string\">&#x27;0101&#x27;</span>,<span class=\"number\">8</span>) <span class=\"comment\">// 65</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Number.toString 方法将十进制数字转换为任意进制的字符串形式，同样，radix 表示进制，取值 2~36</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"title function_\">toString</span>(radix)</span><br><span class=\"line\">(<span class=\"number\">10</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">2</span>) <span class=\"comment\">//&quot;1010&quot; 转 2 进制</span></span><br><span class=\"line\">(<span class=\"number\">10</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">8</span>) <span class=\"comment\">//&quot;12&quot; 转 8 进制</span></span><br><span class=\"line\">(<span class=\"number\">10</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>) <span class=\"comment\">//&quot;a&quot; 转 16 进制</span></span><br><span class=\"line\">(<span class=\"number\">1000</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">36</span>) <span class=\"comment\">//&quot;rs&quot; 转 36 进制</span></span><br></pre></td></tr></table></figure>"},{"title":"【Vue3 源码学习】01，从 createApp() 方法开始","date":"2022-06-03T02:56:48.000Z","_content":"\n![s0](./vueSourceCodeStudy01/s0.jpg)\nPS: 这是一张很有用的图\n\n## 前言：怎样学习源码？\n1. 有主线，两种方式\n   1. 从入口入手，package.json-->\n   2. 从逻辑入手，createApp()\n2. 提出一个问题，在源码中找答案\n3. 学习一步整理一步，然后复盘复习（画图）\n4. 有所掌握后造轮子实践\n5. 写博客或者做视频，在知识分享中巩固知识\n\n## 首先提几个问题\n- 第一个问题：app 实例如何创建？\n- 第二个问题：app 实例中有些什么？\n\n## 第一个问题：app 实例如何创建？\n![s1-1](./vueSourceCodeStudy01/s1-1.png)\n![s1-2](./vueSourceCodeStudy01/s1-2.png)\ncreateApp() 函数内部的 ensureRenderer() 方法返回了一个渲染器 renderer（），这个 renderer 调用了 createApp() 创建实例。可以看到在 ensureRenderer() 方法内部调用了 createRenderer() 方法，进入其中会发现一个工厂函数 baseCreateRenderer()。\n![s1-3](./vueSourceCodeStudy01/s1-3.png) \n查看 baseCreateRenderer() 方法的实现，会发现它返回了一个方法 createAppAPI()，进入 createAppAPI() 方法内部，会发现这又是一个工厂函数，返回一个 createApp() 方法，而这就是图一中一开始调用的 createApp()。\n![s1-4](./vueSourceCodeStudy01/s1-4.png)\n![s1-5](./vueSourceCodeStudy01/s1-5.png)\n\n## 第二个问题：app 实例中有些什么？\n在 createAppAPI() 方法的实现代码中，我们可以找到实例 app 的实现，它包含了一些实例属性和实例方法，我们所熟悉的 use、mixin、component、directive、mount、unmount、provide 尽在其上\n![s1-6](./vueSourceCodeStudy01/s1-6.png)\n\n## 一些思考\n可以发现，相比于 vue2 来说，vue3 将全局方法挂载到了实例 app 上（vue2 是挂载在构建函数 Vue 上），这样我们使用这些方法的方式发生了变化\n```javascript\nimport myComponent from './vueSourceCodeStudy01/myComponent';\nimport myPlugin from './myPlugin';\n\n// vue2\nVue.component('myComponent',myComponent);\nVue.use(myPlugin);\n\n// vue3\ncreateApp({...}).coponent(myComponent).use(myPlugin).mount('#app')\n```\n这样做有什么好处呢？我认为是为了应付多实例场景，这样做更加便于维护且清晰易懂。","source":"_posts/vueSourceCodeStudy01.md","raw":"---\ntitle: 【Vue3 源码学习】01，从 createApp() 方法开始\ndate: 2022-06-03 10:56:48\ntags: [vue]\ncategories: [源码]\n---\n\n![s0](./vueSourceCodeStudy01/s0.jpg)\nPS: 这是一张很有用的图\n\n## 前言：怎样学习源码？\n1. 有主线，两种方式\n   1. 从入口入手，package.json-->\n   2. 从逻辑入手，createApp()\n2. 提出一个问题，在源码中找答案\n3. 学习一步整理一步，然后复盘复习（画图）\n4. 有所掌握后造轮子实践\n5. 写博客或者做视频，在知识分享中巩固知识\n\n## 首先提几个问题\n- 第一个问题：app 实例如何创建？\n- 第二个问题：app 实例中有些什么？\n\n## 第一个问题：app 实例如何创建？\n![s1-1](./vueSourceCodeStudy01/s1-1.png)\n![s1-2](./vueSourceCodeStudy01/s1-2.png)\ncreateApp() 函数内部的 ensureRenderer() 方法返回了一个渲染器 renderer（），这个 renderer 调用了 createApp() 创建实例。可以看到在 ensureRenderer() 方法内部调用了 createRenderer() 方法，进入其中会发现一个工厂函数 baseCreateRenderer()。\n![s1-3](./vueSourceCodeStudy01/s1-3.png) \n查看 baseCreateRenderer() 方法的实现，会发现它返回了一个方法 createAppAPI()，进入 createAppAPI() 方法内部，会发现这又是一个工厂函数，返回一个 createApp() 方法，而这就是图一中一开始调用的 createApp()。\n![s1-4](./vueSourceCodeStudy01/s1-4.png)\n![s1-5](./vueSourceCodeStudy01/s1-5.png)\n\n## 第二个问题：app 实例中有些什么？\n在 createAppAPI() 方法的实现代码中，我们可以找到实例 app 的实现，它包含了一些实例属性和实例方法，我们所熟悉的 use、mixin、component、directive、mount、unmount、provide 尽在其上\n![s1-6](./vueSourceCodeStudy01/s1-6.png)\n\n## 一些思考\n可以发现，相比于 vue2 来说，vue3 将全局方法挂载到了实例 app 上（vue2 是挂载在构建函数 Vue 上），这样我们使用这些方法的方式发生了变化\n```javascript\nimport myComponent from './vueSourceCodeStudy01/myComponent';\nimport myPlugin from './myPlugin';\n\n// vue2\nVue.component('myComponent',myComponent);\nVue.use(myPlugin);\n\n// vue3\ncreateApp({...}).coponent(myComponent).use(myPlugin).mount('#app')\n```\n这样做有什么好处呢？我认为是为了应付多实例场景，这样做更加便于维护且清晰易懂。","slug":"vueSourceCodeStudy01","published":1,"updated":"2023-03-02T13:23:30.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychn00217gh86veq2wpm","content":"<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s0.jpg\"\n                      class=\"\" title=\"s0\"\n                >\n<p>PS: 这是一张很有用的图</p>\n<h2 id=\"前言：怎样学习源码？\"><a href=\"#前言：怎样学习源码？\" class=\"headerlink\" title=\"前言：怎样学习源码？\"></a>前言：怎样学习源码？</h2><ol>\n<li>有主线，两种方式<ol>\n<li>从入口入手，package.json–&gt;</li>\n<li>从逻辑入手，createApp()</li>\n</ol>\n</li>\n<li>提出一个问题，在源码中找答案</li>\n<li>学习一步整理一步，然后复盘复习（画图）</li>\n<li>有所掌握后造轮子实践</li>\n<li>写博客或者做视频，在知识分享中巩固知识</li>\n</ol>\n<h2 id=\"首先提几个问题\"><a href=\"#首先提几个问题\" class=\"headerlink\" title=\"首先提几个问题\"></a>首先提几个问题</h2><ul>\n<li>第一个问题：app 实例如何创建？</li>\n<li>第二个问题：app 实例中有些什么？</li>\n</ul>\n<h2 id=\"第一个问题：app-实例如何创建？\"><a href=\"#第一个问题：app-实例如何创建？\" class=\"headerlink\" title=\"第一个问题：app 实例如何创建？\"></a>第一个问题：app 实例如何创建？</h2><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-1.png\"\n                      class=\"\" title=\"s1-1\"\n                >\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-2.png\"\n                      class=\"\" title=\"s1-2\"\n                >\n<p>createApp() 函数内部的 ensureRenderer() 方法返回了一个渲染器 renderer（），这个 renderer 调用了 createApp() 创建实例。可以看到在 ensureRenderer() 方法内部调用了 createRenderer() 方法，进入其中会发现一个工厂函数 baseCreateRenderer()。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-3.png\"\n                      class=\"\" title=\"s1-3\"\n                > \n<p>查看 baseCreateRenderer() 方法的实现，会发现它返回了一个方法 createAppAPI()，进入 createAppAPI() 方法内部，会发现这又是一个工厂函数，返回一个 createApp() 方法，而这就是图一中一开始调用的 createApp()。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-4.png\"\n                      class=\"\" title=\"s1-4\"\n                >\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-5.png\"\n                      class=\"\" title=\"s1-5\"\n                >\n\n<h2 id=\"第二个问题：app-实例中有些什么？\"><a href=\"#第二个问题：app-实例中有些什么？\" class=\"headerlink\" title=\"第二个问题：app 实例中有些什么？\"></a>第二个问题：app 实例中有些什么？</h2><p>在 createAppAPI() 方法的实现代码中，我们可以找到实例 app 的实现，它包含了一些实例属性和实例方法，我们所熟悉的 use、mixin、component、directive、mount、unmount、provide 尽在其上</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-6.png\"\n                      class=\"\" title=\"s1-6\"\n                >\n\n<h2 id=\"一些思考\"><a href=\"#一些思考\" class=\"headerlink\" title=\"一些思考\"></a>一些思考</h2><p>可以发现，相比于 vue2 来说，vue3 将全局方法挂载到了实例 app 上（vue2 是挂载在构建函数 Vue 上），这样我们使用这些方法的方式发生了变化</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> myComponent <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./vueSourceCodeStudy01/myComponent&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> myPlugin <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./myPlugin&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vue2</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;myComponent&#x27;</span>,myComponent);</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(myPlugin);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vue3</span></span><br><span class=\"line\"><span class=\"title function_\">createApp</span>(&#123;...&#125;).<span class=\"title function_\">coponent</span>(myComponent).<span class=\"title function_\">use</span>(myPlugin).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></div>\n<p>这样做有什么好处呢？我认为是为了应付多实例场景，这样做更加便于维护且清晰易懂。</p>\n","site":{"data":{}},"excerpt":"","more":"<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s0.jpg\"\n                      class=\"\" title=\"s0\"\n                >\n<p>PS: 这是一张很有用的图</p>\n<h2 id=\"前言：怎样学习源码？\"><a href=\"#前言：怎样学习源码？\" class=\"headerlink\" title=\"前言：怎样学习源码？\"></a>前言：怎样学习源码？</h2><ol>\n<li>有主线，两种方式<ol>\n<li>从入口入手，package.json–&gt;</li>\n<li>从逻辑入手，createApp()</li>\n</ol>\n</li>\n<li>提出一个问题，在源码中找答案</li>\n<li>学习一步整理一步，然后复盘复习（画图）</li>\n<li>有所掌握后造轮子实践</li>\n<li>写博客或者做视频，在知识分享中巩固知识</li>\n</ol>\n<h2 id=\"首先提几个问题\"><a href=\"#首先提几个问题\" class=\"headerlink\" title=\"首先提几个问题\"></a>首先提几个问题</h2><ul>\n<li>第一个问题：app 实例如何创建？</li>\n<li>第二个问题：app 实例中有些什么？</li>\n</ul>\n<h2 id=\"第一个问题：app-实例如何创建？\"><a href=\"#第一个问题：app-实例如何创建？\" class=\"headerlink\" title=\"第一个问题：app 实例如何创建？\"></a>第一个问题：app 实例如何创建？</h2><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-1.png\"\n                      class=\"\" title=\"s1-1\"\n                >\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-2.png\"\n                      class=\"\" title=\"s1-2\"\n                >\n<p>createApp() 函数内部的 ensureRenderer() 方法返回了一个渲染器 renderer（），这个 renderer 调用了 createApp() 创建实例。可以看到在 ensureRenderer() 方法内部调用了 createRenderer() 方法，进入其中会发现一个工厂函数 baseCreateRenderer()。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-3.png\"\n                      class=\"\" title=\"s1-3\"\n                > \n<p>查看 baseCreateRenderer() 方法的实现，会发现它返回了一个方法 createAppAPI()，进入 createAppAPI() 方法内部，会发现这又是一个工厂函数，返回一个 createApp() 方法，而这就是图一中一开始调用的 createApp()。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-4.png\"\n                      class=\"\" title=\"s1-4\"\n                >\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-5.png\"\n                      class=\"\" title=\"s1-5\"\n                >\n\n<h2 id=\"第二个问题：app-实例中有些什么？\"><a href=\"#第二个问题：app-实例中有些什么？\" class=\"headerlink\" title=\"第二个问题：app 实例中有些什么？\"></a>第二个问题：app 实例中有些什么？</h2><p>在 createAppAPI() 方法的实现代码中，我们可以找到实例 app 的实现，它包含了一些实例属性和实例方法，我们所熟悉的 use、mixin、component、directive、mount、unmount、provide 尽在其上</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy01/s1-6.png\"\n                      class=\"\" title=\"s1-6\"\n                >\n\n<h2 id=\"一些思考\"><a href=\"#一些思考\" class=\"headerlink\" title=\"一些思考\"></a>一些思考</h2><p>可以发现，相比于 vue2 来说，vue3 将全局方法挂载到了实例 app 上（vue2 是挂载在构建函数 Vue 上），这样我们使用这些方法的方式发生了变化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> myComponent <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./vueSourceCodeStudy01/myComponent&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> myPlugin <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./myPlugin&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vue2</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;myComponent&#x27;</span>,myComponent);</span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"title function_\">use</span>(myPlugin);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vue3</span></span><br><span class=\"line\"><span class=\"title function_\">createApp</span>(&#123;...&#125;).<span class=\"title function_\">coponent</span>(myComponent).<span class=\"title function_\">use</span>(myPlugin).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>这样做有什么好处呢？我认为是为了应付多实例场景，这样做更加便于维护且清晰易懂。</p>\n"},{"title":"【Vue3 源码学习】02，初始 mount() 方法","date":"2022-06-03T02:56:48.000Z","_content":"\n## 前言\n书接上回，在 runtime-core 包下的文件`/runtime-core/src/apiCreateApp.ts`中我们找到了 createAppAPI() 方法，此方法调用时创建一个 app 实例，在这个实例中挂载了一些我们熟悉的实例方法，`mount()`就在其中。\n\n## 首先提几个问题\n1. 初次挂载时 mount() 方法做了些什么？ \n2. 回忆一下 vue 的生命周期，mount() 方法在哪一部分执行了？\n![s2-0](./vueSourceCodeStudy02/s0.png)\n\n## 初次挂载时 mount() 方法干了些什么？\n![s2-1](./vueSourceCodeStudy02/s2-1.png)\n\n首先进入 mount() 方法，它接收 3 个参数：`rootContainer`，isHydrate，isSVG，我们这里只关注 rootContainer，因为初次挂载时的一般写法是：\n```javascript\n// 可以看到我们只传了一个字符串，是一个 CSS 选择器。\ncreateApp({}).mount('#app')\n```\n\n再看方法体：\n![s2-2](./vueSourceCodeStudy02/s2-2.png)\n\n可以看到首先创建了一个 vnode，这个 vnode 由 createApp 方法传入的根组件确定；然后执行红框中的 render() 方法，我们传入的 rootContainer 作为第二个参数传入。\n\n让我们看看这个 render 方法，它是 createAppAPI() 方法的第一个参数，上一章介绍过这是 baseCreateRenderer() 这个工厂函数的返回，它在`/runtime-core/src/renderer.ts`目录下可以找到。\n![s2-3](./vueSourceCodeStudy02/s2-3.png)\n\n![s2-4](./vueSourceCodeStudy02/s2-4.png)\n\n接下来找到 render() 方法的方法体：\n![s2-5](./vueSourceCodeStudy02/s2-5.png)\n\n可以看到 render() 方法接收三个参数，初次挂载时 vnode 有值，container 是我们 mount() 方法传入的挂载节点。因为 vnode 存在，所以执行 else 部分，可以看到，这里使用了一个`patch()`方法\n\n我们来看一下这个 patch() 方法中传了些什么：\n![s2-6](./vueSourceCodeStudy02/s2-6.png)\n\n可以看出传入的 container 参数是一个 DOM 对象，在第一次挂载时指向`div#app`，我们的宿主对象，此时 container._vnode 值为 undefined（在 render 方法的最后才会给_vnode 属性赋值），所以第一个参数值为 null，第二个参数是之前传入的 vnode 对象，长这样：\n![s2-7](./vueSourceCodeStudy02/s2-7.png)\n\n之后会用到，此时先不做关注。我们再来看看 patch() 方法内部：\n![s2-8](./vueSourceCodeStudy02/s2-8.png)\n\n<!-- \n  YCNOTE：为什么 switch 语句要传入一个对象\n -->\n沿着逻辑往下走到红框部分，此时从我们传入的 vnode（第一次挂载时 mount 方法中新建的 vnode) 中取出 3 个值，根据`type`和`shapeFlag`的值进行不同的操作：\n![s2-10](./vueSourceCodeStudy02/s2-10.png)\n\n此时 shapeFlag 的值为 4，进行位与运算值为 true。以下`位移枚举`可以学一下，它的好处是清晰、好计算并且可以进行多值判断。\n![s2-11](./vueSourceCodeStudy02/s2-11.png)\n\n初次挂载时执行`processComponent()`方法，进入方法体 processComponent()：\n![s2-12](./vueSourceCodeStudy02/s2-12.png)\n\n可以看到走进 else 代码块，触发方法`mountComponent()`，见名知意，组件由这个方法挂载。进入该方法，该方法首先会执行一个`setupRenderEffect()`方法，\n![s2-13](./vueSourceCodeStudy02/s2-13.png)\n\n这个方法创建了一个执行器 `effect`，然后调用了 effect.run() 方法，当 effect.run() 执行完毕时，整个挂载流程结束。\n\n## 总结\n\n总结一下，初次挂载时 mount() 方法执行流程大概这样：\n\nmount()-->createVNode()-->render()-->patch()-->processComponent()-->mountComponent()-->createComponentInstance-->setupRenderEffect()-->ReactiveEffect()-->update()-->effect.run()\n\n简洁一点就是：\n\nmount()-->render()-->patch()\n\n可以通过调用堆栈查看：\n![s2-14](./vueSourceCodeStudy02/s2-14.png)\n\n回到最初提的两个问题，第一个问题已经基本解答完毕，第二个问题，mount() 函数在 vue 的生命周期的哪一部分执行也已经可以推想出来：\n![s2-15](./vueSourceCodeStudy02/s2-15.png)\n\n本篇文章就到此为止，因为是初识，所以比较简单，基本上就是跟着调用栈走，之后会更具体的分析 render() 和 patch() 函数。\n\n若有错误请大佬指出，感激不尽。\n","source":"_posts/vueSourceCodeStudy02.md","raw":"---\ntitle: 【Vue3 源码学习】02，初始 mount() 方法\ndate: 2022-06-03 10:56:48\ntags: [vue]\ncategories: [源码]\n---\n\n## 前言\n书接上回，在 runtime-core 包下的文件`/runtime-core/src/apiCreateApp.ts`中我们找到了 createAppAPI() 方法，此方法调用时创建一个 app 实例，在这个实例中挂载了一些我们熟悉的实例方法，`mount()`就在其中。\n\n## 首先提几个问题\n1. 初次挂载时 mount() 方法做了些什么？ \n2. 回忆一下 vue 的生命周期，mount() 方法在哪一部分执行了？\n![s2-0](./vueSourceCodeStudy02/s0.png)\n\n## 初次挂载时 mount() 方法干了些什么？\n![s2-1](./vueSourceCodeStudy02/s2-1.png)\n\n首先进入 mount() 方法，它接收 3 个参数：`rootContainer`，isHydrate，isSVG，我们这里只关注 rootContainer，因为初次挂载时的一般写法是：\n```javascript\n// 可以看到我们只传了一个字符串，是一个 CSS 选择器。\ncreateApp({}).mount('#app')\n```\n\n再看方法体：\n![s2-2](./vueSourceCodeStudy02/s2-2.png)\n\n可以看到首先创建了一个 vnode，这个 vnode 由 createApp 方法传入的根组件确定；然后执行红框中的 render() 方法，我们传入的 rootContainer 作为第二个参数传入。\n\n让我们看看这个 render 方法，它是 createAppAPI() 方法的第一个参数，上一章介绍过这是 baseCreateRenderer() 这个工厂函数的返回，它在`/runtime-core/src/renderer.ts`目录下可以找到。\n![s2-3](./vueSourceCodeStudy02/s2-3.png)\n\n![s2-4](./vueSourceCodeStudy02/s2-4.png)\n\n接下来找到 render() 方法的方法体：\n![s2-5](./vueSourceCodeStudy02/s2-5.png)\n\n可以看到 render() 方法接收三个参数，初次挂载时 vnode 有值，container 是我们 mount() 方法传入的挂载节点。因为 vnode 存在，所以执行 else 部分，可以看到，这里使用了一个`patch()`方法\n\n我们来看一下这个 patch() 方法中传了些什么：\n![s2-6](./vueSourceCodeStudy02/s2-6.png)\n\n可以看出传入的 container 参数是一个 DOM 对象，在第一次挂载时指向`div#app`，我们的宿主对象，此时 container._vnode 值为 undefined（在 render 方法的最后才会给_vnode 属性赋值），所以第一个参数值为 null，第二个参数是之前传入的 vnode 对象，长这样：\n![s2-7](./vueSourceCodeStudy02/s2-7.png)\n\n之后会用到，此时先不做关注。我们再来看看 patch() 方法内部：\n![s2-8](./vueSourceCodeStudy02/s2-8.png)\n\n<!-- \n  YCNOTE：为什么 switch 语句要传入一个对象\n -->\n沿着逻辑往下走到红框部分，此时从我们传入的 vnode（第一次挂载时 mount 方法中新建的 vnode) 中取出 3 个值，根据`type`和`shapeFlag`的值进行不同的操作：\n![s2-10](./vueSourceCodeStudy02/s2-10.png)\n\n此时 shapeFlag 的值为 4，进行位与运算值为 true。以下`位移枚举`可以学一下，它的好处是清晰、好计算并且可以进行多值判断。\n![s2-11](./vueSourceCodeStudy02/s2-11.png)\n\n初次挂载时执行`processComponent()`方法，进入方法体 processComponent()：\n![s2-12](./vueSourceCodeStudy02/s2-12.png)\n\n可以看到走进 else 代码块，触发方法`mountComponent()`，见名知意，组件由这个方法挂载。进入该方法，该方法首先会执行一个`setupRenderEffect()`方法，\n![s2-13](./vueSourceCodeStudy02/s2-13.png)\n\n这个方法创建了一个执行器 `effect`，然后调用了 effect.run() 方法，当 effect.run() 执行完毕时，整个挂载流程结束。\n\n## 总结\n\n总结一下，初次挂载时 mount() 方法执行流程大概这样：\n\nmount()-->createVNode()-->render()-->patch()-->processComponent()-->mountComponent()-->createComponentInstance-->setupRenderEffect()-->ReactiveEffect()-->update()-->effect.run()\n\n简洁一点就是：\n\nmount()-->render()-->patch()\n\n可以通过调用堆栈查看：\n![s2-14](./vueSourceCodeStudy02/s2-14.png)\n\n回到最初提的两个问题，第一个问题已经基本解答完毕，第二个问题，mount() 函数在 vue 的生命周期的哪一部分执行也已经可以推想出来：\n![s2-15](./vueSourceCodeStudy02/s2-15.png)\n\n本篇文章就到此为止，因为是初识，所以比较简单，基本上就是跟着调用栈走，之后会更具体的分析 render() 和 patch() 函数。\n\n若有错误请大佬指出，感激不尽。\n","slug":"vueSourceCodeStudy02","published":1,"updated":"2023-03-02T13:23:31.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ycho00257gh8c5mpglx6","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>书接上回，在 runtime-core 包下的文件<code>/runtime-core/src/apiCreateApp.ts</code>中我们找到了 createAppAPI() 方法，此方法调用时创建一个 app 实例，在这个实例中挂载了一些我们熟悉的实例方法，<code>mount()</code>就在其中。</p>\n<h2 id=\"首先提几个问题\"><a href=\"#首先提几个问题\" class=\"headerlink\" title=\"首先提几个问题\"></a>首先提几个问题</h2><ol>\n<li>初次挂载时 mount() 方法做了些什么？ </li>\n<li>回忆一下 vue 的生命周期，mount() 方法在哪一部分执行了？<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s0.png\"\n                      class=\"\" title=\"s2-0\"\n                ></li>\n</ol>\n<h2 id=\"初次挂载时-mount-方法干了些什么？\"><a href=\"#初次挂载时-mount-方法干了些什么？\" class=\"headerlink\" title=\"初次挂载时 mount() 方法干了些什么？\"></a>初次挂载时 mount() 方法干了些什么？</h2><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-1.png\"\n                      class=\"\" title=\"s2-1\"\n                >\n\n<p>首先进入 mount() 方法，它接收 3 个参数：<code>rootContainer</code>，isHydrate，isSVG，我们这里只关注 rootContainer，因为初次挂载时的一般写法是：</p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以看到我们只传了一个字符串，是一个 CSS 选择器。</span></span><br><span class=\"line\"><span class=\"title function_\">createApp</span>(&#123;&#125;).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></div>\n\n<p>再看方法体：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-2.png\"\n                      class=\"\" title=\"s2-2\"\n                >\n\n<p>可以看到首先创建了一个 vnode，这个 vnode 由 createApp 方法传入的根组件确定；然后执行红框中的 render() 方法，我们传入的 rootContainer 作为第二个参数传入。</p>\n<p>让我们看看这个 render 方法，它是 createAppAPI() 方法的第一个参数，上一章介绍过这是 baseCreateRenderer() 这个工厂函数的返回，它在<code>/runtime-core/src/renderer.ts</code>目录下可以找到。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-3.png\"\n                      class=\"\" title=\"s2-3\"\n                >\n\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-4.png\"\n                      class=\"\" title=\"s2-4\"\n                >\n\n<p>接下来找到 render() 方法的方法体：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-5.png\"\n                      class=\"\" title=\"s2-5\"\n                >\n\n<p>可以看到 render() 方法接收三个参数，初次挂载时 vnode 有值，container 是我们 mount() 方法传入的挂载节点。因为 vnode 存在，所以执行 else 部分，可以看到，这里使用了一个<code>patch()</code>方法</p>\n<p>我们来看一下这个 patch() 方法中传了些什么：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-6.png\"\n                      class=\"\" title=\"s2-6\"\n                >\n\n<p>可以看出传入的 container 参数是一个 DOM 对象，在第一次挂载时指向<code>div#app</code>，我们的宿主对象，此时 container._vnode 值为 undefined（在 render 方法的最后才会给_vnode 属性赋值），所以第一个参数值为 null，第二个参数是之前传入的 vnode 对象，长这样：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-7.png\"\n                      class=\"\" title=\"s2-7\"\n                >\n\n<p>之后会用到，此时先不做关注。我们再来看看 patch() 方法内部：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-8.png\"\n                      class=\"\" title=\"s2-8\"\n                >\n\n<!-- \n  YCNOTE：为什么 switch 语句要传入一个对象\n -->\n<p>沿着逻辑往下走到红框部分，此时从我们传入的 vnode（第一次挂载时 mount 方法中新建的 vnode) 中取出 3 个值，根据<code>type</code>和<code>shapeFlag</code>的值进行不同的操作：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-10.png\"\n                      class=\"\" title=\"s2-10\"\n                >\n\n<p>此时 shapeFlag 的值为 4，进行位与运算值为 true。以下<code>位移枚举</code>可以学一下，它的好处是清晰、好计算并且可以进行多值判断。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-11.png\"\n                      class=\"\" title=\"s2-11\"\n                >\n\n<p>初次挂载时执行<code>processComponent()</code>方法，进入方法体 processComponent()：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-12.png\"\n                      class=\"\" title=\"s2-12\"\n                >\n\n<p>可以看到走进 else 代码块，触发方法<code>mountComponent()</code>，见名知意，组件由这个方法挂载。进入该方法，该方法首先会执行一个<code>setupRenderEffect()</code>方法，</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-13.png\"\n                      class=\"\" title=\"s2-13\"\n                >\n\n<p>这个方法创建了一个执行器 <code>effect</code>，然后调用了 effect.run() 方法，当 effect.run() 执行完毕时，整个挂载流程结束。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结一下，初次挂载时 mount() 方法执行流程大概这样：</p>\n<p>mount()–&gt;createVNode()–&gt;render()–&gt;patch()–&gt;processComponent()–&gt;mountComponent()–&gt;createComponentInstance–&gt;setupRenderEffect()–&gt;ReactiveEffect()–&gt;update()–&gt;effect.run()</p>\n<p>简洁一点就是：</p>\n<p>mount()–&gt;render()–&gt;patch()</p>\n<p>可以通过调用堆栈查看：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-14.png\"\n                      class=\"\" title=\"s2-14\"\n                >\n\n<p>回到最初提的两个问题，第一个问题已经基本解答完毕，第二个问题，mount() 函数在 vue 的生命周期的哪一部分执行也已经可以推想出来：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-15.png\"\n                      class=\"\" title=\"s2-15\"\n                >\n\n<p>本篇文章就到此为止，因为是初识，所以比较简单，基本上就是跟着调用栈走，之后会更具体的分析 render() 和 patch() 函数。</p>\n<p>若有错误请大佬指出，感激不尽。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>书接上回，在 runtime-core 包下的文件<code>/runtime-core/src/apiCreateApp.ts</code>中我们找到了 createAppAPI() 方法，此方法调用时创建一个 app 实例，在这个实例中挂载了一些我们熟悉的实例方法，<code>mount()</code>就在其中。</p>\n<h2 id=\"首先提几个问题\"><a href=\"#首先提几个问题\" class=\"headerlink\" title=\"首先提几个问题\"></a>首先提几个问题</h2><ol>\n<li>初次挂载时 mount() 方法做了些什么？ </li>\n<li>回忆一下 vue 的生命周期，mount() 方法在哪一部分执行了？<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s0.png\"\n                      class=\"\" title=\"s2-0\"\n                ></li>\n</ol>\n<h2 id=\"初次挂载时-mount-方法干了些什么？\"><a href=\"#初次挂载时-mount-方法干了些什么？\" class=\"headerlink\" title=\"初次挂载时 mount() 方法干了些什么？\"></a>初次挂载时 mount() 方法干了些什么？</h2><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-1.png\"\n                      class=\"\" title=\"s2-1\"\n                >\n\n<p>首先进入 mount() 方法，它接收 3 个参数：<code>rootContainer</code>，isHydrate，isSVG，我们这里只关注 rootContainer，因为初次挂载时的一般写法是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以看到我们只传了一个字符串，是一个 CSS 选择器。</span></span><br><span class=\"line\"><span class=\"title function_\">createApp</span>(&#123;&#125;).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>再看方法体：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-2.png\"\n                      class=\"\" title=\"s2-2\"\n                >\n\n<p>可以看到首先创建了一个 vnode，这个 vnode 由 createApp 方法传入的根组件确定；然后执行红框中的 render() 方法，我们传入的 rootContainer 作为第二个参数传入。</p>\n<p>让我们看看这个 render 方法，它是 createAppAPI() 方法的第一个参数，上一章介绍过这是 baseCreateRenderer() 这个工厂函数的返回，它在<code>/runtime-core/src/renderer.ts</code>目录下可以找到。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-3.png\"\n                      class=\"\" title=\"s2-3\"\n                >\n\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-4.png\"\n                      class=\"\" title=\"s2-4\"\n                >\n\n<p>接下来找到 render() 方法的方法体：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-5.png\"\n                      class=\"\" title=\"s2-5\"\n                >\n\n<p>可以看到 render() 方法接收三个参数，初次挂载时 vnode 有值，container 是我们 mount() 方法传入的挂载节点。因为 vnode 存在，所以执行 else 部分，可以看到，这里使用了一个<code>patch()</code>方法</p>\n<p>我们来看一下这个 patch() 方法中传了些什么：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-6.png\"\n                      class=\"\" title=\"s2-6\"\n                >\n\n<p>可以看出传入的 container 参数是一个 DOM 对象，在第一次挂载时指向<code>div#app</code>，我们的宿主对象，此时 container._vnode 值为 undefined（在 render 方法的最后才会给_vnode 属性赋值），所以第一个参数值为 null，第二个参数是之前传入的 vnode 对象，长这样：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-7.png\"\n                      class=\"\" title=\"s2-7\"\n                >\n\n<p>之后会用到，此时先不做关注。我们再来看看 patch() 方法内部：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-8.png\"\n                      class=\"\" title=\"s2-8\"\n                >\n\n<!-- \n  YCNOTE：为什么 switch 语句要传入一个对象\n -->\n<p>沿着逻辑往下走到红框部分，此时从我们传入的 vnode（第一次挂载时 mount 方法中新建的 vnode) 中取出 3 个值，根据<code>type</code>和<code>shapeFlag</code>的值进行不同的操作：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-10.png\"\n                      class=\"\" title=\"s2-10\"\n                >\n\n<p>此时 shapeFlag 的值为 4，进行位与运算值为 true。以下<code>位移枚举</code>可以学一下，它的好处是清晰、好计算并且可以进行多值判断。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-11.png\"\n                      class=\"\" title=\"s2-11\"\n                >\n\n<p>初次挂载时执行<code>processComponent()</code>方法，进入方法体 processComponent()：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-12.png\"\n                      class=\"\" title=\"s2-12\"\n                >\n\n<p>可以看到走进 else 代码块，触发方法<code>mountComponent()</code>，见名知意，组件由这个方法挂载。进入该方法，该方法首先会执行一个<code>setupRenderEffect()</code>方法，</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-13.png\"\n                      class=\"\" title=\"s2-13\"\n                >\n\n<p>这个方法创建了一个执行器 <code>effect</code>，然后调用了 effect.run() 方法，当 effect.run() 执行完毕时，整个挂载流程结束。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总结一下，初次挂载时 mount() 方法执行流程大概这样：</p>\n<p>mount()–&gt;createVNode()–&gt;render()–&gt;patch()–&gt;processComponent()–&gt;mountComponent()–&gt;createComponentInstance–&gt;setupRenderEffect()–&gt;ReactiveEffect()–&gt;update()–&gt;effect.run()</p>\n<p>简洁一点就是：</p>\n<p>mount()–&gt;render()–&gt;patch()</p>\n<p>可以通过调用堆栈查看：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-14.png\"\n                      class=\"\" title=\"s2-14\"\n                >\n\n<p>回到最初提的两个问题，第一个问题已经基本解答完毕，第二个问题，mount() 函数在 vue 的生命周期的哪一部分执行也已经可以推想出来：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2022/06/03/vueSourceCodeStudy02/s2-15.png\"\n                      class=\"\" title=\"s2-15\"\n                >\n\n<p>本篇文章就到此为止，因为是初识，所以比较简单，基本上就是跟着调用栈走，之后会更具体的分析 render() 和 patch() 函数。</p>\n<p>若有错误请大佬指出，感激不尽。</p>\n"},{"title":"【Vue3 源码学习】03，初始 mount() 方法","date":"2022-06-03T02:56:48.000Z","_content":"<!-- YCTODO -->","source":"_posts/vueSourceCodeStudy03.md","raw":"---\ntitle: 【Vue3 源码学习】03，初始 mount() 方法\ndate: 2022-06-03 10:56:48\ntags: [vue]\ncategories: [源码]\n---\n<!-- YCTODO -->","slug":"vueSourceCodeStudy03","published":1,"updated":"2023-03-02T13:23:33.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf92ychp00287gh8544wcahq","content":"<!-- YCTODO -->","site":{"data":{}},"excerpt":"","more":"<!-- YCTODO -->"},{"title":"【算法基础】排序","date":"2023-02-13T01:30:57.000Z","_content":"\n![sort](ALGSort/sort.png)\n## 冒泡排序 θ(n^2)\n## 选择排序 θ(n^2)\n`实现逻辑`\n1. 比较相邻的元素，如果第一个比第二个大，交换它们两个\n2. 对每一组相邻元素进行比较交换操作，从第一对到最后一对。结束后最大值在最后一位元素\n3. 重复以上步骤，除了最后一个元素\n4. 持续以上步骤，知道没有任何一对元素需要比较\n\n`伪代码实现`\n```javascript\n// 对数组A进行排序\nSELECTION-SORT(A)\nfor i=0 to A.length-1\n\tkey = A[i]\n\tj = i+1\n\tmin = A[j]\n\tfor(j to A.length)\n\t\tif(min>=A[j])\n\t\t\tmin=A[j]\n\t\t\tidx=j\n\tif(A[i]>min)\n\t\tA[i] = min\n\t\tA[idx] = key\t\t\n```\n`代码实现`\n## 插入排序 θ(n^2)\n`实现逻辑`\n`伪代码实现`\n`代码实现`\n## ","source":"_posts/ALGSort.md","raw":"---\ntitle: 【算法基础】排序\ndate: 2023-02-13 09:30:57\ntags: [JS,算法]\ncategories: [算法]\n---\n\n![sort](ALGSort/sort.png)\n## 冒泡排序 θ(n^2)\n## 选择排序 θ(n^2)\n`实现逻辑`\n1. 比较相邻的元素，如果第一个比第二个大，交换它们两个\n2. 对每一组相邻元素进行比较交换操作，从第一对到最后一对。结束后最大值在最后一位元素\n3. 重复以上步骤，除了最后一个元素\n4. 持续以上步骤，知道没有任何一对元素需要比较\n\n`伪代码实现`\n```javascript\n// 对数组A进行排序\nSELECTION-SORT(A)\nfor i=0 to A.length-1\n\tkey = A[i]\n\tj = i+1\n\tmin = A[j]\n\tfor(j to A.length)\n\t\tif(min>=A[j])\n\t\t\tmin=A[j]\n\t\t\tidx=j\n\tif(A[i]>min)\n\t\tA[i] = min\n\t\tA[idx] = key\t\t\n```\n`代码实现`\n## 插入排序 θ(n^2)\n`实现逻辑`\n`伪代码实现`\n`代码实现`\n## ","slug":"ALGSort","published":1,"updated":"2023-11-23T02:08:34.182Z","_id":"clf946zge0000xwh89dj03rw4","comments":1,"layout":"post","photos":[],"content":"<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2023/02/13/ALGSort/sort.png\"\n                      class=\"\" title=\"sort\"\n                >\n<h2 id=\"冒泡排序-θ-n-2\"><a href=\"#冒泡排序-θ-n-2\" class=\"headerlink\" title=\"冒泡排序 θ(n^2)\"></a>冒泡排序 θ(n^2)</h2><h2 id=\"选择排序-θ-n-2\"><a href=\"#选择排序-θ-n-2\" class=\"headerlink\" title=\"选择排序 θ(n^2)\"></a>选择排序 θ(n^2)</h2><p><code>实现逻辑</code></p>\n<ol>\n<li>比较相邻的元素，如果第一个比第二个大，交换它们两个</li>\n<li>对每一组相邻元素进行比较交换操作，从第一对到最后一对。结束后最大值在最后一位元素</li>\n<li>重复以上步骤，除了最后一个元素</li>\n<li>持续以上步骤，知道没有任何一对元素需要比较</li>\n</ol>\n<p><code>伪代码实现</code></p>\n<div class=\"highlight-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对数组A进行排序</span></span><br><span class=\"line\"><span class=\"variable constant_\">SELECTION</span>-<span class=\"title function_\">SORT</span>(A)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">0</span> to A.<span class=\"property\">length</span>-<span class=\"number\">1</span></span><br><span class=\"line\">\tkey = A[i]</span><br><span class=\"line\">\tj = i+<span class=\"number\">1</span></span><br><span class=\"line\">\tmin = A[j]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j to A.<span class=\"property\">length</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(min&gt;=A[j])</span><br><span class=\"line\">\t\t\tmin=A[j]</span><br><span class=\"line\">\t\t\tidx=j</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(A[i]&gt;min)</span><br><span class=\"line\">\t\tA[i] = min</span><br><span class=\"line\">\t\tA[idx] = key\t\t</span><br></pre></td></tr></table></figure></div>\n<p><code>代码实现</code></p>\n<h2 id=\"插入排序-θ-n-2\"><a href=\"#插入排序-θ-n-2\" class=\"headerlink\" title=\"插入排序 θ(n^2)\"></a>插入排序 θ(n^2)</h2><p><code>实现逻辑</code><br><code>伪代码实现</code><br><code>代码实现</code></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","excerpt":"","more":"<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/2023/02/13/ALGSort/sort.png\"\n                      class=\"\" title=\"sort\"\n                >\n<h2 id=\"冒泡排序-θ-n-2\"><a href=\"#冒泡排序-θ-n-2\" class=\"headerlink\" title=\"冒泡排序 θ(n^2)\"></a>冒泡排序 θ(n^2)</h2><h2 id=\"选择排序-θ-n-2\"><a href=\"#选择排序-θ-n-2\" class=\"headerlink\" title=\"选择排序 θ(n^2)\"></a>选择排序 θ(n^2)</h2><p><code>实现逻辑</code></p>\n<ol>\n<li>比较相邻的元素，如果第一个比第二个大，交换它们两个</li>\n<li>对每一组相邻元素进行比较交换操作，从第一对到最后一对。结束后最大值在最后一位元素</li>\n<li>重复以上步骤，除了最后一个元素</li>\n<li>持续以上步骤，知道没有任何一对元素需要比较</li>\n</ol>\n<p><code>伪代码实现</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对数组A进行排序</span></span><br><span class=\"line\"><span class=\"variable constant_\">SELECTION</span>-<span class=\"title function_\">SORT</span>(A)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i=<span class=\"number\">0</span> to A.<span class=\"property\">length</span>-<span class=\"number\">1</span></span><br><span class=\"line\">\tkey = A[i]</span><br><span class=\"line\">\tj = i+<span class=\"number\">1</span></span><br><span class=\"line\">\tmin = A[j]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j to A.<span class=\"property\">length</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(min&gt;=A[j])</span><br><span class=\"line\">\t\t\tmin=A[j]</span><br><span class=\"line\">\t\t\tidx=j</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(A[i]&gt;min)</span><br><span class=\"line\">\t\tA[i] = min</span><br><span class=\"line\">\t\tA[idx] = key\t\t</span><br></pre></td></tr></table></figure>\n<p><code>代码实现</code></p>\n<h2 id=\"插入排序-θ-n-2\"><a href=\"#插入排序-θ-n-2\" class=\"headerlink\" title=\"插入排序 θ(n^2)\"></a>插入排序 θ(n^2)</h2><p><code>实现逻辑</code><br><code>伪代码实现</code><br><code>代码实现</code></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"}],"PostAsset":[{"_id":"source/_posts/MethodologyFrontendEngineering/s0.png","slug":"s0.png","post":"clf92ycgw00097gh81wl09fyl","modified":0,"renderable":0},{"_id":"source/_posts/MethodologyFrontendEngineering/s1.png","slug":"s1.png","post":"clf92ycgw00097gh81wl09fyl","modified":0,"renderable":0},{"_id":"source/_posts/MethodologyFrontendEngineering/s2.png","slug":"s2.png","post":"clf92ycgw00097gh81wl09fyl","modified":0,"renderable":0},{"_id":"source/_posts/MethodologyFrontendEngineering/s3.png","slug":"s3.png","post":"clf92ycgw00097gh81wl09fyl","modified":0,"renderable":0},{"_id":"source/_posts/MethodologyFrontendEngineering/s4-1.png","slug":"s4-1.png","post":"clf92ycgw00097gh81wl09fyl","modified":0,"renderable":0},{"_id":"source/_posts/MethodologyFrontendEngineering/s4.png","slug":"s4.png","post":"clf92ycgw00097gh81wl09fyl","modified":0,"renderable":0},{"_id":"source/_posts/MethodologyFrontendEngineering/s5.png","slug":"s5.png","post":"clf92ycgw00097gh81wl09fyl","modified":0,"renderable":0},{"_id":"source/_posts/PracticePromise/s1.png","slug":"s1.png","post":"clf92ychc00117gh8fssk060g","modified":0,"renderable":0},{"_id":"source/_posts/ReprintAngularOptimization/angular-performance01.png","slug":"angular-performance01.png","post":"clf92ychd00137gh8aaxm561w","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop01.png","slug":"js-eventloop01.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop02.png","slug":"js-eventloop02.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop03.png","slug":"js-eventloop03.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop04.png","slug":"js-eventloop04.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop05.png","slug":"js-eventloop05.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop06.png","slug":"js-eventloop06.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop07.png","slug":"js-eventloop07.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop08.png","slug":"js-eventloop08.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop09.png","slug":"js-eventloop09.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop10.png","slug":"js-eventloop10.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop11.png","slug":"js-eventloop11.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop12.png","slug":"js-eventloop12.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop13.png","slug":"js-eventloop13.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop14.png","slug":"js-eventloop14.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop15.png","slug":"js-eventloop15.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop16.png","slug":"js-eventloop16.png","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/ReprintJSEventLoop/js-eventloop17.jpg","slug":"js-eventloop17.jpg","post":"clf92yche00157gh83d8zfmkw","modified":0,"renderable":0},{"_id":"source/_posts/someInterestingQuestions01/q1.png","slug":"q1.png","post":"clf92ychi001i7gh89g3s1apj","modified":0,"renderable":0},{"_id":"source/_posts/someInterestingQuestions01/q2.png","slug":"q2.png","post":"clf92ychi001i7gh89g3s1apj","modified":0,"renderable":0},{"_id":"source/_posts/someInterestingQuestions01/q3.png","slug":"q3.png","post":"clf92ychi001i7gh89g3s1apj","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy01/s0.jpg","slug":"s0.jpg","post":"clf92ychn00217gh86veq2wpm","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy01/s1-1.png","slug":"s1-1.png","post":"clf92ychn00217gh86veq2wpm","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy01/s1-2.png","slug":"s1-2.png","post":"clf92ychn00217gh86veq2wpm","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy01/s1-3.png","slug":"s1-3.png","post":"clf92ychn00217gh86veq2wpm","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy01/s1-4.png","slug":"s1-4.png","post":"clf92ychn00217gh86veq2wpm","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy01/s1-5.png","slug":"s1-5.png","post":"clf92ychn00217gh86veq2wpm","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy01/s1-6.png","slug":"s1-6.png","post":"clf92ychn00217gh86veq2wpm","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s0.png","slug":"s0.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-1.png","slug":"s2-1.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-10.png","slug":"s2-10.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-11.png","slug":"s2-11.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-12.png","slug":"s2-12.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-13.png","slug":"s2-13.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-14.png","slug":"s2-14.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-15.png","slug":"s2-15.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-2.png","slug":"s2-2.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-3.png","slug":"s2-3.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-4.png","slug":"s2-4.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-5.png","slug":"s2-5.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-6.png","slug":"s2-6.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-7.png","slug":"s2-7.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-8.png","slug":"s2-8.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/vueSourceCodeStudy02/s2-9.png","slug":"s2-9.png","post":"clf92ycho00257gh8c5mpglx6","modified":0,"renderable":0},{"_id":"source/_posts/ALGSort/sort.png","slug":"sort.png","post":"clf946zge0000xwh89dj03rw4","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clf92ycgo00017gh88oc5fjzm","category_id":"clf92ycgs00047gh8g31sgu9q","_id":"clf92ych0000h7gh85umz7k3q"},{"post_id":"clf92ycgz000f7gh809yehfz3","category_id":"clf92ycgx000c7gh81gvl9aw9","_id":"clf92ych1000m7gh80e6w2t0s"},{"post_id":"clf92ycgq00037gh88ll8cv8b","category_id":"clf92ycgx000c7gh81gvl9aw9","_id":"clf92ych1000q7gh8cjb6bb73"},{"post_id":"clf92ycgu00077gh8cq9b7url","category_id":"clf92ycgx000c7gh81gvl9aw9","_id":"clf92ych2000s7gh8f7v5ccpm"},{"post_id":"clf92ycgw00097gh81wl09fyl","category_id":"clf92ycgx000c7gh81gvl9aw9","_id":"clf92ych2000v7gh81yfd963o"},{"post_id":"clf92ycgx000b7gh8f98z68jh","category_id":"clf92ycgx000c7gh81gvl9aw9","_id":"clf92ych2000w7gh822uvgy7w"},{"post_id":"clf92ychb000y7gh8e0w7dhm3","category_id":"clf92ycgx000c7gh81gvl9aw9","_id":"clf92yche00167gh8bu6n80q1"},{"post_id":"clf92ychb000x7gh8duge7j9f","category_id":"clf92ychc000z7gh8dpq49j9g","_id":"clf92ychg001d7gh8bhxb186o"},{"post_id":"clf92ychc00117gh8fssk060g","category_id":"clf92ychc000z7gh8dpq49j9g","_id":"clf92ychj001j7gh80obu75nf"},{"post_id":"clf92ychg001f7gh87c6i3l57","category_id":"clf92ychg001c7gh81fs88bja","_id":"clf92ychk001o7gh80hd3cud2"},{"post_id":"clf92ychd00137gh8aaxm561w","category_id":"clf92ychg001c7gh81fs88bja","_id":"clf92ychl001t7gh80kfyb6q5"},{"post_id":"clf92yche00157gh83d8zfmkw","category_id":"clf92ychg001c7gh81fs88bja","_id":"clf92ychm001x7gh84m4i6pxr"},{"post_id":"clf92ychf00197gh86shpb4av","category_id":"clf92ychg001c7gh81fs88bja","_id":"clf92ycho00237gh87ykebzcd"},{"post_id":"clf92ychf001b7gh8gvz52p8q","category_id":"clf92ychg001c7gh81fs88bja","_id":"clf92ychp00297gh86885djhj"},{"post_id":"clf92ychi001i7gh89g3s1apj","category_id":"clf92ycho00227gh894oj8niu","_id":"clf92ychq002e7gh85f34fpau"},{"post_id":"clf92ychj001l7gh8euoe5tgf","category_id":"clf92ycho00227gh894oj8niu","_id":"clf92ychr002i7gh8f83afacf"},{"post_id":"clf92ychk001n7gh84drg6dxk","category_id":"clf92ycho00227gh894oj8niu","_id":"clf92ychr002l7gh889z40v6b"},{"post_id":"clf92ychl001s7gh8c07k12p3","category_id":"clf92ycho00227gh894oj8niu","_id":"clf92ychr002o7gh85m5tf7k0"},{"post_id":"clf92ychm001v7gh8ebp2503p","category_id":"clf92ycho00227gh894oj8niu","_id":"clf92ychs002q7gh8ddlnftg7"},{"post_id":"clf92ychn001z7gh8e1fwdcqb","category_id":"clf92ycho00227gh894oj8niu","_id":"clf92ychs002r7gh8fb30556z"},{"post_id":"clf92ychn00217gh86veq2wpm","category_id":"clf92ychs002p7gh8eld8248t","_id":"clf92ycht002u7gh85yc55bgb"},{"post_id":"clf92ycho00257gh8c5mpglx6","category_id":"clf92ychs002p7gh8eld8248t","_id":"clf92ycht002v7gh82972djj4"},{"post_id":"clf92ychp00287gh8544wcahq","category_id":"clf92ychs002p7gh8eld8248t","_id":"clf92ycht002w7gh8hlbh59y9"},{"post_id":"clf946zge0000xwh89dj03rw4","category_id":"clp9vmgcj0000mkh81fwifzma","_id":"clp9vmgck0001mkh8ecvpgey9"}],"PostTag":[{"post_id":"clf92ycgw00097gh81wl09fyl","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ycgz000e7gh80nhkffsc"},{"post_id":"clf92ycgo00017gh88oc5fjzm","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ycgz000g7gh8ax5veo3p"},{"post_id":"clf92ycgx000b7gh8f98z68jh","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ych0000k7gh8az0754b6"},{"post_id":"clf92ycgq00037gh88ll8cv8b","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ych1000l7gh86jj7g0rx"},{"post_id":"clf92ycgu00077gh8cq9b7url","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ych1000p7gh8d0hl3up8"},{"post_id":"clf92ycgz000f7gh809yehfz3","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ych2000t7gh830zz8ipy"},{"post_id":"clf92ycgz000f7gh809yehfz3","tag_id":"clf92ych1000n7gh87w1h3qms","_id":"clf92ych2000u7gh8dr376zvm"},{"post_id":"clf92ychb000x7gh8duge7j9f","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychc00107gh8c99octug"},{"post_id":"clf92ychb000y7gh8e0w7dhm3","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychd00127gh8dtywhze5"},{"post_id":"clf92ychc00117gh8fssk060g","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92yche00147gh82l046p4t"},{"post_id":"clf92yche00157gh83d8zfmkw","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychf001a7gh88wbtgq9y"},{"post_id":"clf92ychf00197gh86shpb4av","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychg001e7gh80w7b5xdr"},{"post_id":"clf92ychd00137gh8aaxm561w","tag_id":"clf92ychf00187gh8h4yn7gun","_id":"clf92ychi001h7gh8a7h80ayt"},{"post_id":"clf92ychi001i7gh89g3s1apj","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychk001m7gh8bgzlfab1"},{"post_id":"clf92ychj001l7gh8euoe5tgf","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychl001r7gh8bali8c0t"},{"post_id":"clf92ychf001b7gh8gvz52p8q","tag_id":"clf92ychh001g7gh8g5hacff5","_id":"clf92ychm001u7gh8fubq02fy"},{"post_id":"clf92ychk001n7gh84drg6dxk","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychn001y7gh81xa1dtgq"},{"post_id":"clf92ychl001s7gh8c07k12p3","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychn00207gh8axbbhig1"},{"post_id":"clf92ychg001f7gh87c6i3l57","tag_id":"clf92ychk001p7gh80km00g1b","_id":"clf92ycho00247gh841f62vgm"},{"post_id":"clf92ychm001v7gh8ebp2503p","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ycho00277gh8hb8ncqf6"},{"post_id":"clf92ychn001z7gh8e1fwdcqb","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf92ychp002b7gh83v047jcl"},{"post_id":"clf92ychn00217gh86veq2wpm","tag_id":"clf92ycho00267gh8aytdgswt","_id":"clf92ychq002f7gh8aqdfddg5"},{"post_id":"clf92ycho00257gh8c5mpglx6","tag_id":"clf92ycho00267gh8aytdgswt","_id":"clf92ychr002j7gh89e10935g"},{"post_id":"clf92ychp00287gh8544wcahq","tag_id":"clf92ycho00267gh8aytdgswt","_id":"clf92ychr002m7gh8gagg4ssp"},{"post_id":"clf946zge0000xwh89dj03rw4","tag_id":"clf92ycgu00057gh87qvcbpoj","_id":"clf946zgl0002xwh83r8j82pu"},{"post_id":"clf946zge0000xwh89dj03rw4","tag_id":"clp8d9qph00008ch86s30dizg","_id":"clp8d9qpl00018ch84vyl7epe"}],"Tag":[{"name":"JS","_id":"clf92ycgu00057gh87qvcbpoj"},{"name":"前端工程化","_id":"clf92ych1000n7gh87w1h3qms"},{"name":"angular","_id":"clf92ychf00187gh8h4yn7gun"},{"name":"browser","_id":"clf92ychh001g7gh8g5hacff5"},{"name":"typescript","_id":"clf92ychk001p7gh80km00g1b"},{"name":"vue","_id":"clf92ycho00267gh8aytdgswt"},{"name":"算法","_id":"clp8d9qph00008ch86s30dizg"}]}}