<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="ped-Yc"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://ped-yc.github.io/2021/03/02/reprintbrowserrender/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="原文转自：https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000014018604   线程和进程进程和线程的概念可以这样理解： 进程是一个工厂，工厂有它的独立资源 – 工厂之间相互独立 – 线程是工厂中的工人，多个工人协作完成任务 – 工厂内有一个或多个工人 – 工人之间共享空间 工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。  进程是cpu资源分配的最"><meta property="og:type" content="article"><meta property="og:title" content="【转载】浏览器渲染机制"><meta property="og:url" content="https://ped-yc.github.io/2021/03/02/ReprintBrowserRender/index.html"><meta property="og:site_name" content="ped-Yc&#39;s Blog"><meta property="og:description" content="原文转自：https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000014018604   线程和进程进程和线程的概念可以这样理解： 进程是一个工厂，工厂有它的独立资源 – 工厂之间相互独立 – 线程是工厂中的工人，多个工人协作完成任务 – 工厂内有一个或多个工人 – 工人之间共享空间 工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。  进程是cpu资源分配的最"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://segmentfault.com/img/bV6ZbY?w=834&h=742"><meta property="og:image" content="https://segmentfault.com/img/bV6RM7?w=864&h=471"><meta property="og:image" content="https://segmentfault.com/img/bV6ZLo?w=655&h=608"><meta property="og:image" content="https://segmentfault.com/img/bV66KM?w=1034&h=560"><meta property="og:image" content="https://segmentfault.com/img/bV6WyG?w=716&h=506"><meta property="og:image" content="https://segmentfault.com/img/bV6WOP?w=703&h=509"><meta property="og:image" content="https://segmentfault.com/img/bV6YSS?w=506&h=570"><meta property="og:image" content="https://segmentfault.com/img/bV7W88?w=479&h=457"><meta property="article:published_time" content="2021-03-02T12:13:22.000Z"><meta property="article:modified_time" content="2024-07-11T03:17:03.552Z"><meta property="article:author" content="ped-Yc"><meta property="article:tag" content="browser"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://segmentfault.com/img/bV6ZbY?w=834&h=742"><link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/redefine-favicon.svg"><title>【转载】浏览器渲染机制 - ped-Yc&#39;s Blog</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/assets/build/styles.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><script src="/js/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"ped-yc.github.io",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/bg01.webp"},title:"Welcome to ped-Yc's Blog",subtitle:{text:["Welcome to ped-Yc's Blog"],hitokoto:{enable:!0,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.6.4",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Archives:{path:"/archives",icon:"fa-regular fa-archive"},Categories:{path:"/categories",icon:"fa-regular fa-layer-group"},Tags:{path:"/tags",icon:"fa-regular fa-tags"},About:{icon:"fa-regular fa-user",submenus:{Me:"/about",Github:"https://github.com/ped-Yc"}}},search:{enable:!1,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/8/17 11:45:14"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">ped-Yc&#39;s Blog</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [40,0],
                translateZ: 0,
                opacity: [0,1],
                filter: ['blur(5px)', 'blur(0px)'], // Starting from blurred to unblurred
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i,
            }).add({
                targets: '.ml13 .letter',
                translateY: [0,-40],
                opacity: [1,0],
                filter: ['blur(0px)', 'blur(5px)'], // Ending from unblurred to blurred
                easing: "easeInExpo",
                duration: 1200,
                delay: (el, i) => 100 + 30 * i,
                complete: function() {
                    hidePreloader(); // Call hidePreloader after the animation completes
                }
            });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content"><div class="left"><a class="logo-image" href="/"><img src="/images/avatar.jpeg"> </a><a class="logo-title" href="/">ped-Yc&#39;s Blog</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a href="/categories"><i class="fa-regular fa-layer-group fa-fw"></i> 分类</a></li><li class="navbar-item"><a href="/tags"><i class="fa-regular fa-tags fa-fw"></i> 标签</a></li><li class="navbar-item"><a class="has-dropdown" href="#" onclick="&#34;return" false;&#34;><i class="fa-regular fa-user fa-fw"></i> 关于 <i class="fa-solid fa-chevron-down fa-fw"></i></a><ul class="sub-menu"><li><a href="/about">ME</a></li><li><a target="_blank" rel="noopener" href="https://github.com/ped-Yc">GITHUB</a></li></ul></li></ul></div><div class="mobile"><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories"><span>分类 </span><i class="fa-regular fa-layer-group fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/tags"><span>标签 </span><i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full"><div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" navbar-data-toggle="submenu-About"><span>关于 </span><i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i></div><div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About"><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/about">ME</a></div><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" target="_blank" rel="noopener" href="https://github.com/ped-Yc">GITHUB</a></div></div></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">26</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">【转载】浏览器渲染机制</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/avatar.jpeg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">ped-Yc</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2021-03-02 20:13:22</span> <span class="mobile">2021-03-02 20:13:22</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-07-11 11:17:03</span> <span class="mobile">2024-07-11 11:17:03</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/browser/">browser</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>6.2k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>21 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><blockquote><p>原文转自：<a class="link" target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014018604">https://segmentfault.com/a/1190000014018604 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程和线程的概念可以这样理解：</p><p>进程是一个工厂，工厂有它的独立资源 – 工厂之间相互独立 – 线程是工厂中的工人，多个工人协作完成任务 – 工厂内有一个或多个工人 – 工人之间共享空间</p><p>工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。</p><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV6ZbY?w=834&h=742"></p><p>进程是<code>cpu</code>资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存）<br>线程是<code>cpu</code>调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）</p><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV6RM7?w=864&h=471"></p><p>浏览器是多进程的，每打开一个<code>tab</code>页，就相当于创建了一个独立的浏览器进程。</p><h3 id="浏览器包含的进程："><a href="#浏览器包含的进程：" class="headerlink" title="浏览器包含的进程："></a>浏览器包含的进程：</h3><ol><li><p><code>Browser</code>进程：浏览器的主进程（负责协调，主控），只有一个，作用有：</p><ul><li>负责浏览器的界面显示，与用户交互，如前进，后退等</li><li>负责各个页面的管理，创建和销毁其它进程</li><li>将<code>Rendered</code>进程得到的内存中的<code>Bitmap</code>, 绘制到用户界面上</li><li>网络资源的管理，下载</li></ul></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</p></li><li><p><code>GPU</code>进程：最多一个，用于<code>3D</code>绘制等。</p></li><li><p>浏览器渲染进程（浏览器内核）（<code>Render</code>进程，内部是多线程的）：默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为：</p><ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ol><p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p><h3 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h3><ul><li>避免单个<code>page crash</code>影响整个浏览器</li><li>避免第三方插件<code>crash</code>影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li></ul><p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器；<br>当然，内存等资源消耗也会更大，像空间换时间一样。</p><h2 id="重点是浏览器内核（渲染进程）"><a href="#重点是浏览器内核（渲染进程）" class="headerlink" title="重点是浏览器内核（渲染进程）"></a>重点是浏览器内核（渲染进程）</h2><p>对于普通的前端操作来说，最重要的<strong>渲染进程</strong>：页面的渲染，<code>js</code>的执行，事件的循环等都在这个进程内执行；<br><strong>浏览器是多进程的，浏览器的渲染进程是多线程的；</strong></p><h3 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a><code>GUI</code>渲染线程</h3><ul><li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>, 构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li><li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li><li>注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li></ul><h3 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a><code>JS</code>引擎线程</h3><ul><li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code>引擎）。</li><li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li><li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</li><li>同样注意，<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h3 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h3><ul><li>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</li><li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li><li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li></ul><h3 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h3><ul><li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li><li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li><li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li></ul><h3 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步<code>http</code>请求线程</h3><ul><li>在<code>XMLHttpRequest</code>在连接后是通过浏览器新型一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由<code>JavaScript</code>引擎执行</li></ul><p>总结下来，渲染进程如下：</p><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV6ZLo?w=655&h=608"></p><h3 id="Browser-主进程和浏览器内核（渲染进程）的通信过程"><a href="#Browser-主进程和浏览器内核（渲染进程）的通信过程" class="headerlink" title="Browser 主进程和浏览器内核（渲染进程）的通信过程"></a>Browser 主进程和浏览器内核（渲染进程）的通信过程</h3><p>打开一个浏览器，可以看到：任务管理器出现了 2 个进程（一个主进程，一个是打开<code>Tab</code>页的渲染进程）；</p><ul><li><code>Browser</code>主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）, 随后将该任务通过<code>RendererHost</code>接口传递给<code>Render</code>渲染进程</li><li><code>Render</code>渲染进程的<code>Renderer</code>接口收到消息，简单解释后，交给渲染线程<code>GUI</code>，然后开始渲染</li><li><code>GUI</code>渲染线程接收请求，加载网页并渲染网页，这其中可能需要<code>Browser</code>主进程获取资源和需要<code>GPU</code>进程来帮助渲染</li><li>当然可能会有<code>JS</code>线程操作<code>DOM</code>（这可能会造成回流并重绘）</li><li>最后<code>Render</code>渲染进程将结果传递给<code>Browser</code>主进程</li><li><code>Browser</code>主进程接收到结果并将结果绘制出来</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV66KM?w=1034&h=560"></p><h3 id="浏览器内核（渲染进程）中线程之间的关系"><a href="#浏览器内核（渲染进程）中线程之间的关系" class="headerlink" title="浏览器内核（渲染进程）中线程之间的关系"></a>浏览器内核（渲染进程）中线程之间的关系</h3><p><strong>GUI 渲染线程与 JS 引擎线程互斥</strong></p><p>由于<code>JavaScript</code>是可操作<code>DOM</code>的，如果在修改这些元素属性同时渲染界面（即<code>JS</code>线程和<code>GUI</code>线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此，为了防止渲染出现不可预期的结果，浏览器就设置了互斥的关系，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起。<code>GUI</code>更新则会被保存在一个队列中等到<code>JS</code>引擎线程空闲时立即被执行。</p><p><strong>JS 阻塞页面加载</strong></p><p>从上述的互斥关系，可以推导出，<code>JS</code>如果执行时间过长就会阻塞页面。</p><p>譬如，假设<code>JS</code>引擎正在进行巨量的计算，此时就算<code>GUI</code>有更新，也会被保存在队列中，要等到<code>JS</code>引擎空闲后执行。然后由于巨量计算，所以<code>JS</code>引擎可能很久很久才能空闲，肯定就会感觉很卡。</p><p>所以，要尽量避免<code>JS</code>执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><p><strong><code>css</code>加载是否会阻塞<code>dom</code>树渲染</strong></p><p>这里说的是头部引入<code>css</code>的情况<br>首先，我们都知道：<code>css</code>是由单独的下载线程异步下载的。<br>然后还有几个现象：</p><ol><li><code>css</code>加载不会阻塞<code>DOM</code>树解析（异步加载时<code>dom</code>照常构建）</li><li>但会阻塞<code>render</code>树渲染（渲染时需要等<code>css</code>加载完毕，因为<code>render</code>树需要<code>css</code>信息）</li></ol><p>这可能也是浏览器的一种优化机制<br>因为你加载<code>css</code>的时候，可能会修改下面<code>DOM</code>节点的样式，如果<code>css</code>加载不阻塞<code>render</code>树渲染的话，那么当<code>css</code>加载完之后，<code>render</code>树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗<br>所以干脆把<code>DOM</code>树的结构先解析完，把可以做的工作做完，然后等<code>css</code>加载完之后，在根据最终的样式来渲染<code>render</code>树，这种做法确实对性能好一点。</p><p><strong><code>WebWorker</code>,<code>JS</code>的多线程？</strong></p><p>前文中有提到<code>JS</code>引擎是单线程的，而且<code>JS</code>执行时间过长会阻塞页面，那么<code>JS</code>就真的对<code>cpu</code>密集型计算无能为力么？</p><p>所以，后来<code>HTML5</code>中支持了<code>WebWorker</code>。</p><p>这样理解下：</p><p>创建<code>Worker</code>时，<code>JS</code>引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作<code>DOM</code>）<br><code>JS</code>引擎线程与<code>worker</code>线程间通过特定的方式通信（<code>postMessage API</code>，需要通过序列化对象来与线程交互特定的数据）</p><p>所以，如果有非常耗时的工作，请单独开一个<code>Worker</code>线程，这样里面不管如何翻天覆地都不会影响<code>JS</code>引擎主线程，只待计算出结果后，将结果通信给主线程即可，<code>perfect!</code></p><p>而且注意下，<code>JS</code>引擎是单线程的，这一点的本质仍然未改变，<code>Worker</code>可以理解是浏览器给<code>JS</code>引擎开的外挂，专门用来解决那些大量计算问题。</p><p><strong><code>WebWorker</code>与<code>SharedWorker</code></strong></p><p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p><p><code>WebWorker</code>只属于某个页面，不会和其他页面的<code>Render</code>进程（浏览器内核进程）共享<br>所以<code>Chrome</code>在<code>Render</code>进程中（每一个<code>Tab</code>页就是一个<code>render</code>进程）创建一个新的线程来运行<code>Worker</code>中的<code>JavaScript</code>程序。</p><p><code>SharedWorker</code>是浏览器所有页面共享的，不能采用与<code>Worker</code>同样的方式实现，因为它不隶属于某个<code>Render</code>进程，可以为多个<code>Render</code>进程共享使用<br>所以<code>Chrome</code>浏览器为<code>SharedWorker</code>单独创建一个进程来运行<code>JavaScript</code>程序，在浏览器中每个相同的<code>JavaScript</code>只存在一个<code>SharedWorker</code>进程，不管它被创建多少次。</p><p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。<code>SharedWorker</code>由独立的进程管理，<code>WebWorker</code>只是属于<code>render</code>进程下的一个线程</p><h3 id="总结浏览器渲染流程"><a href="#总结浏览器渲染流程" class="headerlink" title="总结浏览器渲染流程"></a>总结浏览器渲染流程</h3><p>浏览器输入<code>url</code>，浏览器主进程接管，开一个下载线程，然后进行<code>http</code>请求（略去<code>DNS</code>查询，<code>IP</code>寻址等等操作），然后等待响应，获取内容，随后将内容通过<code>RendererHost</code>接口转交给<code>Render</code>进程 – 浏览器渲染流程开始</p><p>浏览器内核拿到内容后，渲染大概可以划分为：</p><ol><li>解析<code>html</code>建立<code>dom</code>要</li><li>解析<code>css</code>构建<code>render</code>树（将<code>css</code>代码解析成树形的数据结构，然后结合<code>dom</code>合并成<code>render</code>树）</li><li>布局<code>render</code>树（<code>Layout/reflow</code>）, 负责各元素尺寸，位置的计算</li><li>绘制<code>render</code>树（<code>paint</code>），绘制页面像素信息</li><li>浏览器会将各层的信息发送给<code>GPU</code>，<code>GPU</code>会将各层合成（<code>composite</code>）, 显示在屏幕上</li></ol><p>渲染完毕后就是<code>load</code>事件了，之后就是自己的<code>JS</code>逻辑处理了，略去了详细步骤。</p><p><strong><code>load</code>事件与<code>DOMContentLoaded</code>事件的先后</strong></p><p>上面提到，渲染完毕后会触发<code>load</code>事件，那么你能分清楚<code>load</code>事件与<code>DOMContentLoaded</code>事件的先后么？</p><p>很简单，知道它们的定义就可以了：</p><p>当 <code>DOMContentLoaded</code> 事件触发时，仅当<code>DOM</code>加载完成，不包括样式表，图片。<br>（譬如如果有<code>async</code>加载的脚本就不一定完成）</p><p>当 <code>onload</code> 事件触发时，页面上所有的<code>DOM</code>，样式表，脚本，图片都已经加载完成了。（渲染完毕了）</p><p>所以，顺序是：<code>DOMContentLoaded</code> -&gt; <code>load</code></p><h3 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h3><p>渲染步骤就提到了<code>composite</code>概念；浏览器渲染的图层一般包含两大类：普通图层以及复合图层。</p><ol><li>普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）</li><li><code>absolute</code>布局（<code>fixed</code>也一样），虽然可以脱离文档流，但它仍然属于默认复合层</li><li>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li></ol><p>可以简单理解下：<code>GPU</code>中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p><p><strong>如何变成复合图层（硬件加速）</strong></p><p>将元素变成一个复合图层，就是传说中的硬件加速技术</p><ul><li>最常用的方式：<code>translate3d</code>,<code>translatez</code></li><li><code>opacity</code>属性 &#x2F; 过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li><li><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li><li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li><li>其它，譬如以前的<code>flash</code>插件</li></ul><p><strong><code>absolute</code>和硬件加速的区别</strong></p><p>可以看到，<code>absolute</code>虽然可以脱离普通文档流，但是无法脱离默认复合层。</p><p>所以，就算<code>absolute</code>中信息改变时不会改变普通文档流中<code>render</code>树，但是，浏览器最终绘制时，是整个复合层绘制的，所以<code>absolute</code>中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，<code>absolute</code>带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><p><strong>复合图层的作用</strong></p><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。<br>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p><p><strong>硬件加速时请使用<code>index</code></strong></p><p>使用硬件加速时，尽可能的使用 index, 防止浏览器默认给后续的元素创建复合层渲染<br>具体的原理是：<br><code>webkit CSS3</code>中，如果这个元素添加了硬件加速，并且<code>index</code>层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且<code>relective</code>或<code>absolute</code>属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能</p><p>简单点理解，可以认为是一个隐式合成的概念：如果 a 是一个复合层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层，这点需要特别注意</p><h2 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从<code>Event Loop</code>谈<code>JS</code>的运行机制</h2><p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，<code>JS</code>引擎的一些运行机制分析。主要是结合<code>Event Loop</code>来谈<code>JS</code>代码是如何执行的。<br>我们已经知道了<code>JS</code>引擎是单线程的，知道了<code>JS</code>引擎线程，事件触发线程，定时触发器线程。<br>然后还需要知道：</p><ul><li><code>JS</code>分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件</li><li>一旦执行栈中的所有同步任务执行完毕（此时<code>JS</code>引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV6WyG?w=716&h=506"></p><p>看到这里，应该就可以理解了：为什么有时候<code>setTimeOut</code>推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以就必须等待，自然有误差。</p><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV6WOP?w=703&h=509"></p><p>主线程在运行时会产生执行栈，栈中的代码调用某些<code>api</code>时，它们会在事件队列中添加各种事件（当满足触发条件后，如<code>ajax</code>请求完毕）。而当栈中的代码执行完毕，就会去读取事件队列中的事件，去执行那些回调，如此循环。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>上面事件循环机制的核心是：<code>JS</code>引擎线程和事件触发线程</p><p>调用<code>setTimeout</code>后，是由定时器线程控制等到特定时间后添加到事件队列的，因为<code>JS</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时准确，因此很有必要另开一个线程用来计时。</p><p>当使用<code>setTimout</code>或<code>setInterval</code>时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p><p>如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;console.log(&#x27;hello!),1000)</span><br><span class="line">//等 1000 毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(&#x27;begin&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行。</p><p>注意：</p><ol><li>执行结果是：先<code>begin</code>，后<code>hello</code></li><li>虽然代码的本意是<code>0</code>毫秒就推入事件队列，但是<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code></li><li>就算不等待<code>4ms</code>，就算假设<code>0</code>毫秒就推入事件队列，也会先执行<code>begin</code>（因为只能可执行栈内空了后才会主动读取事件队列）</li></ol><p><strong><code>setInterval</code></strong></p><p>用<code>setTimeout</code>模拟定期计时和直接用<code>setInterval</code>是有区别的：</p><ul><li>每次<code>setTimeout</code>计时到后就会去执行，然后执行一段时间后才会继续<code>setTimeout</code>, 中间就多了误差</li><li>而<code>setInterval</code>则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</li></ul><p>而且<code>setInterval</code>有一些比较致命的问题：</p><ul><li>累积效应，如果<code>setInterval</code>代码在<code>setInterval</code>再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔，就算正常间隔执行，多个<code>setInterval</code>的代码执行时间可能会比预期小（因为代码执行需要一定时间）</li><li>比如你<code>ios</code>的<code>webview</code>，或者<code>safari</code>等浏览器中都有一人特点，在滚动的时候是不执行<code>JS</code>的，如果使用了<code>setInterval</code>，会发现在滚动结束后会执行多次由于滚动不执行<code>JS</code>积攒回调，如果回调执行时间过长，就会非常容易造成卡顿问题和一些不可知的错误（<code>setInterval</code>自带的优化，如果当前事件队列中有<code>setInterval</code>的回调，不会重复添加回调）</li><li>而且把浏览器最小化显示等操作时，<code>setInterval</code>并不是不执行程序，它会把<code>setInterval</code>的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行</li></ul><p>所以，至于这么问题，一般认为的最佳方案是：用<code>setTimeout</code>模拟<code>setInterval</code>或者特殊场合直接用<code>requestAnimationFrame</code></p><h3 id="Promise时代的microtask与macrotask"><a href="#Promise时代的microtask与macrotask" class="headerlink" title="Promise时代的microtask与macrotask"></a><code>Promise</code>时代的<code>microtask</code>与<code>macrotask</code></h3><p>在<code>es6</code>盛行的现在，可以看下这题：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;,0);</span><br><span class="line"></span><br><span class="line">Promise.resolve()</span><br><span class="line">.then(()=&gt;console.log(&#x27;promise1&#x27;))</span><br><span class="line">.then(()=&gt;console.log(&#x27;promise2&#x27;))</span><br><span class="line"></span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line"></span><br><span class="line">//执行结果：</span><br><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>因为<code>promise</code>有一个新的概念<code>microtask</code>. 或者可以说<code>JS</code>中分为两种任务：<code>macrotask</code>和<code>microtask</code>;<br>理解如下：</p><ul><li><code>macrotask</code>（又叫宏任务）, 主代码块，<code>setTimeout</code>,<code>setInterval</code>等（可以看到，事件队列中的每一个事件都是一个<code>macrotask</code>）</li><li>可以理解是每次执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li><li>第一个<code>macrotask</code>会从头到尾将这个任务执行完毕，不会执行其它</li><li>浏览器为了能够使得<code>JS</code>内部<code>macrotask</code>与<code>DOM</code>任务能够有序的执行，会在一个<code>macrotask</code>执行结束后，在下一个<code>macrotask</code>执行开始前，对页面进行重新渲染（<code>task</code>-&gt; 渲染 -&gt;<code>task</code>-&gt;…）</li><li><code>microtask</code>（又叫微任务），<code>Promise</code>,<code>process.nextTick</code>等。</li><li>可以理解是在当前<code>macrotask</code>执行结束后立即执行的任务</li><li>也就是说在当前<code>macrotask</code>任务后，下一个<code>macrotask</code>之前，在渲染之前</li><li>所以它的响应速度相比<code>setTimeout</code>(<code>setTimeout</code>是<code>macrotask</code>) 会更快因为无需等待渲染</li><li>也就是说，在某一个<code>macrotask</code>执行完成后，就会将在它执行期间产生的所有<code>microtask</code>都执行完毕（在渲染前）</li></ul><p>注意：在<code>Node</code>环境下，<code>process.nextTick</code>的优先级高于<code>promise</code>. 也就是：在宏任务结束后会先执行微任务队列中的<code>nextTick</code>部分，然后才会执行微任务中的<code>promise</code>部分。</p><p>另外，<code>setImmediate</code>则是规定：在下一次<code>Event Loop</code>（宏任务）时触发（所以它是属于优先级较高的宏任务），（<code>Node.js</code>文档中称，<code>setImmediate</code>指定的回调函数，总是排在<code>setTimeout</code>前面），所以<code>setImmediate</code>如果嵌套的话，是需要经过多个<code>Loop</code>才能完成的，而不会像<code>process.nextTick</code>一样没完没了。</p><p>可以理解：</p><ul><li><code>macrotask</code>中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护。</li><li><code>microtask</code>中的所有微任务都是添加到微任务队列中，等待当前<code>macrotask</code>执行完后执行，而这个队列由<code>JS</code>引擎线程维护。</li></ul><p>所以：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li><li>渲染完毕后，<code>JS</code>线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV6YSS?w=506&h=570"></p><p><img lazyload src="/images/loading.svg" data-src="https://segmentfault.com/img/bV7W88?w=479&h=457"></p><p><strong><code>new Promise</code>里的函数是直接执行的算做主程序里，而且<code>.then</code>后面的才会放到微任务中。</strong></p><p><strong>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</strong></p><p>官方版本中，是标准的<code>microtask</code>形式<br><code>polyfill</code>，一般都是通过<code>setTimeout</code>模拟的，所以是<code>macrotask</code>形式<br>请特别注意这两点区别</p><p>注意，有一些浏览器执行结果不一样（因为它们可能把<code>microtask</code>当成<code>macrotask</code>来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p><p><code>Mutation Observer</code>可以用来实现<code>microtask</code>（它属于<code>microtask</code>，优先级小于<code>Promise</code>，一般是<code>Promise</code>不支持时才会这样做）</p><p>它是<code>HTML5</code>中的新特性，作用是：监听一个<code>DOM</code>变动，当<code>DOM</code>对象树发生任何变动时，<code>Mutation Observer</code>会得到通知</p><p>像以前的<code>Vue</code>源码中就是利用它来模拟<code>nextTick</code>的，具体原理是，创建一个<code>TextNode</code>并监听内容变化，然后要<code>nextTick</code>的时候去改一下这个节点的文本内容，如下：（<code>Vue</code>的源码，未修改）</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var counter=1</span><br><span class="line">var observer=newMutationObserver(nextTickHandler)</span><br><span class="line">var textNode=document.createTextNode(String(counter))</span><br><span class="line">observer.observe(textNode,&#123;characterData:true&#125;)</span><br><span class="line">timerFunc=()=&gt;&#123;</span><br><span class="line">    counter=(counter+1)%2</span><br><span class="line">    textNode.data=String(counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>不过，现在的<code>Vue（2.5+）</code>的<code>nextTick</code>实现移除了<code>Mutation Observer</code>的方式（据说是兼容性原因），取而代之的是使用<code>MessageChannel</code>（当然，默认情况仍然是<code>Promise</code>，不支持才兼容的）。</p><p><code>MessageChannel</code>属于宏任务，优先级是：<code>setImmediate-&gt;MessageChannel-&gt;setTimeout</code>，所以<code>Vue（2.5+）</code>内部的<code>nextTick</code>与<code>2.4</code>及之前的实现是不一样的，需要注意下。</p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 【转载】浏览器渲染机制</li><li><strong>作者:</strong> ped-Yc</li><li><strong>创建于 :</strong> 2021-03-02 20:13:22</li><li><strong>更新于 :</strong> 2024-07-11 11:17:03</li><li><strong>链接:</strong> https://ped-yc.github.io/2021/03/02/ReprintBrowserRender/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/browser/">#browser</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2021/03/06/someInterestingQuestions03/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">【一些有趣的问题】03，浮点数</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2021/02/25/someInterestingQuestions02/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">【一些有趣的问题】02，事件循环</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">评论</div><div id="gitalk-container"></div><script data-swup-reload-script src="//cdn.staticfile.org/gitalk/1.8.0/gitalk.min.js"></script><script data-swup-reload-script>function loadGitalk(){let t=decodeURI(location.pathname);t.length>50&&(t=t.substring(0,47)+"...");try{Gitalk&&new Gitalk({clientID:"Ov23liQZt4TG95jUky9q",clientSecret:"215c6f1b9db7bfde28028f240b935d1929d4052a",repo:"gitalk",owner:"ped-yc",admin:["ped-yc"],id:t,language:"zh-CN",proxy:"https://github.com/login/oauth/access_token"}).render("gitalk-container")}catch(t){window.Gitalk=null}}{const t=setTimeout(()=>{loadGitalk(),clearTimeout(t)},1e3)}</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">此页目录</div><div class="page-title">【转载】浏览器渲染机制</div><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84"><span class="nav-text">浏览器是多进程的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9A"><span class="nav-text">浏览器包含的进程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-text">浏览器多进程的优势</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%82%B9%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="nav-text">重点是浏览器内核（渲染进程）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GUI%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B"><span class="nav-text">GUI渲染线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS%E5%BC%95%E6%93%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">JS引擎线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%BA%BF%E7%A8%8B"><span class="nav-text">事件触发线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E8%A7%A6%E5%8F%91%E5%99%A8%E7%BA%BF%E7%A8%8B"><span class="nav-text">定时触发器线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5http%E8%AF%B7%E6%B1%82%E7%BA%BF%E7%A8%8B"><span class="nav-text">异步http请求线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Browser-%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-text">Browser 主进程和浏览器内核（渲染进程）的通信过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">浏览器内核（渲染进程）中线程之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="nav-text">总结浏览器渲染流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%9B%BE%E5%B1%82%E5%92%8C%E5%A4%8D%E5%90%88%E5%9B%BE%E5%B1%82"><span class="nav-text">普通图层和复合图层</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8EEvent-Loop%E8%B0%88JS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-text">从Event Loop谈JS的运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise%E6%97%B6%E4%BB%A3%E7%9A%84microtask%E4%B8%8Emacrotask"><span class="nav-text">Promise时代的microtask与macrotask</span></a></li></ol></li></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">ped-Yc</a><p class="post-count space-x-0.5"><span>共 26 篇文章 </span><span>共 35.7k 字</span></p></div><script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.4</a></span></div><div class="icp-info my-1"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn"></a></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div></main><script src="/js/libs/Swup.min.js"></script><script src="/js/libs/SwupSlideTheme.min.js"></script><script src="/js/libs/SwupScriptsPlugin.min.js"></script><script src="/js/libs/SwupProgressPlugin.min.js"></script><script src="/js/libs/SwupScrollPlugin.min.js"></script><script src="/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/tools/imageViewer.js" type="module"></script><script src="/js/utils.js" type="module"></script><script src="/js/main.js" type="module"></script><script src="/js/layouts/navbarShrink.js" type="module"></script><script src="/js/tools/scrollTopBottom.js" type="module"></script><script src="/js/tools/lightDarkSwitch.js" type="module"></script><script src="/js/layouts/categoryList.js" type="module"></script><script src="/js/tools/codeBlock.js" type="module"></script><script src="/js/layouts/lazyload.js" type="module"></script><script src="/js/tools/runtime.js"></script><script src="/js/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/libs/Typed.min.js"></script><script src="/js/plugins/typed.js" type="module"></script><div class="post-scripts" data-swup-reload-script><script src="/js/tools/tocToggle.js" type="module"></script><script src="/js/layouts/toc.js" type="module"></script><script src="/js/plugins/tabs.js" type="module"></script></div></body></html>